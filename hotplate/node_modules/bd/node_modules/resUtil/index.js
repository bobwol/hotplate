
var 
  dummy
, hotplate =  require('hotplate')
, mongoose = require('mongoose')
;

app = hotplate.app;

exports.hotHooks = hooks = {}


exports.checkFindOneResponse = function( err, doc, next, cb ){
  var e = hotplate.getModule('hotError').errors;

  if(err ){
    next(new e.RuntimeError( err ) );
  } else {
    if( ! doc  ){
      next( new e.NotFoundError() );
    } else {
      cb();
    }
  }
}

exports.checkFindResponse = function( err, doc, next, cb ){
  var e = hotplate.getModule('hotError').errors;

  if(err ){
    next(new e.RuntimeError( err ) );
  } else {
    if( ! doc || doc.length == 0 ){
      next( new e.NotFoundError() );
    } else {
      cb();
    }
  }
}


exports.checkUpdateResponse = function( err, doc, next, cb) {

  var e = hotplate.getModule('hotError').errors;

  if( err ){
    next( new e.RuntimeError( err ) );
  } else {
    if( ! doc ){
      next( new e.NotFoundError() );
    } else {
      cb();
    }
  }
}



exports.makeUpdateObject = function(prefix, data){

  // Make up update object
  var updateObject = {}
   for( var k in data ){
     updateObject[ prefix + k ] = data[k];
  }
  return { $set: updateObject } ;
}



exports.parametersAreMissing = function(obj, attributes, errors, next){

  var e = hotplate.getModule('hotError').errors;

  attributes.forEach(function(attribute){
    if( typeof(obj) === 'undefined' || typeof(obj[attribute]) == 'undefined'){
      errors.push( { field: attribute, message: 'Required attribute not provided: ' + attribute, mustChange: false } );
    }
  });

  if( errors.length && typeof(next) === 'function' ){
    next( new e.ValidationError( "Validation error, missing parameters", errors ) );
    return true;
  }
  return false;
}


exports.parametersAreEmpty = function(obj, attributes, errors, next){

  var e = hotplate.getModule('hotError').errors;

  attributes.forEach(function(attribute){
    if( typeof( obj[attribute] ) !== 'undefined' && obj[attribute] == '' ){
      errors.push( { field: attribute, message: 'Value cannot be empty', mustChange: false } );
    }
  });

  return exports.respondIfErrors( errors, next );

}

exports.respondIfErrors = function( errors, next ){

  var e = hotplate.getModule('hotError').errors;

  if( errors.length && typeof(next) === 'function' ) {
    next( new e.ValidationError('Validation error', errors ) );
    return true;
  }
  return false;
}

exports.findAndSave = function( model, query, updater, next ){

  model.findOne( query, function( err, doc ) {
    if( err ){
      next( err, null );
    } else {
      if(! doc ){
        next( new Error("Object to save not found"), null );
      } else {

        // Run the updater and save...
        updater( doc );
        doc.save( next );
      }
    }
  });
}


/*

// UNUSED
function makeValidationErrorFromMongoose(err, prefix, message){

  var errors = [];
  var e = hotplate.getModule('hotError').errors; 

  for( var y in err.errors ){
    var yy = y.replace(prefix, '');
    errors.push( { field: yy, message:err.errors[y].type } );
  }
  return new e.ValidationError(message, errors) ;
}
*/


