var 
  dummy
, hotplate =  require('hotplate')
, path = require('path')
, mongoose = require('mongoose')
, Schema = mongoose.Schema
, ObjectId = Schema.ObjectId
, async = require('async')
, util = require('util')
, mongoUtil = require('mongoUtil')
, ObjectId = require('mongoWrapper').ObjectId
, checkObjectId = require('mongoWrapper').checkObjectId
, db = hotplate.get('db')
;

app = hotplate.app;

exports.hotHooks = hooks = {}

hooks.creatingUser = function( done, u ){
  u.settings = u.settings || {};
  u.settings.email = u.registerEmail; 
  done( null );
}

hooks.creatingWorkspace = function( done, u, w ){

  w.access[0].settings = {};
  w.access[0].settings.localEmail = u.registerEmail; 

  w.settings = w.settings || {};
  w.settings.tag = "Your tagline here";
  w.settings.longName = "Your workspace's long name"
  done( null );
}


hooks.init = function( done ){
  done( null );
}

hooks.enrichAuthUserSchema = function( done, User ){

  User.add( { settings: {
    name     : { type: String, index: true, set: mongoUtil.trim(40) },
    lastName : { type: String, index: true, set: mongoUtil.trim(40) },
    email    : { type: String, index: true, set: mongoUtil.trimAndLowerCase(80) },
  }});

  done( null );
}

hooks.enrichAuthWorkspaceSchema = function( done, Workspace) {

  Workspace.add({
    settings: {
      tag            : { type: String, index: false, set: mongoUtil.trim(150) } ,
      longName       : { type: String, index: false, set: mongoUtil.trim(50) },
  } } );

  done( null );
}

hooks.enrichAuthAccessSchema = function( done, Access ) {

  Access.add( { settings: {
    adminFlag      : { type: Boolean, index: true },
    localEmail     : { type: String,  index: true, set: mongoUtil.trimAndLowerCase(80) },
  } });

  done( null );
}


hooks.run = function( done ){

  var resUtils = hotplate.getModule('hotResUtils');

  app.get( '/call/:workspaceIdCall/userConfig/:userId', getUserConfig );
  app.put( '/call/:workspaceIdCall/userConfig/:userId', putUserConfig );



  app.get( '/call/userConfigNoWorkspace/:userId', getUserConfigNoWorkspace );
  app.put( '/call/userConfigNoWorkspace/:userId', putUserConfigNoWorkspace );


  // app.get( '/call/:workspaceIdCall/workspaceConfig/:workspaceId', getWorkspaceConfig );


  app.get( '/call/:workspaceIdCall/workspaceConfig/:workspaceId', resUtils.makeGet( new resUtils.Config( {
    collection:'workspaces',
    storeName:  'workspaceConfig',
    paramsIds: [ 'workspaceId' ],
    manipulateDocBeforeSend: function(req, next,    doc, cb){ 
      var o = doc.settings; o._id = doc._id;
      cb( o );
    },

    checkPermissions:function( req, next, cb ) {

      // Asking user needs to be in the workspace's `access` list
      if ( this.fetchedDoc.access.filter( function(o){ return o._id.toString() === req.application.user._id.toString(); } ).length ){
        cb();
      } else {
        next( new this.e.ForbiddenError() );
      }
    },

  } ) ) );


  // app.put( '/call/:workspaceIdCall/workspaceConfig/:workspaceId', putWorkspaceConfig );
  app.put( '/call/:workspaceIdCall/workspaceConfig/:workspaceId', resUtils.makePut( new resUtils.Config({

    schema: new resUtils.SimpleSchema({
      longName: { type: 'string', notEmpty: true, trim: 35 },
      tag     : { type: 'string', notEmpty: true, notEmpty: true, trim: 70 },
      _id     : { type: 'id', isRequired: true, doNotSave: true },
      _tabId  : { type: 'id', doNotSave: true  },
    }),

    collection:   'workspaces',
    storeName:    'workspaceConfig',
    paramsIds:    [ 'workspaceId' ],
    updateObjectPrefix: 'settings.',

    checkPermissions:function( req, next, cb ) {
      // Asking user needs to be in the workspace's `access` list
      if ( resUtils.currentUserInWorkspaceAccess( req, this.fetchedDoc ) ){
        cb();
      } else {
        next( new this.e.ForbiddenError() );
      }
    },
    setBroadcastObject: function( req, next, cb ){
      // Returns just the settings attribute, adding _id by hand
      this.broadcastObject = this.fetchedDoc.settings;
      this.broadcastObject._id = this.fetchedDoc._id;
      cb();
    },
  } ) ) );

  app.get( '/call/:workspaceIdCall/accessConfig/:userId', resUtils.makeGet( new resUtils.Config({

    collection:'workspaces',
    storeName:  'workspaceConfig',
    paramsIds: [ 'userId' ],
    findOne: function( req, next, cb ) {
      this.collectionObject.findOne({ _id: req.application.workspace._id , 'access._id': ObjectId( req.params.userId) }, cb )
    },
    manipulateDocBeforeSend: function(req, next,    doc, cb){
      var r = doc.access.filter( function(o) { return o._id.toString() === req.params.userId.toString() } )[0]; // Find the right _id
      r.settings._id = r._id; // Add the _id property artificially
      r = r.settings; // Just get the settings
      cb( r );
    },
    checkPermissions:function( req, next, cb ) {

      // Asking user needs to be in the workspace's `access` list
      if ( resUtils.currentUserInWorkspaceAccess( req, this.fetchedDoc ) ){
        cb();
      } else {
        next( new this.e.ForbiddenError() );
      }
    },

  }) ) );


  app.put( '/call/:workspaceIdCall/accessConfig/:userId', putAccessConfig );

  // app.put('/emptyResponse/self', function(req,res,next){ res.send(''); } );
  // app.get('/emptyResponse/self', function(req,res,next){ res.send(''); } );
  //
  // app.get( '/call/userConfig', getUserConfigQuery );

  done( null );
}


hooks.pageElementsPerPage = function( done, elements, req, pageName ){

  var resUtils = hotplate.getModule('hotResUtils');


  switch(pageName){
    case 'hotDojoAppContainer/container':

      var userConfig, accessConfig, workspaceConfig;

      workspaceConfig     = req.application.workspace.settings;
      workspaceConfig._id = req.application.workspace._id;

      userConfig     = req.application.user.settings;
      userConfig._id = req.application.user._id;

      accessConfig     = req.application.access.settings;
      accessConfig._id = req.application.user._id;

      // Sending the page out
      done( null, {
              moduleName: 'bd', result: {
                jses: ['bd.js'],
                csses: ['bd.css'],
                vars: [
                  { name: 'userConfig', value: userConfig },
                  { name: 'accessConfig', value:accessConfig },
                  { name: 'workspaceConfig', value:workspaceConfig } 
                ], 
              }
      });
    break;

    // Add an extra div to the "No workspaces to pick!" page, so that
    // a user can click on their config if they like (they are logged in after all)
    case 'hotDojoAuth/pickButEmptyPage':

      done( null, {
               moduleName: 'bd', result: {
                 body: elements.body.replace('</div></body>', '<div id="userConfig"></div></div></body>'),
                 jses: ['container.js'],
              }
      });
    break;

    default:
      done( null, { moduleName: 'bd', result: {} }  );
    break;
  }
}


// Simply activate path to client files
hooks.clientPaths = function( done ){
  done( null, { moduleName: 'bd', result: [ path.join(__dirname, '../client') ] } );
}


hooks.stores = function( done ){
  done( null, {
    accessConfig         : { target: '/call/:workspaceIdCall/accessConfig/',    idProperty: '_id', sortParam: 'sortBy', },
    workspaceConfig      : { target: '/call/:workspaceIdCall/workspaceConfig/', idProperty: '_id', sortParam: 'sortBy', },
    userConfig           : { target: '/call/:workspaceIdCall/userConfig/',      idProperty: '_id', sortParam: 'sortBy', },
    userConfigNoWorkspace: { target: '/call/userConfigNoWorkspace/',            idProperty: '_id', sortParam: 'sortBy', },
  });
}


hooks.storePermissions = function( done, req, store, doc ){

  switch( store ){

    // userConfig

    case 'userConfig/put':
      // * Configuration MUST be owned by user OR
      // * User MUST be admin TODO
      var userToPut = doc;
      if( req.application.user._id.toString() === userToPut._id.toString() ){
        done( null, true );
       } else {
        done( null, false );
      }
    break;
    case 'userConfig/get':
      // * Configuration MUST be owned by a user within the workspace
      var userToGet = doc;
      if ( req.application.workspace.access.filter( function(o){ return o._id.toString() === userToGet._id.toString(); } ).length ){
        done( null, true );
      } else {
        done( null, false );
      }
    break;


    case 'accessConfig/put':
      // * Workspace MUST be accessible by user AND
      // * User must be owner of accessConfig data
      var workspaceToPut = doc;
      var data = req.body;
      if ( workspaceToPut.access.filter( function(o){ return o._id.toString() === req.application.user._id.toString(); } ).length &&
           data._id.toString() === req.application.user._id.toString() ){
        done( null, true );
       } else {
        done( null, false );
      }
    break;

    default:
      done( null, false );
    break;
  }

}


hooks.sharedFunctions = function( done ) {
  var result = {};
  done( null, { moduleName: 'bd', result: result } );
}


function putAccessConfig( req, res, next ){

  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var Validators = hotplate.getModule('hotSharedCode').sharedFunctions.hotCommonValidators; 
  var e = hotplate.getModule('hotError').errors;
  var perms = hotplate.getModule('hotPerms');
  var messages = hotplate.getModule('hotMessages');
  var errors = [];

  var Workspace = mongoose.model('Workspace');

  // Check mongo IDs
  if( ! checkObjectIdAsync( req.body._tabId, "Tab ID", next )) return;
  if( ! checkObjectIdAsync( req.params.userId, "User ID", next )) return;


  // Check for required parameters
  // if( resUtils.parametersAreEmpty( req.body, ['localEmail'], errors, next ) ) return; // FOR FUTURE NEEDS

  // Validate passed fields
  if( ! Validators.email(req.body.localEmail) ){
     errors.push( { field: 'localEmail' , message: Validators.email(false), mustChange: false } );
  }
  if( resUtils.respondIfErrors( errors, next ) ) return;


  // Make up update object

  Workspace.findOne({ _id: req.application.workspace._id , 'access._id': req.params.userId }
                   , function( err, doc){
    resUtils.checkFindOneResponse(err, doc, next, function(){

      perms.checkPermissions( req, next, 'accessConfig/put', doc, function(){

        var settings = doc.access.id( req.params.userId ).settings;

        for( var k in req.body ) settings[k] = req.body[k];

        doc.save( function( err, doc ){
          resUtils.checkErr( err, doc, next, function(){
        
            // Send empty response...
            sendResponse( res );
 
            // Broadcast the change
            var r = settings.toObject();
            r._id = req.params.userId;
            messages.sendToTabsOfWorkspace(req.application.workspace._id,
                                           req.body._tabId,
                                           req.application.user._id,
                                           'storeUpdate',
                                           { storeName: 'accessConfig', objectId: req.params.userId, object: r, remote: true } );
 
          });
        });
      });
    });
  });

}



function getUserConfig( req, res, next ){
 
  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var User = mongoose.model('User');
  var e = hotplate.getModule('hotError').errors;
  var perms = hotplate.getModule('hotPerms');

  // Check mongo IDs
  if( ! checkObjectIdAsync( req.params.userId, "User ID", next )) return;

  User.findOne({ _id: req.params.userId } , function( err, doc){
    resUtils.checkFindOneResponse(err, doc, next, function(){
       perms.checkPermissions( req, next, 'userConfig/get', doc, function(){
         var obj = doc.settings.toObject();
         sendResponse( res, obj );
      });
    });
  });
}

function getUserConfigNoWorkspace( req, res, next ){
 
  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var User = mongoose.model('User');
  var e = hotplate.getModule('hotError').errors;
  var perms = hotplate.getModule('hotPerms');

  // Check mongo IDs
  if( ! checkObjectIdAsync( req.params.userId, "User ID", next )) return;

  // Only the owner user can make this call (which is outside the workspace)
  // This is not part of the API. So, it's OK to check with the session
  // directly (this is used by the interactive "view your settings" form in the picker
  if( req.session.userId.toString() !== req.params.userId ){
    return next( new e.ForbiddenError() );        
  } 

  User.findOne({ _id: req.params.userId } , function( err, doc){
    resUtils.checkFindOneResponse(err, doc, next, function(){

      var obj = doc.settings.toObject();
      sendResponse( res, obj );
    });
  });
}


function putUserConfig( req, res, next ){

  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var Validators = hotplate.getModule('hotSharedCode').sharedFunctions.hotCommonValidators; 
  var errors = [];
  var User = mongoose.model('User');
  var e = hotplate.getModule('hotError').errors;
  var messages = hotplate.getModule('hotMessages');
  var perms = hotplate.getModule('hotPerms');


  // Check mongo IDs
  if( ! checkObjectIdAsync( req.body._tabId, "Tab ID", next )) return;
  if( ! checkObjectIdAsync( req.params.userId, "User ID", next )) return;

  // Check for required parameters
  // if( resUtils.parametersAreEmpty( req.body, ['localEmail'], errors, next ) ) return; // FOR FUTURE NEEDS

  // Validate passed fields
  if( ! Validators.email(req.body.email) ){
     errors.push( { field: 'email' , message: Validators.email(false), mustChange: false } );
  }
  if( resUtils.respondIfErrors( errors, next ) ) return;

  // Actually update the object on the database
  User.findById( req.params.userId, function( err, doc){ 
    resUtils.checkFindOneResponse( err, doc, next, function(){

      // Make up the object to be passed to the permission checking
      // var settings = doc.settings.toObject();
      // settings._id = doc._id;

      perms.checkPermissions( req, next, 'userConfig/put', doc, function(){

        for( var k in req.body ) doc.settings[k] = req.body[k];

        doc.save( function( err, doc) {
          resUtils.checkErr( err, doc, next, function(){

            // Send empty response...
            sendResponse( res );

            // Broadcast the change
            var r = doc.toObject().settings;
            r._id = doc._id;
            messages.sendToTabsOfWorkspace(req.application.workspace._id,
                             ObjectId( req.body._tabId), 
                             req.application.user._id,
                             'storeUpdate', 
                             { storeName: 'userConfig', objectId: req.params.userId, object: r, remote: true } );

          });
        });
      });
    });
  });
}

function putUserConfigNoWorkspace( req, res, next ){

  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var Validators = hotplate.getModule('hotSharedCode').sharedFunctions.hotCommonValidators; 
  var errors = [];
  var User = mongoose.model('User');
  var e = hotplate.getModule('hotError').errors;
  var messages = hotplate.getModule('hotMessages');
  var perms = hotplate.getModule('hotPerms');

  // Check mongo IDs
  if( ! checkObjectIdAsync( req.params.userId, "User ID", next )) return;

  req.body._id = req.params.userId;
       
  // Check for required parameters
  // if( resUtils.parametersAreEmpty( req.body, ['localEmail'], errors, next ) ) return; // FOR FUTURE NEEDS

  // Validate passed fields
  if( ! Validators.email(req.body.email) ){
     errors.push( { field: 'email' , message: Validators.email(false), mustChange: false } );
  }
  if( resUtils.respondIfErrors( errors, next ) ) return;

  // Only the owner user can make this call (which is outside the workspace)
  // This is not part of the API. So, it's OK to check with the session
  // directly (this is used by the interactive "view your settings" form in the picker
  if( req.session.userId.toString() !== req.body._id ){
    return next( new e.ForbiddenError() );        
  } 

  // Actually update the object on the database
  User.findById( req.params.userId, function( err, doc){ 
    resUtils.checkFindOneResponse( err, doc, next, function(){

      for( var k in req.body ) doc.settings[k] = req.body[k];

      doc.save( function( err, doc) {
        resUtils.checkErr( err, doc, next, function(){
          // Send empty response...
          sendResponse( res );
        });
      });
    });
  });
}

function checkObjectIdAsync( id, idName, next ){

  var e = hotplate.getModule('hotError').errors;
  if( ! checkObjectId( id ) ){
    next( new e.ValidationError( "Field not valid: " + idName ) );
    return false;
  }
  return true;
}



