
var 
  dummy
, hotplate =  require('hotplate')
, path = require('path')
, mongoose = require('mongoose')
, Schema = mongoose.Schema
, ObjectId = Schema.ObjectId
, async = require('async')
, util = require('util')
, mongoUtil = require('mongoUtil')
;

app = hotplate.app;

exports.hotHooks = hooks = {}

hooks.creatingUser = function( done, u ){
  u.settings.email = u.registerEmail; 
  done( null );
}

hooks.creatingWorkspace = function( done, u, w ){
  w.access[0].settings = {};
  w.access[0].settings.localEmail = u.registerEmail; 
  w.settings.tag = "Your tagline here";
  w.settings.longName = "Your workspace's long name"
  done( null );
}


hooks.init = function( done ){
  done( null );
}

hooks.enrichAuthUserSchema = function( done, User ){

  User.add( { settings: {
    name     : { type: String, index: true, set: mongoUtil.trim(40) },
    lastName : { type: String, index: true, set: mongoUtil.trim(40) },
    email    : { type: String, index: true, set: mongoUtil.trimAndLowerCase(80) },
    __v      : { type: Number, index: true },
  }});

  done( null );
}

hooks.enrichAuthWorkspaceSchema = function( done, Workspace) {

  Workspace.add({
    settings: {
      tag            : { type: String, index: false, set: mongoUtil.trim(150) } ,
      longName       : { type: String, index: false, set: mongoUtil.trim(50) },
      __v            : { type: Number, index: true },
  } } );

  done( null );
}

hooks.enrichAuthAccessSchema = function( done, Access ) {

  Access.add( { settings: {
    adminFlag      : { type: Boolean, index: true },
    localEmail     : { type: String,  index: true, set: mongoUtil.trimAndLowerCase(80) },
    __v            : { type: Number, index: true },
  } });

  done( null );
}


hooks.run = function( done ){

  // app.get( '/call/:workspaceIdCall/userConfig/:userId', getUserConfig );
  // app.put( '/call/:workspaceIdCall/userConfig/:userId', putUserConfig );
  // app.get( '/call/:workspaceIdCall/userConfig', getUserConfigQuery );
  app.get( '/call/userConfig/:userId', getUserConfig );
  app.put( '/call/userConfig/:userId', putUserConfig );
  app.get( '/call/userConfig', getUserConfigQuery );

  app.get( '/call/:workspaceIdCall/workspaceConfig/:workspaceId', getWorkspaceConfig );
  app.put( '/call/:workspaceIdCall/workspaceConfig/:workspaceId', putWorkspaceConfig );

  app.get( '/call/:workspaceIdCall/accessConfig/:userId', getAccessConfig );
  app.put( '/call/:workspaceIdCall/accessConfig/:userId', putAccessConfig );

  // app.put('/emptyResponse/self', function(req,res,next){ res.send(''); } );
  // app.get('/emptyResponse/self', function(req,res,next){ res.send(''); } );

  done( null );
}


hooks.pageElementsPerPage = function( done, elements, req, pageName ){

  var resUtils = hotplate.getModule('hotResUtils');


  switch(pageName){
    case 'hotDojoAppContainer/container':

      var userConfig, accessConfig, workspaceConfig;
      var User = mongoose.model('User');
      var Workspace = mongoose.model('Workspace');
      var workspaceSettings, userSettings, accessSettings;

      console.log(require('util').inspect(req.application, true, 5));

      workspaceConfig     = req.application.workspace.settings;
      workspaceConfig._id = req.application.workspace._id;

      userConfig     = req.application.user.settings;
      userConfig._id = req.application.user._id;

      accessConfig     = req.application.access.settings;
      accessConfig._id = req.application.user._id;

      // Sending the page out
      done( null, {
              moduleName: 'bd', result: {
                jses: ['bd.js'],
                csses: ['bd.css'],
                vars: [
                  { name: 'userConfig', value: userConfig },
                  { name: 'accessConfig', value:accessConfig },
                  { name: 'workspaceConfig', value:workspaceConfig } 
                ], 
              }
      });
    break;

    // Add an extra div to the "No workspaces to pick!" page, so that
    // a user can click on their config if they like (they are logged in after all)
    case 'hotDojoAuth/pickButEmptyPage':

      done( null, {
               moduleName: 'bd', result: {
                 body: elements.body.replace('</div></body>', '<div id="userConfig"></div></div></body>'),
                 jses: ['container.js'],
                 vars: [ { name: 'userId', value: req.session.userId } ],
              }
      });
    break;

    default:
      done( null, { moduleName: 'bd', result: {} }  );
    break;
  }
}


// Simply activate path to client files
hooks.clientPaths = function( done ){
  done( null, { moduleName: 'bd', result: [ path.join(__dirname, '../client') ] } );
}


hooks.stores = function( done ){
  done( null, {
    accessConfig   : { target: '/call/:workspaceIdCall/accessConfig/',    idProperty: '_id', sortParam: 'sortBy', },
    workspaceConfig: { target: '/call/:workspaceIdCall/workspaceConfig/', idProperty: '_id', sortParam: 'sortBy', },
    userConfig     : { target: '/call/userConfig/',                       idProperty: '_id', sortParam: 'sortBy', },
  });
}


hooks.storePermissions = function( done, req, store, data, doc ){

  switch( store ){

    // userConfig

    case 'userConfig/put':
      // * Configuration MUST be owned by user OR
      // * User MUST be admin TODO
      var userToPut = doc;
      if( req.application.user._id.toString() === userToPut._id.toString() ){
        done( null, true );
       } else {
        done( null, false );
      }
    break;
    case 'userConfig/get':
      // * Configuration MUST be owned by a user within the workspace
      var userToGet = doc;
      if ( req.application.workspace.access.filter( function(o){ return o._id.toString() === userToGet._id.toString(); } ).length ){
        done( null, true );
      } else {
        done( null, false );
      }
    break;

    // workspaceConfig

    case 'workspaceConfig/put':
      // * Workspace MUST be accessible by user AND
      // * User  MUST be admin TODO
      var workspaceToPut = doc;
      if ( workspaceToPut.access.filter( function(o){ return o._id.toString() === req.application.user._id.toString(); } ).length ){
        done( null, true );
       } else {
        done( null, false );
      }
    break;

    case 'workspaceConfig/get':
      // * Workspace MUST be accessible by user
      var workspaceToGet = doc;
      if ( workspaceToget.access.filter( function(o){ return o._id.toString() === req.application.user._id.toString(); } ).length ){
        done( null, true );
      } else {
        done( null, false );
      }
    break;

    // accessConfig

    case 'accessConfig/put':
      // * Workspace MUST be accessible by user AND
      // * User must be owner of accessConfig data
      var workspaceToPut = doc;
      if ( workspaceToPut.access.filter( function(o){ return o._id.toString() === req.application.user._id.toString(); } ).length &&
           data._id.toString() === req.application.user._id.toString() ){
        done( null, true );
       } else {
        done( null, false );
      }
    break;

    case 'accessConfig/get':
      // * Workspace MUST be accessible by user
      var workspaceToGet = doc;
      if ( WorkspaceToGet.access.filter( function(o){ return o._id.toString() === req.application.user._id.toString(); } ).length ){
        done( null, true );
      } else {
        done( null, false );
      }
    break;

    default:
      done( null, false );
    break;
  }

}


hooks.sharedFunctions = function( done ) {
  var result = {};
  done( null, { moduleName: 'bd', result: result } );
}


function getWorkspaceConfig( req, res, next ){
 
  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;
  var perms = hotplate.getModule('hotPerms');
  var Workspace = mongoose.model('Workspace');

  if( ! hotplate.mongoIdCheck(req.params.workspaceId ) )
    return next( new e.ValidationError( "Workspace ID not valid" ) );

  Workspace.findOne({ _id: req.params.workspaceId }, function( err, doc ){
    resUtils.checkFindOneResponse( err, doc, next, function(){

      perms.checkPermissions( req, next, 'workspaceConfig/get', req.body, doc, function(){
        sendResponse( res, doc.settings );
      });
    });
  });
}


function putWorkspaceConfig( req, res, next ){
 
  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;
  var perms = hotplate.getModule('hotPerms');
  var errors = [];
  var messages = hotplate.getModule('hotMessages');


  if( ! hotplate.mongoIdCheck(req.params.workspaceId ) )
    return next( new e.ValidationError( "Workspace ID not valid" ) );

  // Looks for a workspace. If it's there, answers without errors. If not,
  // answers with a very short error
  var Workspace = mongoose.model('Workspace');

  // Stop here if required parameters are empty
  if( resUtils.parametersAreEmpty(req.body, ['longName', 'tag'], errors, next) ) return; 

  Workspace.findById( req.params.workspaceId, function( err, doc ){
    resUtils.checkFindOneResponse( err, doc, next, function(){

      perms.checkPermissions( req, next, 'workspaceConfig/put', req.body, doc, function(){
   
        for( var k in req.body ) doc.settings[k] = req.body[k];

        doc.save( function( err, doc ) {
          resUtils.checkErr( err, doc, next, function(){

            // Send empty response...
            sendResponse( res );
         
            // Broadcast the change
            var r = doc.toObject().settings;
            r._id = doc._id;
            messages.sendToTabsOfWorkspace(req.application.workspace._id,
                                           req.body._tabId,
                                           req.application.user._id,
                                           'storeUpdate',
                                           { storeName: 'workspaceConfig', objectId: req.params.workspaceId, object: r, remote: true } );
          });

        });
      });
    });
  });
}


function getAccessConfig( req, res, next ){
 
  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;
  var perms = hotplate.getModule('hotPerms');
  var Workspace = mongoose.model('Workspace');
 
  if( ! hotplate.mongoIdCheck(req.params.userId ) )
    return next( new e.ValidationError( "User ID not valid" ) );

  Workspace.findOne({ _id: req.application.workspace._id , 'access._id': req.params.userId }
  //                  { 'access': { $elemMatch: { _id: req.application.user._id } } }, { strict: true } 
                    , function( err, doc){
    resUtils.checkFindOneResponse(err, doc, next, function(){

      perms.checkPermissions( req, next, 'accessConfig/get', null, doc, function(){

        var settings = doc.access.id( req.application.user._id ).settings;
        settings._id = doc._id;
        sendResponse( res, settings );
      });
    });
  });
}


function putAccessConfig( req, res, next ){

  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var Validators = hotplate.getModule('hotSharedCode').sharedFunctions.hotCommonValidators; 
  var e = hotplate.getModule('hotError').errors;
  var perms = hotplate.getModule('hotPerms');
  var messages = hotplate.getModule('hotMessages');
  var errors = [];

  var Workspace = mongoose.model('Workspace');


  if( ! hotplate.mongoIdCheck(req.params.userId ) )
    return next( new e.ValidationError( "User ID not valid" ) );

  // Check for required parameters
  // if( resUtils.parametersAreEmpty( req.body, ['localEmail'], errors, next ) ) return; // FOR FUTURE NEEDS

  // Validate passed fields
  if( ! Validators.email(req.body.localEmail) ){
     errors.push( { field: 'localEmail' , message: Validators.email(false), mustChange: false } );
  }
  if( resUtils.respondIfErrors( errors, next ) ) return;


  // Make up update object

  Workspace.findOne({ _id: req.application.workspace._id , 'access._id': req.params.userId }
                   , function( err, doc){
    resUtils.checkFindOneResponse(err, doc, next, function(){

      perms.checkPermissions( req, next, 'accessConfig/put', req.body, doc, function(){

        var settings = doc.access.id( req.params.userId ).settings;

        for( var k in req.body ) settings[k] = req.body[k];

        doc.save( function( err, doc ){
          resUtils.checkErr( err, doc, next, function(){
        
            // Send empty response...
            sendResponse( res );
 
            // Broadcast the change
            var r = settings.toObject();
            r._id = req.params.userId;
            messages.sendToTabsOfWorkspace(req.application.workspace._id,
                                           req.body._tabId,
                                           req.application.user._id,
                                           'storeUpdate',
                                           { storeName: 'accessConfig', objectId: req.params.userId, object: r, remote: true } );
 
          });
        });
      });
    });
  });

}



function getUserConfig( req, res, next ){
 
  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var User = mongoose.model('User');
  var e = hotplate.getModule('hotError').errors;
  var perms = hotplate.getModule('hotPerms');

  if( ! hotplate.mongoIdCheck(req.params.userId ) )
    return next( new e.ValidationError( "User ID not valid" ) );

  User.findOne({ _id: req.params.userId } , function( err, doc){
    resUtils.checkFindOneResponse(err, doc, next, function(){
      // perms.checkPermissions( req, next, 'userConfig/get', null, doc, function(){
         var obj = doc.settings.toObject();
         sendResponse( res, obj );
        // sendResponse( res );
      //});
    });
  });
}

function getUserConfigQuery( req, res, next ){
 
  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var User = mongoose.model('User');
  var e = hotplate.getModule('hotError').errors;

  //if( ! hotplate.mongoIdCheck(req.params.userId ) )
  //  return next( new e.ValidationError( "User ID not valid" ) );

  User.find({ } , function( err, docs){
    resUtils.checkFindOneResponse(err, docs, next, function(){
      var r = [];
      docs.forEach( function( item ) {
        item = item.toObject();
        var o = new Object();
        o = item.settings;
        o._id = item._id;
        r.push(o);
      });
      sendResponse( res, r );
    });
  });
}


function putUserConfig( req, res, next ){

  var resUtils = hotplate.getModule('hotResUtils');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var Validators = hotplate.getModule('hotSharedCode').sharedFunctions.hotCommonValidators; 
  var errors = [];
  var User = mongoose.model('User');
  var e = hotplate.getModule('hotError').errors;
  var messages = hotplate.getModule('hotMessages');
  var perms = hotplate.getModule('hotPerms');

  if( ! hotplate.mongoIdCheck(req.params.userId ) )
    return next( new e.ValidationError( "User ID not valid" ) );

  if( req.params._tabId && ! hotplate.mongoIdCheck(req.params._tabId ) )
    return next( new e.ValidationError( "TAB ID not valid" ) );


  req.body._id = req.params.userId;
       
  // Check for required parameters
  // if( resUtils.parametersAreEmpty( req.body, ['localEmail'], errors, next ) ) return; // FOR FUTURE NEEDS

  // Validate passed fields
  if( ! Validators.email(req.body.email) ){
     errors.push( { field: 'email' , message: Validators.email(false), mustChange: false } );
  }
  if( resUtils.respondIfErrors( errors, next ) ) return;

  // Actually update the object on the database
  User.findById( req.params.userId, function( err, doc){ 
    resUtils.checkFindOneResponse( err, doc, next, function(){

      // Make up the object to be passed to the permission checking
      //var settings = doc.settings.toObject();
      //settings._id = doc._id;

      // perms.checkPermissions( req, next, 'userConfig/put', req.body, doc, function(){

        for( var k in req.body ) doc.settings[k] = req.body[k];

        doc.save( function( err, doc) {
          resUtils.checkErr( err, doc, next, function(){

            // Send empty response...
            sendResponse( res );

            // Broadcast the change
            var r = doc.toObject().settings;
            r._id = doc._id;
            messages.sendToTabsOfWorkspace(req.application.workspace._id,
                             req.body._tabId, 
                             req.application.user._id,
                             'storeUpdate', 
                             { storeName: 'userConfig', objectId: req.params.userId, object: r, remote: true } );

          });
        });
      //});
    });
  });
}

