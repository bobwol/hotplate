/* TODO:

  * USE THE RIGHT VALIDATORS FROM THE GLOBAL ONES FOR THE SERVER (HELPER FUNCTION?)
  * MAKE SURE THINGS ARE VALIDATED CLIENT SIDE FIRST AS WELL TO AVOID UNECESSARY NETWORK TRAFFIC
  * WRITE DEFAULT FUNCTIONS TO RESPOND TO GET REQUESTS TOO
  * 


*/

var 
  dummy
, hotplate =  require('hotplate')
, path = require('path')
, mongoose = require('mongoose')
, Schema = mongoose.Schema
, ObjectId = Schema.ObjectId
, async = require('async')
, util = require('util')
;

app = hotplate.app;

exports.hotHooks = hooks = {}


hooks.init = function( done ){
  done(null);
}

hooks.enrichAuthUserSchema = function( done, User ){

  User.add( { settings: {
    name     : { type: String, index: true }, // Global name
    lastName : { type: String, index: true }, // Global lastName

  } });

  done( null );
}


hooks.enrichAuthWorkspaceSchema = function( done, Workspace) {

  Workspace.add({
    settings: {
      tag            : { type: String, index: false, validate: [ function(v){ return v.length < 5}, "Tag too long!"] },
      longName       : { type: String, index: false, validate: [ function(v){ return v.length < 5}, "Long name too long!"] },
  } });

  done( null );
}

hooks.enrichAuthAccessSchema = function( done, Access ) {
 

  Access.add( { settings: {
    adminFlag      : { type: Boolean, index: true },
    localName      : { type: String, index: true, validate: [ function(v){ return v.length < 5}, "Name too long!"]  },
    localLastName  : { type: String, index: true, validate: [ function(v){ return v.length < 5}, "Last name too long!"]  },
    localEmail     : { type: String, index: true },
    
  } });

  done( null );
}



hooks.run = function( done ){

  app.get( '/call/:workspaceIdCall/workspaceConfig/self', getWorkspaceConfig );
  app.put( '/call/:workspaceIdCall/workspaceConfig/self', putWorkspaceConfig );

  app.get( '/call/:workspaceIdCall/accessConfig/self', getAccessConfig );
  app.put( '/call/:workspaceIdCall/accessConfig/self', putAccessConfig );

  // app.get( '/call/:workspaceIdCall/accountConfig/self', getAccountConfig );
  // app.put( '/call/:workspaceIdCall/accountConfig/self', putAccountConfig );

  done( null );
}


hooks.pageElementsPerPage = function( done, elements, req, pageName ){

  if( pageName  === 'hotDojoAppContainer/container' ){

    done( null, {
      moduleName: 'bd', result: {
        jses: ['bd.js'],
        csses: ['bd.css']
      }
    });
  } else {
    done( null, { moduleName: 'bd', result: {} }  );
  }
}



// Simply activate path to client files
hooks.clientPaths = function( done ){
  done( null, { moduleName: 'bd', result: [ path.join(__dirname, '../client') ] } );
}


hooks.stores = function( done ){
  done( null, {

    userConfig  :      { target: '/call/:workspaceIdCall/accessConfig/',        idProperty: '_id', sortParam: 'sortBy', },
    workspaceSettings: { target: '/call/:workspaceIdCall/workspaceConfig/', idProperty: '_id', sortParam: 'sortBy', },
  });
}



function getWorkspaceConfig( req, res, next ){
 
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;

  // Looks for a workspace. If it's there, answers without errors. If not,
  // answers with a very short error
  var Workspace = mongoose.model('Workspace');
  Workspace.findOne({ _id: req.application.workspaceId }, function(err, doc){
    if(err ){
      next(new e.RuntimeError( err ) );
    } else {
      sendResponse( res, { data: doc.settings  } );
    }
  });
}


function putWorkspaceConfig( req, res, next ){
 
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;

  // Looks for a workspace. If it's there, answers without errors. If not,
  // answers with a very short error
  var Workspace = mongoose.model('Workspace');

  // Delete the ID and the version since there's no point,
  //  _id is set as "self" and __v is unimportant
  delete req.body._id;
  delete req.body.__v;

  var updateObject = makeUpdateObject('settings.', req.body );

  Workspace.findByIdAndUpdate( req.application.workspaceId, updateObject, function( err, doc ){
    sendDefaultPutResponse( err, doc, res, 'settings.', 'Validation problems!', 'Data saved!', next);
  });

}


function getAccessConfig( req, res, next ){
 
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;

  var Workspace = mongoose.model('Workspace');

 
  Workspace.findOne({ _id: req.application.workspaceId , 'access._id': req.application.userId } , 
                    { 'access': { $elemMatch: { _id: req.application.userId } }} 
                    , function( err, doc){
    if(err || ! doc ){
      if( ! err ) err = new e.NotFoundError( );
      next( err );
    } else {
      sendResponse( res, { data: doc.access[0].settings } );
    }
  });
}



function putAccessConfig( req, res, next ){
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;

  var Workspace = mongoose.model('Workspace');
       
  // Delete the ID and the version since there's no point,
  //  _id is set as "self" and __v is unimportant
  delete req.body._id;
  delete req.body.__v;

  var updateObject = makeUpdateObject('access.$.settings.', req.body );
  
  // Good //
  //Workspace.findOneAndUpdate( { _id: req.application.workspaceId, 'access._id': req.application.userId }, updateObject).exec(function( err, doc){ 
  Workspace.update( { _id: req.application.workspaceId, 'access._id': req.application.userId }, updateObject).exec(function( err, doc){ 
    sendDefaultPutResponse( err, doc, res, 'access.$.settings.', 'Validation problems!', 'Data saved!', next);
  });

     
}



function sendDefaultPutResponse( err, doc, res, prefix, errMessage, okMessage, next) {

  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;


  if( err ){
    if( err.name == 'ValidationError' ){
      next( makeValidationErrorFromMongoose(err, prefix, errMessage ));
    } else {
      next( new e.RuntimeError( err ) );
    }
  } else {
    if( ! doc ){
      next( new e.NotFoundError() );
    } else {
      sendResponse( res, { message: okMessage }  );
    }
  }
}

function makeUpdateObject(prefix, data){

  // Make up update object
  var updateObject = {}
   for( var k in data ){
     updateObject[ prefix + k ] = data[k];
  }
  return updateObject;

}

function makeValidationErrorFromMongoose(err, prefix, message){

  var errors = [];
  var e = hotplate.getModule('hotError').errors; 

  for( var y in err.errors ){
    var yy = y.replace(prefix, '');
    errors.push( { field: yy, message:err.errors[y].type } );
  }
  return new e.ValidationError(message, errors) ;
}



/* CURRENTLY UNUSED */

/*
function findAndSave( model, query, updater, next ){

  model.findOne( query, function( err, doc ) {
    if( err ){
      next( err, null );
    } else {
      if(! doc ){
        next( new Error("Object to save not found"), null );
      } else {

        // Run the updater and save...
        updater( doc );
        doc.save( next );
        
      }
    }
  });
}


function sendSaveResponse( err, doc, res, next ){

  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;
  var errors = [];

  // Something went wrong
  if( err ){

    // It's a validation error. It's a "soft" problem, will simply
    // throw the ValidationError error with the right errors set
    if( err.name == 'ValidationError' ){
      console.log( err.errors );
      for( var y in err.errors ){
        errors.push( { field: y, message:err.errors[y].type } );
        next( new e.ValidationError('Validation problem', errors) );
      }
    // It's a more serious error, throw the exception
    } else {
      next( new e.RuntimeError( err ) );
    }

  // All good and saved
  } else {
    sendResponse( res, { message: "Data saved" }  );
  }

};

*/
