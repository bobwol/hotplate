
define([
     "dojo/_base/declare",
     "dojo/topic",
     "dojo/aspect",
     "hotplate/hotDojoStores/stores",
     "hotplate/hotMessages/messages",

     "dojo/domReady!",
   ], function(
   declare
   , topic
   , aspect
   , stores
   , messages
 ){


  // CHANGES WITHIN
  //
  // For each "put" and "remove" in the store, publish a message locally
  // about the store being changed
  // Basically, after a put() or a remove(), it will publish a topic (storeUpdate, storeCreate or storeErase )
  // so that other parts of the application will be able to listen up.
  // NOTE: The _tabId is added to each request, so that the server will know not to broadcast the change
  //       here (since it was a local one, no point in knowing about it twice).
  // 
  console.log("I AM HEREEEEEEEEEEEEEEEE");
  topic.subscribe( 'hotplate/hotDojoStores/newStore', function( storeName, store ){

    console.log("Enhancing " + storeName );
    // Before anything else, create _tabId so that the JsonRest store will receive
    // each time, and will know which tab NOT to notify of the change
    aspect.before( store, 'put', function( object, options ){
      console.log("ADDING TAB ID:");
      console.log(object);
      console.log(messages);
      console.log(messages.tabId);
      object._tabId = messages.tabId;
      OO = object;
      console.log(object);
      return [ object, options ];
    });

    // But before storing it in the local cache, delete it
    aspect.before( store.memCache, 'put', function( object, options ){
      delete object._tabId;
      return [ object, options ];
    });

    // After making a change to the cache, well, the main store has definitely
    // worked, so it's time for an app-wide message
    aspect.after( store.memCache, 'put', function( object, options ){
      var eventName;
      var identity = store.idProperty;
      eventName = object[identity] ? 'storeUpdate' : 'storeCreate';

      if( ! options || ( options && ! options.dontPublish ) ) {
        topic.publish(eventName, null, { storeName: storeName, objectId: object[identity], object: object, remote: false }  );
      }
    }, true );


    // After making a change to the cache, well, the main store has definitely
    // worked, so it's time for an app-wide message
    aspect.after( store.memCache, 'add', function( object, options ){
      var eventName;
      eventName = 'storeCreate';

      if( ! options || ( options && ! options.dontPublish ) ) {
        topic.publish(eventName, null, { storeName: storeName, object: object, remote: false }  );
      }
    }, true );



    aspect.after( store.memCache, 'remove', function( objectId, options ){
      var identity = store.idProperty;
      if( ! options || ( options && ! options.dontPublish ) ) {
        topic.publish('storeRemove', null, { storeName: storeName, objectId: objectId, remote: false }  );
      }
    }, true );
  });

  // CHANGES FROM THE OUTSIDE
  //
  // Update local stores according to Comet messages
  // NOTE: The comet message will come from the server after a put() (that is, the server will queue it),
  //       at which point the local cache will need to be updated with the new values.
  //       New topics (which will guarantee that the cache is in a good state at time emission) wll also 
  //       be published
  
  topic.subscribe('storeUpdate', function( from, message){
    // A Comet changed a remote store. Refresh the Something came from a Comet. 
    if( message.remote ){

      // Inject the data into the store's cache, run a notify on the main store,
      // publish an afterCache event
      var store = stores(message.storeName);
      store.memCache.put( message.object, { dontPublish: true } );
      store.notify( message.object, message.object[store.idProperty]);
      topic.publish('storeUpdate/afterCache', from, message);
    }
  });

  topic.subscribe('storeCreate', function( from, message ){
    // A Comet changed a remote store. Refresh the Something came from a Comet. 
    if( message.remote ){

      // Inject the data into the store's cache, run a notify on the main store,
      // publish an afterCache event
      var store = stores(message.storeName);
      store.memCache.put( message.object, { dontPublish: true } );
      store.noCache.notify( message.object, null );
      topic.publish('storeCreate/afterCache', from, message);
    }
  });

  topic.subscribe('storeRemove', function( from, message){
    // A Comet changed a remote store. Refresh the Something came from a Comet. 
    if( message.remote ){

      // Inject the data into the store's cache, run a notify on the main store,
      // publish an afterCache event
      var store = stores(message.storeName);
      store.memCache.remove( message.objectId, { dontPublish: true } );
      store.noCache.notify( null, message.objectId );
      topic.publish('storeRemove/afterCache', from, message);
    }
  });

  return {};

});


