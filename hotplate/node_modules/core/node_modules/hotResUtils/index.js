
var 
  dummy
, hotplate =  require('hotplate')
, url = require('url')
, async = require('async')
, checkObjectId = hotplate.get('dbCheckObjectId')
;


exports.hotHooks = hooks = {}


var SimpleSchema = function( structure, options ){
  this.structure = structure;
  this.options = typeof( options ) !== 'undefined' ? options : {};
  this.cameEmpty = {};
}

SimpleSchema.prototype.cast = function( object ){

/*
    schema: {
      longName: { type: 'string', isRequired: true, notEmpty: true, trim: 35 },
      tag     : { type: 'number', notEmpty: true, max: 30 },
      _id     : { type: 'id', isRequired: true },
      _tabId  : { type: 'id', doNotSave: true },
    }
  */

  var type;

  // Scan passed object
  for( var k in object ){

      definition = this.structure[ k ];

      if( typeof(definition) === 'undefined' ) return;

      // Set the internal hash this.cameEmpty if the field arrived empty
      // This will then be used later at checking time
      // Note: arrays are a special case: it's an array if multiple fields have 
      // the same `name` attribute. Arrays are not checked.
      if( ! Array.isArray( object[ k ] ) && object[ k ] == '' ) this.cameEmpty[ k ] = true;

      switch(definition.type){

        case 'string':
          object[ k ] = object[ k ].toString();
          // Trim it if necessary. Since there is no chanche of adding an error,
          // I consider this part of casting
          if( definition.trim ) object[ k ] = object[ k ].substr( 0, definition.trim );
          if( definition.lowercase) object[ k ] = object[ k ].toLowerCase();
          if( definition.uppercase) object[ k ] = object[ k ].toLowerCase();
        break;
   
        case 'number':
          object[ k ] = Number( object[k] );
        break;

        case 'date':
          object[ k ] = new Date( object[ k ] );
        break;

        case 'id':
        break;

        case 'array':
          if( ! Array.isArray( object[ k ] ) ){
             // Turn into an Array with 1 value: the original object
             object[ k ] = [ object[ k ] ];
          }
        break;


      }
 
  }
  
}

SimpleSchema.prototype.check = function( object, errors ){

/*
    schema: {
      longName: { type: 'string', isRequired: true, notEmpty: true, trim: 35 },
      tag     : { type: 'number', notEmpty: true, max: 30 },
      _id     : { type: 'id', isRequired: true },
      _tabId  : { type: 'id', doNotSave: true },
    }
  */

  var type;

  if( ! Array.isArray( errors ) ) errors = [];

  // Use the global validator first
  if( typeof( this.options.validator) !== 'undefined' ){
    this.options.validator.call( this, object, errors );
  }
  

  // Scan passed object
  for( var k in object ){

    // First of all, if it's not in the schema, it's not allowed
    if( typeof( this.structure[ k ] ) === 'undefined' ){
      errors.push( { field: k, message: 'Field not allowed: ' + k, mustChange: false } );
    } else {

      // Get the value type
      definition = this.structure[ k ];

      // Check if the value was empty when it was submitted and it shouldn't have been
      if( definition.notEmpty && this.cameEmpty[ k ] ){
          errors.push( { field: k, message: 'Field cannot be empty: ' + k, mustChange: true } );
      }

      // Apply fieldValidators
      if( typeof( definition.fieldValidator) !== 'undefined' ){
        var msg = definition.fieldValidator( false );
        if( ! definition.fieldValidator( object[ k ] ) )
          errors.push( { field: k, message: msg, mustChange: true } );
      }

      switch(definition.type){

        case 'string':
        break;
   
        case 'number':
          // Check its range
          if( typeof( definition.max ) !== 'undefined'  && object[k] > definition.max )
            errors.push( { field: k, message: 'Field is too high: ' + k, mustChange: true } );
          if( typeof( definition.min ) !== 'undefined'  && object[k] < definition.min )
            errors.push( { field: k, message: 'Field is too low: ' + k, mustChange: true } );
        break;

        case 'date':
        break;

        case 'id':
          if( ! checkObjectId( object[ k ] ) )
            errors.push( { field: k, message: 'Invalid ID: ' + k, mustChange: false } );
        break;

        case 'array':
        break;
      }
        

    }
 
  }
  
}


exports.SimpleSchema = SimpleSchema;



/* FIXME: move this somewhere else, even in bd.js, feels wrong here */
exports.currentUserInWorkspaceAccess = function( req, workspaceObject ){
  return  workspaceObject.access.filter( function(o){ 
     return o._id.toString() === req.application.user._id.toString(); } ).length > 0;
}


exports.runtimeErrorIfErr = function( err, next, cb) {
  var e = hotplate.getModule('hotError').errors;

  if( err ){
    next( new e.RuntimeError( err ) );
  } else {
      cb();
  }
}




/* Utility functions written before the schema, and still useful to have */

exports.parametersAreMissing = function(obj, attributes, errors, next){

  var e = hotplate.getModule('hotError').errors;

  attributes.forEach(function(attribute){
    if( typeof(obj) === 'undefined' || typeof(obj[attribute]) == 'undefined'){
      errors.push( { field: attribute, message: 'Required attribute not provided: ' + attribute, mustChange: false } );
    }
  });

  if( errors.length && typeof(next) === 'function' ){
    next( new e.ValidationError( "Validation error, missing parameters", errors ) );
    return true;
  }
  return false;
}


exports.parametersAreEmpty = function(obj, attributes, next){

  var e = hotplate.getModule('hotError').errors;
  var errors = [];

  attributes.forEach(function(attribute){
    if( typeof( obj[attribute] ) !== 'undefined' && obj[attribute] == '' ){
      errors.push( { field: attribute, message: 'Value cannot be empty', mustChange: false } );
    }
  });

  return exports.respondIfErrors( errors, next );

}

exports.parametersAllowed = function(obj, allowedFields, next){

  var e = hotplate.getModule('hotError').errors;
  var errors = [];

  console.log(obj);
  console.log(allowedFields);

  for( var k in obj ){
    if( allowedFields.indexOf( k ) == -1 ){
      errors.push( { field: k, message: 'Value not accepted: ' + k, mustChange: false } );
    }
  };
  return exports.respondIfErrors( errors, next );

}

exports.respondIfErrors = function( errors, next ){

  var e = hotplate.getModule('hotError').errors;

  if( errors.length && typeof(next) === 'function' ) {
    next( new e.ValidationError('Validation error', errors ) );
    return true;
  }
  return false;
}



