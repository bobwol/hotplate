var dummy
  , path = require('path')
  , hotplate = require('hotplate')
  , passport = require('passport')

  , mongoose = require('mongoose')
  , Schema = mongoose.Schema
  , ObjectId = Schema.ObjectId

  , hat = require('hat')

  , bcrypt = require('bcrypt')
  , SALT_WORK_FACTOR = 15;

;


/*
Comprehensive login framework for hotPlate.
A few facts:

## SESSION

To be "logged in" means that: 

 - req.session.loggedIn == true
 - req.session.login    == <username>
 - req.session.userId == <userId>

The variable `req.session.login` MAY hang around (is not zeroed on logout) as it MAY be used to pre-set the login field

## MIDDLEWARE VARIABLES

Using workspaceIdCall (AJAX) tokenIdCall (AJAX) and workspaceIdPages (pages), the following
variables in req will be set:

 - req.application.workspace
 - req.application.user
 - req.application.access

*/

app = hotplate.app;

exports.hotHooks = hooks = {}

hooks.init = function( done ){

  // Sets the Access schema, which is simply a userId/token pair
  var Access = new Schema({
    _id            : { type: ObjectId, index: true }, // this is as userId
    token          : { type: String, index: true },
  });
  
  // Allows modules to enrich the Access schema, 
  hotplate.invokeAll('enrichAuthAccessSchema', Access, function(err, results){

    // Sets the Access model after enriching
    mongoose.model('Access', Access);

    // Sets the Workspace schema, which is simply a list with name, active flag,
    // and the list of users who can access it (though the [Access] schema)
    var Workspace = new Schema({
      name           : { type: String, unique: true}, // Always lowercase
      isActive       : Boolean,
      access          : [ Access ],
    });

    // Allows modules to enrich the Workspace schema
    hotplate.invokeAll('enrichAuthWorkspaceSchema', Workspace, function(err, results){

      // Sets the Workspace model after enriching
      mongoose.model('Workspace', Workspace);

      // Sets the Uer schema, which is a very basic user/password/email
      var User = new Schema({
        login         : { type: String, unique: true }, // Always lowercase
        password      : { type: String },
        registerEmail : { type: String }, // Always lowercase
      });

      // Methods for password encryption
      User.pre('save', function( next ){
        var user = this;
        // only hash the password if it has been modified (or is new)
        if (!user.isModified('password')) return next();

        // generate a salt
        bcrypt.genSalt(SALT_WORK_FACTOR, function(err, salt) {
          if (err) return next(err);

          // hash the password using our new salt
          bcrypt.hash(user.password, salt, function(err, hash) {
            if (err) return next(err);

            // override the cleartext password with the hashed one
            user.password = hash;
            next();
          });
        });
      });
      User.methods.comparePassword = function(candidatePassword, cb) {
        bcrypt.compare(candidatePassword, this.password, function(err, isMatch) {
          if (err) return cb(err);
          cb(null, isMatch);
        });
      };
      // THANK YOU http://devsmash.com/blog/password-authentication-with-mongoose-and-bcrypt

      hotplate.invokeAll('enrichAuthUserSchema', User, function(err, results){

        // Sets the User model after enriching
        mongoose.model('User', User);
        

        // Middleware parameters that set req.application
        app.param( 'workspaceIdPages',   paramWorkspaceIdPages);     // Used by /ws/WORKSPACEID
        app.param( 'tokenCall',          paramTokenCall);            // Used by API calls
        app.param( 'workspaceIdCall',    paramWorkspaceIdCall);      // Used by API calls

        // Other middleware parameters
        app.param( 'mongoId',             mongoIdCall);               // Used by API calls (generic ID)

        done( null );
      });
    });
  });
}
hooks.init.invokes = [ 'enrichAuthUserSchema', 'enrichAuthWorkspaceSchema', 'enrichAuthAccessSchema' ];


hooks.pageElements = function( done ){
  done( null, { moduleName: 'hotDojoAuth', result:{
    jses: [ 'RetypePasswordDialog.js' ],
  } } );
}


hooks.run = function( done ){


  // Set global variables (global to this module), getting them from other hotplate modules.
  var dummy
  , logger = hotplate.getModule('hotServerLogger')

  , e = hotplate.getModule('hotError').errors

  // Pages
  app.get('/pages/login' , pageLogin);
  app.get('/pages/login/:workspaceName' , pageLoginWorkspace, pageLogin );
  app.get('/pages/register' , pageRegister );
  app.get('/pages/pick' , pagePick );

    // Calls to check if users and workspaces are taken
  app.get(  '/call/usersAnon',      getUsersAnon );
  app.get(  '/call/workspacesAnon', getWorkspacesAnon );

  // Calls to actually create workspaces
  app.post( '/call/workspacesAnon', postWorkspacesAnon );
  app.post( '/call/workspacesUser', postWorkspacesUser );

  // Login, logout, recover calls
  app.post( '/call/recoverAnon',    postRecoverAnon );
  app.post( '/call/loginAnon',      postLoginAnon );
  app.get(  '/call/logoutUser',     getLogoutUser );

  done( null );

}

hooks.clientPaths = function( done ){
  done( null, { moduleName: 'hotDojoAuth', result: [ path.join(__dirname, '../client') ] } );
}


hooks.stores = function( done ){
  done( null, {
    usersAnon     : { target: '/call/usersAnon',      idProperty: '_id', sortParam: 'sortBy', },
    workspacesAnon: { target: '/call/workspacesAnon', idProperty: '_id', sortParam: 'sortBy', },

    workspacesUser: { target: '/call/workspacesUser', idProperty: '_id', sortParam: 'sortBy', },

    loginAnon     : { target: '/call/loginAnon',      idProperty: '_id', sortParam: 'sortBy', },
    recoverAnon   : { target: '/call/recoverAnon',    idProperty: '_id', sortParam: 'sortBy', },
    logoutUser    : { target: '/call/logoutUser',     idProperty: '_id', sortParam: 'sortBy', },
  });
}


/* **************************************************
 *
 * Pages
 *
 * **************************************************
*/

var pageLoginWorkspace = function( req, res, next ){

  var Workspace = mongoose.model('Workspace');
  var e = hotplate.getModule('hotError').errors;

  // If the URL has workspaceName, the user requested /pages/login/<workspacename>, in
  // which case the page will need to check that it exists!
  //if( typeof( req.params.workspaceName ) !== 'undefined' ){

    Workspace.findOne({ name: req.params.workspaceName.toLowerCase()}, function(err, doc){
      if(err){
         res.status = 500;
         hotplate.get('errorPage')(req, res, next);
      } else {
        if(doc){
          next();
        } else {
          res.status = 404;
          hotplate.get('errorPage')(req, res, next);
        }
      }
    });
  //} else {
  //  next();
  //}
}


var pageLogin = function(req, res, next){

  var Workspace = mongoose.model('Workspace');
  var hotPage = hotplate.getModule('hotPage');
  var e = hotplate.getModule('hotError').errors;

  // CASE #1: The user IS NOT logged in. Show the straight login form,
  //          after setting the right variables
  if(! req.session.loggedIn){

    var extraJses = (new hotPage.Jses).add('hotDojoAuth', 'login.js');
    var extraCsses = (new hotPage.Csses).add('hotDojoAuth', 'rrl.css');
    var extraVars = new hotPage.Vars();

    extraVars.add('hotDojoAuth', 'loggedIn', false );
    extraVars.add('hotDojoAuth', 'login', typeof( req.session.login ) === 'undefined' ? '' : req.session.login );

    hotPage.processPageTemplate(
      {
        jses:extraJses,
        csses:extraCsses,
        vars:extraVars,
        body: '<body class="claro"><div id="loginForm"></div></body>'
      },
      req,
      'hotDojoAuth/loginForm',
      function( err, result ){
        if( err ){
          hotplate.get('errorPage')(req, res, next);
        } else {
          res.send( result );
          logger.log( { message: "Login page served" } );
        }
      }
    );
    return;
  }

  // CASE #2: The user IS logged in. Redirect to pick()
  if( req.session.userId ){
    res.redirect('/pages/pick');
  }

};


var pageRegister = function(req, res, next){

    var hotPage = hotplate.getModule('hotPage');
    var e = hotplate.getModule('hotError').errors;

    var extraJses = (new hotPage.Jses).add('hotDojoAuth', 'register.js');
    var extraCsses = (new hotPage.Csses).add('hotDojoAuth', 'rrl.css');
    var extraVars = new hotPage.Vars();


    // This will tell the Javascript in the register page that the user is already
    // logged in. We set the "login" variable so that the form can also pre-set the
    // login field, which is a nice bonus
    if( req.session.loggedIn){
      extraVars.add('hotDojoAuth', 'loggedIn', true );
      extraVars.add('hotDojoAuth', 'login', req.session.login );
    } else {
      extraVars.add('hotDojoAuth', 'loggedIn', false );
      extraVars.add('hotDojoAuth', 'login', typeof( req.session.login ) === 'undefined' ? '' : req.session.login );
    }

    result = hotPage.processPageTemplate(
      { 
        jses:extraJses,
        csses:extraCsses,
        vars: extraVars,
        body: '<body class="claro"><div id="registerForm"></div></body>' 
      },
      req,
      'hotDojoAuth/registerPage',
      function( err, result ){
        res.send( result );
        logger.log( { message: "Register page served" } );
      }
    );

  };


var pagePick = function(req, res, next){

  var hotPage = hotplate.getModule('hotPage');
  var e = hotplate.getModule('hotError').errors;

  // User is not logged in: redirect to the login page
  if(! req.session.loggedIn ){
    res.redirect('/pages/login');
    return;
  }

  // Make up a list of workspaces user has access to, and pass it to the jade template
  var list = [];
  var Workspace = mongoose.model('Workspace');
  Workspace.find( { 'access._id': req.session.userId }, function(err, docs){
    if( err ){
      Logger({ logLevel: 4, errorName: err.name, message: err.message, req: req });
      res.status = 500;
      hotplate.get('errorPage')(req, res, next);
    } else {
      docs.forEach( function(workspace){
        list.push( { name: workspace.name, id: workspace._id } );
      });

      // hotplate.log("%j", list );

      // There are no workspaces available
      if( list.length == 0){
        var extraCsses = (new hotPage.Csses).add('hotDojoAuth', 'rrl.css');
        hotPage.processPageTemplate(
          {
            csses:extraCsses,
            body: '<body class="claro"><div id="pickForm">No workspace to pick!</div></body>' 
          },
          req,
          'hotDojoAuth/pickButEmptyPage',
          function(err, result){
            res.send( result );
         }
        );

      // If there is only one workspace in the list, there is no point in having to pick: goes straight there
      } else if( list.length == 1){
        res.redirect( hotplate.get('afterLoginPage') + list[0].id);

      // There is a proper list of workspaces -- let the user pick
      } else {

        // Render the pick list 
        var pickList = '<ul class="simpleList">' + "\n";
        list.forEach(function(item){
          pickList += '<li><a href="' + hotplate.get('afterLoginPage') + item.id + '">' + item.name + '</a></li>' + "\n";
        });
        pickList += "</ul>" + "\n";

        var extraCsses = (new hotPage.Csses).add('hotDojoAuth', 'rrl.css');

        hotPage.processPageTemplate(
          {
            csses:extraCsses, 
            body: '<body class="claro"><div id="pickForm">' + pickList + '</div></body>' 
          },
          req,
          'hotDojoAuth/pickPage',
          function( err, result ){
            res.send( result );
            logger.log( { message: "Pick page served" } );
          } 
        );

      }
    }
  });

};





/* **************************************************
 *
 * Parameters
 *
 * **************************************************
*/

paramWorkspaceIdPages = function( req, res, next, workspaceId ){

  req.application = {};
  var e = hotplate.getModule('hotError').errors;

  var Workspace = mongoose.model('Workspace');
  var User = mongoose.model('User');

  // User is not logged in (?!?): redirect to the login page
  if(! req.session.loggedIn ){
   res.redirect( '/pages/login' );
   return;
  }

  // FIXME http://stackoverflow.com/questions/12192463/error-handler-when-throwing-in-express
  // Check that the workspaceId is in a valid format
  if(  ! hotplate.mongoIdCheck(workspaceId)){
    res.status = 404;
    hotplate.get('errorPage')(req, res, next);
    return;
  }

  Workspace.findOne({ _id: mongoose.Types.ObjectId(workspaceId), 'access._id':req.session.userId }, 
                    function(err, doc){
    if(err){
       res.status = 500;
       hotplate.get('errorPage')(req, res, next);
    } else {
      if(doc){

        var access =  doc.access.id(req.session.userId);

        req.application.access = access.toObject();
        req.application.workspace = doc.toObject();

        User.findOne({ _id: mongoose.Types.ObjectId(req.session.userId) }, function(err, doc){
          if( err ){
            next( new e.RuntimeError( err ) );
          } else {
            req.application.user = doc.toObject();

            next();
          }
        });

      } else {
        res.redirect('/pages/login') ;
      }
    }
  });
};


paramWorkspaceIdCall = function( req, res, next, workspaceId ){
  req.application = {};
  var e = hotplate.getModule('hotError').errors;

  var Workspace = mongoose.model('Workspace');
  var User = mongoose.model('User');

  // Not authorized to do anything as not logged in
  if(! req.session.loggedIn){
    next( new e.UnauthorizedError() );
    return;
  }
  
  // Check that the workspaceId is in a valid format
  if( ! hotplate.mongoIdCheck(workspaceId) ) {
      next( new e.ValidationError( "Workspace id not valid" ) );
      return;
  }


  // Attempts to set the required variables
  Workspace.findOne({ _id: mongoose.Types.ObjectId(workspaceId), 'access._id': req.session.userId }, function(err, doc){
    if( err ){
      next( new e.RuntimeError( err ) );
    } else {

      if(doc){

        var access =  doc.access.id(req.session.userId);

        req.application.access = doc.access.id(req.session.userId).toObject();
        req.application.workspace = doc.toObject();

        // Attempts to set the required variables
        User.findOne({ _id: mongoose.Types.ObjectId(req.session.userId) }, function(err, doc){
          if( err ){
            next( new e.RuntimeError( err ) );
          } else {
            req.application.user = doc.toObject();
            next();
          }
        });
      } else {
        next( new e.UnauthorizedError() );
      }
    }
  });
};


var mongoIdCall = function( req, res, next, id ){

  var e = hotplate.getModule('hotError').errors;

  // Check that the ID is in a valid format
  if( ! hotplate.mongoIdCheck(id) ) {
      next( new e.ValidationError( "ID not valid:" + id) );
      return;
  }
  next();
}


// MERC: FIXME: paramTokenCall 100% untested
var paramTokenCall = function( req, res, next, token ){

  var e = hotplate.getModule('hotError').errors;
  var accessEntry;
  var User = mongoose.model('User');
  var Workspace = mongoose.model('Workspace');

  req.application = {};

  // Find the token, fetch it (along with the workspace name)
  Workspace.findOne({ 'access.token': token } , function(err, doc){
    if(err){
      next( new e.RuntimeError( err ) );
    } else {
      if(! doc ){
        next( new e.BadTokenError() );
      } else {

        accessEntry = doc.access.filter( function( o ){ return o.token == token; } )[0];

        req.application.access = accessEntry.toObject();
        req.application.workspace = doc.toObject();

        User.findOne({ '_id': accessEntry._id } , function(err, doc){
          if(err){
            next( new e.RuntimeError( err ) );
          } else {
            if(! doc ){
              next( new e.BadTokenError() );
            } else {
              req.application.user = doc.toObject();
              // req.application.login = doc.login;
              next();
            }
          }
        });
      }
    }
  });
}


/* 
 **************************************************
 *
 * Actual callbacks
 *
 * **************************************************
*/


/*
  RESTful call: getUsersAnon
  Example     : GET /UsersAnon?login=something
  Params      : * login: Mandatory. Login name
  Notes       : It's an anonymous RESTful call to check if a login name is
                taken or not. Used in registration form. It will never
                work as a generic filter, and that's why the parameter is required
*/

var getUsersAnon = function(req, res, next){

  var login = req.query.login;
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;
     
  // Looks for a workspace. If it's there, answers without errors. If not,
  // answers with a very short error
  User = mongoose.model('User');
  if( typeof(login) === 'undefined' ){
    next(new e.ValidationError("'login' filter not passed", { name: 'parameter required'}) );
  } else {
    User.findOne({ login: login.toLowerCase() }, function(err, doc){
      if(err ){
        next(new e.RuntimeError( err ) );
      } else {
        // Note: returns a simplified version of the record as
        // this is asked from an anonymous source
        if(doc){
          sendResponse( res, [ { login:login } ] );
        } else {
          sendResponse( res, [] );
       }
      }
    });
  }
}; 

function parametersAreThere(obj, attributes, errors){
  attributes.forEach(function(attribute){
    if( typeof(obj) === 'undefined' || typeof(obj[attribute]) == 'undefined'){
      errors.push( { field: attribute, message: 'Required attribute not provided: ' + attribute, mustChange: false } );
    }
  }); 
}

function parametersNotEmpty(obj, attributes, errors){
  attributes.forEach(function(attribute){
    if( obj[attribute] == '' ){
      errors.push( { field: attribute, message: 'Value cannot be empty: ' + attribute, mustChange: false } );
    }
  }); 
}


/*
  RESTful call: getWorkspaceAnon
  Example     : GET /WorkspaceAnon?name=something
  Params      : * name: Mandatory. Workspace name
  Notes       : It's an anonymous RESTful call to check if a workspace is
                taken or not. Used in registration form. It will never
                work as a generic filter, and that's why the parameter is required
*/
var getWorkspacesAnon = function(req, res, next){

  var name = req.query.name;
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;

  // Looks for a workspace. If it's there, answers without errors. If not,
  // answers with a very short error
  Workspace = mongoose.model('Workspace');
  if( typeof( name ) === 'undefined' ){
    next(new e.ValidationError("'name' filter not passed", { name: 'parameter required'}) );
  } else {
    Workspace.findOne({ name: name.toLowerCase() }, function(err, doc){
      if(err ){
        next(new e.RuntimeError( err ) );
      } else {
        // Note: returns a simplified version of the record as
        // this is asked from an anonymous source
        if(doc){
          sendResponse( res, [ { name: name } ]  ); 
        } else {
          sendResponse( res, [] ); 
       }
      }
    });
  }
}


var postWorkspacesAnon = function(req, res, next){

  var e = hotplate.getModule('hotError').errors;

  // *****
  setTimeout(function(){
  // *****

  var errors = [];
  var Workspace = mongoose.model("Workspace");
  var User = mongoose.model("User");
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var Validators = hotplate.getModule('hotSharedCode').sharedFunctions.hotCommonValidators;


  // **************************************************************
  // PHASE #1: SOFT VALIDATION (NO DB INTERACTION YET)
  //           "Because you cannot trust Javascript validation"
  // **************************************************************


  // (Paranoid) Check of passed parameters
  parametersAreThere(req.body, ['password', 'workspace', 'login', 'registerEmail'], errors);

  if( typeof(req.body.password) !== 'object' ){
    errors.push( { field: 'password', message: 'Invalid parameter: password', mustChange: false } );
  } else {
    if( typeof( req.body.password[0] ) === 'undefined' || typeof( req.body.password[1] ) === 'undefined'){
      errors.push( { field: 'password', message: 'Missing parameter: password', mustChange: false } );
    }
  }

  // There were errors: end of story, don't even bother the database
  if(errors.length){
    next( new e.ValidationError('Required parameters missing or invalid', errors));
    return;
  }


  // Check if the password matches.
  // This will populate "errors", which will make things stop even if
  // user and workspace are not taken
  if( req.body.password[0] != req.body.password[1] ){
    errors.push( { field: 'password', message: 'Password does not match', mustChange: false } );
  }


  // Enrich the `errors` object if parameters are empty strings
  parametersNotEmpty(req.body, ['workspace', 'login' ], errors);

  // Validate workspace
  if( ! Validators.workspace(req.body.workspace) ){
    errors.push( {field: 'workspace' , message: Validators.workspace(false) });
  }

  // Validate user name
  if( ! Validators.login(req.body.login) ){
    errors.push( {field: 'login' , message: Validators.login(false) });
  }

  // Validate email
  if( ! Validators.email(req.body.registerEmail) ){
    errors.push( {field: 'registerEmail' , message: Validators.email(false) });
  }


  // There were errors: end of story, don't even bother the database
  if(errors.length){
    next( new e.ValidationError('Validation of parameters failed', errors));
    return;
  }
   
  // *******************************************************
  // PHASE #1: ADDING RECORDS TO DB (WITH CHECKS)
  // *******************************************************

  User.findOne( { login: req.body.login.toLowerCase() }, function(err, doc){
    // Log database error if it's there
    if(err ){
      next(new e.RuntimeError( err ) );
    } else {
      // If the user exists, add it to the error vector BUT keep going
      if(doc){
        errors.push({ field:'login', message: 'Login name taken, sorry!', mustChange: true } );
      }
      Workspace.findOne({ name: req.body.workspace.toLowerCase() }, function(err, doc){
        if(err ){
          next(new e.RuntimeError( err ) );
        } else {
          if(doc){
            errors.push( {field: "workspace", message: "Workspace taken, sorry!", mustChange: true} );
          } 

          // Check if there are any errors -- if so, return them and that's it
          if( errors.length ){
            next( new e.ValidationError('Validation of parameters failed', errors));
          } else { 

            //
            // AT THIS POINT, UNLESS SOMETHING JUMPS ON US, both user and workspace are available
            //

            // User doesn't exist: create it
            var u = new User();
            u.login = req.body.login.toLowerCase();
            u.password = req.body.password[0].toLowerCase();
            u.registerEmail = req.body.registerEmail.toLowerCase();
            u.workspaceIds = [];
            hotplate.invokeAll('creatingUser', u, function(){
              u.save( function(err) {
                if(err){
                  next( new e.RuntimeError( err ) );
                } else {
                  var w = new Workspace();
                  w.name = req.body.workspace.toLowerCase();
                  w.activeFlag = true;
                  w.access = []; 

                  makeToken( function(err, token) {
                    if(err){
                      next(new e.RuntimeError( err ) );
                    } else {

                      w.access.push( {  _id: u._id, token:token });
                      hotplate.invokeAll('creatingWorkspace', u, w, function(){

                        w.save( function(err){
                          if(err ){
                            console.log("ERROR:");
                            console.log(err);
                            next( new e.RuntimeError( err ) );
                          } else{
                            // Login and password correct: user is logged in, regardless of what workspace they were requesting access for.
                            req.session.loggedIn = true;
                            req.session.login = u.login;
                            req.session.userId = u._id;

                            sendResponse(res, { workspaceId: w._id } );
                          }
                        }) // w.save()
                      }) // hotplace.involeAll('accessCreated')
                    } 
                  }) // makeToken()

                }
              }) // u.save
            }) // invokeAll('userCreated')

          } // if(errors.length != 0)
        }
      }) // Workspace.findOne()
    }
  }); // User.findOne()

  //
  } , 500); // Artificial timeout
  //
}



var postWorkspacesUser = function(req, res, next){

  var e = hotplate.getModule('hotError').errors;

  // *****
  setTimeout(function(){
  // *****

  var Workspace = mongoose.model('Workspace');
  var User = mongoose.model('User');
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var Validators = hotplate.getModule('hotSharedCode').sharedFunctions.hotCommonValidators;

  var errors = [];

  // Chuck user out if he's not logged in.
  // TODO: Move this into a middleware
  if(! req.session.loggedIn ){
    next( new e.UnauthorizedError('Not logged in'));
    return; 
  }

  // Check that required parameters to this call are there
  parametersAreThere(req.body, ['workspace'], errors);
  if(errors.length){
    next( new e.ValidationError('Required parameters missing', errors));
    return;
  }


  // Enrich the `errors` object if parameters are empty strings
  parametersNotEmpty(req.body, ['workspace' ], errors);


  // Validate workspace
  if( ! Validators.workspace(req.body.workspace) ){
    errors.push( {field: 'workspace' , message: Validators.workspace(false) });
  }

  // There were errors: end of story, don't even bother the database
  if(errors.length){
    next( new e.ValidationError('Validation of parameters failed', errors));
    return;
  }


  // Step 1: Check that the workspace is not already taken
  Workspace.findOne({ name:req.body.workspace.toLowerCase() }, function(err, doc){
    if(err){
      next(new e.RuntimeError( err ) );
    } else {
      if(doc){
        errors.push( {field: "workspace", message: "Workspace taken, sorry!", mustChange: true} );
        next( new e.ValidationError('Validation failed', errors));
      } else {

        // Assign values
        var w = new Workspace();
        w.name = req.body.workspace;
        w.activeFlag = true;
        makeToken( function(err, token) {
          if(err){
             next(new e.RuntimeError( err ) );
          } else {
            w.access = {  _id: req.session.userId, token:token }; 
            w.save( function(err){
              if(err){
                 next(new e.RuntimeError( err ) );
              } else{

                // Register the workspace, and return the worksapce Id in as an option (to allow redirect)
                sendResponse( res, { workspaceId: w._id } ); 

              }
            }); // w.save
          }
        }); // makeToken
      }
    }
  }); // Workspace.findOne


  //
  } , 500); // Artificial timeout
  //
}



var getLogoutUser = function(req, res, next){

  var e = hotplate.getModule('hotError').errors;

  // *****
  setTimeout(function(){
  // *****

    var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
    // There is nothing to be checked: simply logs out by clearing the session variables
    // NOTE: req.session.login is properly set to null as the user really wanted to logout
    // NOTE2: Maybe not. In which case would this not be set to null...?
    req.session.loggedIn = false;
    // req.session.login = null;

    // Send an OK response. It's up to the client to redirect/etc.
    sendResponse( res, {} );

  //
  } , 500); // Artificial timeout
  //

}


var postRecoverAnon = function(req, res, next){

  var e = hotplate.getModule('hotError').errors;

  // *****
  setTimeout(function(){
  // *****

  var errors = [];
  var Workspace = mongoose.model("Workspace");
  var User = mongoose.model("User");
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;

  // Check that the email is indeed there
  parametersAreThere(req.body, ['registerEmail'], errors);
  if(errors.length){
    next( new e.ValidationError('Missing parameter: registerEmail', errors));
    return;
  }


  // Enrich the `errors` object if parameters are empty strings
  parametersNotEmpty(req.body, [ 'registerEmail' ], errors);


  // **************************************************************
  // PHASE #1: SOFT VALIDATION (NO DB INTERACTION YET)
  //           "Because you cannot trust Javascript validation"
  // **************************************************************

  // Validate email
  if( ! Validators.email(req.body.registerEmail)){
    errors.push( { field: 'registerEmail' , message: Validators.email(false) });
  }

  // There were errors: end of story, don't even bother the database
  if(errors.length){
    next( new e.ValidationError('Soft validation of parameters failed', errors));
    return;
  }
   

  // *******************************************************
  // PHASE #1: ADDING RECORDS TO DB (WITH CHECKS)
  // *******************************************************

  User.findOne( { login: req.body.registerEmail.toLowerCase }, function(err, doc){
    // Log database error if it's there
    if(err ){
      next(new e.RuntimeError( err ) );
    } else {
      // If the user exists, add it to the error vector BUT keep going
      if(doc){
        hotplate.log("Sending email for " + doc.registerEmail);
        // TODO: SEND EMAIL USING NEW EMAIL INFRASTRUCTURE
      }
      sendResponse( res );
    }
  }); // User.findOne()

  //
  } , 500); // Artificial timeout
  //
}




var postLoginAnon = function(req, res, next){


  var e = hotplate.getModule('hotError').errors;

  // *****
  // setTimeout(function(){
  // *****

  var Validators = hotplate.getModule('hotSharedCode').sharedFunctions.hotCommonValidators;
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;

  var errors = [],
      User = mongoose.model("User"),
      Workspace = mongoose.model("Workspace");

  // **************************************************************
  // PHASE #1: SOFT VALIDATION (NO DB INTERACTION YET)
  //           "Because you cannot trust Javascript validation"
  // **************************************************************
    

  // Parameters were actually passed
  parametersAreThere(req.body, ['login', 'password', 'remember' ], errors);
  if(errors.length){
    next( new e.ValidationError('Missing required fields in request', errors));
    return;
  }

  // Enrich the `errors` object if parameters are empty strings
  parametersNotEmpty(req.body, ['login', 'password' ], errors);

  if( ! Validators.login(req.body.login) ){
    errors.push( {field: 'login' , message: Validators.login(false) });
  }

  // There were errors: end of story, don't even bother the database
  if(errors.length){
    next( new e.ValidationError('Validation of some parameters failed', errors));
    return;
  }
 
  // *******************************************************
  // PHASE #2: POST THE DATA
  // Note: since we are posting username/password,
  // 
  // *******************************************************

  var forWorkspaceId = '';
  User.findOne( { login: req.body.login.toLowerCase() }, function(err, docUser){
    // Log database error if it's there
    if(err ){
      next(new e.RuntimeError( err ) );
    } else {
      // Password is incorrect: return errors
      if(! docUser ) {
          errors.push({ field:'password', message: 'Password incorrect', mustChange: false } );
          next( new e.ValidationError('Password incorrect', errors));
      } else {
       
        docUser.comparePassword( req.body.password, function( err, isMatch){
       
          if(err ){
            next(new e.RuntimeError( err ) );
          } else {

            if( !isMatch){

              errors.push({ field:'password', message: 'Password incorrect', mustChange: false } );
              next( new e.ValidationError('Password incorrect', errors));
            } else {

              // Login and password correct: user is logged in, regardless of what workspace they were requesting access for.
              req.session.loggedIn = true;
              req.session.login = docUser.login;
              req.session.userId = docUser._id;

              // Set the life of the session cookie: just this browsing session,
              // or 2 weeks (depending on whether the user ticked "remember me" or not)
              if( req.body.remember[0] === 'on' ) {
                req.session.cookie.maxAge = 14 * 24 * 3600 * 1000; // They ticked "remember me": set a deadline for the cookie
              } else {
                req.session.cookie.expires = false; // No "remember me": remember till the browser closes
              }

              // The client requested a login for a specific workspace name: attempt to set forWorkspaceId (if they have
              // access to that specific workspace)
              if( typeof(req.params.workspaceName) !== 'undefined'){

                User.findOne( { login: req.body.login.toLowerCase() } , function( err, docUser){
                  if(err){
                     next(new e.RuntimeError( err ) );
                  } else {
                


                    Workspace.findOne( { 'name': req.params.workspaceName.toLowerCase(), 'access._id' : docUser._id }, function(err, docWorkspace){
                      if(err ){
                        next(new e.RuntimeError( err ) );
                      } else {
                        if(docWorkspace){
                          forWorkspaceId = docWorkspace._id;
                        }
                        sendResponse( res, { forWorkspaceId: forWorkspaceId } );
                      }
                    }); // Workspace.findOne
                  }
                }); //  User.findOne 

              } // if( req.body.workspaceName != '')


              // There was no specific requirement in terms of workspace, just return OK with empty forWorkspaceId
              else {

                // Finally send the OK response
                sendResponse( res, { forWorkspaceId: '' } );
  
              } // ELSE ( if( req.body.workspaceName != '') )

            } // else  ( if( !isMatch) )

          } // else * if(err)

        }); // docUser.comparePassword( req.body.password, function( err, isMatch)
      }
    }
  }); // User.findOne()


  //
  // } , 3500); // Artificial timeout
  //

}

var makeToken = function( callback ){

  var attempts = 0;
  look();

  function look(){
    Workspace = mongoose.model("Workspace");

    // Generate the token, check that it's indeed available
    var token = hat();
    Workspace.findOne( { 'access.token':token } , function(err, doc){

      // There is an error: call the callback returning an error
      if(err){
        callback(err, null);
      } else {

        // Token already there: either give up (too many attempts)...
        if( doc ){
          attempts ++;
          if( attempts == 5 ){
            callback( new Error("Cannot generate unique token"), null );
          } else {
            look();
          }
        // ... or try again by calling this function again!
        } else {
          callback(null, token );
        }
      }
    });
  }
}

