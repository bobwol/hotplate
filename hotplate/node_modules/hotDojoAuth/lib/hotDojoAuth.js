var dummy
  , path = require('path')
  , hotplate = require('hotplate')
  , passport = require('passport')

  , mongoose = require('mongoose')
  , Schema = mongoose.Schema
  , ObjectId = Schema.ObjectId

  , hat = require('hat')

;


/*
Comprehensive login framework for hotPlate.
A few facts:


## SESSION

To be "logged in" means that: 

 - req.session.loggedIn == true
 - req.session.login    == <username>
 - req.session.userId == <userId>

The variable `req.session.login` MAY hang around (is not zeroed on logout) as it MAY be used to pre-set the login field

## MIDDLEWARE VARIABLES

Using workspaceIdCall (AJAX) tokenIdCall (AJAX) and workspaceIdPages (pages), the following
variables in req will be set:

 - req.application.workspaceId   = <workspaceId>
 - req.application.workspaceName = <workspaceName>
 - req.application.userId = <userId>
 - req.application.login  = <login>
 - req.application.token  = <token>

It's _very_ handy to have `userId` and `login` here: remember that when an AJAX call is done using the token,
the session variables `req.session.loggedIn`, `req.session.login` and `req.session.userId` will NOT be set. Having everything
here makes things like logging much easier
*/

app = hotplate.app;

exports.hotHooks = hooks = {}

hooks.init = function( done ){

  var Access = new Schema({
    userId         : { type: ObjectId, index: true },
    token          : { type: String, index: true },
    isOwner        : { type: Boolean, index: true },
  });
  mongoose.model('Access', Access);

  var Workspace = new Schema({
    name           : { type: String, lowercase: true, unique: true},
    description    : String,
    isActive       : Boolean,
    access          : [ Access ],
  });
  mongoose.model('Workspace', Workspace);

  var User = new Schema({
    login         : { type: String, unique: true, lowercase: true },
    password      : { type: String },
    email         : { type: String, lowercase:true },
  });
  mongoose.model('User', User);

  // Middleware parameters that set req.application
  app.param( 'workspaceIdPages',   paramWorkspaceIdPages);     // Used by /ws/WORKSPACEID
  app.param( 'tokenCall',          paramTokenCall);            // Used by API calls
  app.param( 'workspaceIdCall',    paramWorkspaceIdCall);      // Used by API calls

  // Other middleware parameters
  app.param( 'idCall',             paramIdCall);               // Used by API calls (generic ID)
 
  done( null );

}


hooks.run = function( done ){

  // Set global variables (global to this module), getting them from other hotplate modules.
  dummy
  , logger = hotplate.getModule('hotServerLogger')
  , hotPage = hotplate.getModule('hotPage')

  , e = hotplate.getModule('hotError').errors
  , sendResponse = hotplate.getModule('hotProtocol').sendResponse
  , Validators = hotplate.getModule('hotSharedCode').sharedFunctions.hotSharedValidators; // This is in core, so I can

  // Pages
  app.get('/pages/login' , pageLogin);
  app.get('/pages/login/:workspaceName' , pageLoginWorkspace, pageLogin );
  app.get('/pages/register' , pageRegister );
  app.get('/pages/pick' , pagePick );

    // Calls to check if users and workspaces are taken
  app.get(  '/call/usersAnon',      getUsersAnon );
  app.get(  '/call/workspacesAnon', getWorkspacesAnon );

  // Calls to actually create workspaces
  app.post( '/call/workspacesAnon', postWorkspacesAnon );
  app.post( '/call/workspacesUser', postWorkspacesUser );

  // Login, logout, recover calls
  app.post( '/call/recoverAnon',    postRecoverAnon );
  app.post( '/call/loginAnon',      postLoginAnon );
  app.get(  '/call/logoutUser',     getLogoutUser );

  done( null );

}

hooks.clientPaths = function( done ){
  done( null, { moduleName: 'hotDojoAuth', result: [ path.join(__dirname, '../client') ] } );
}


hooks.stores = function( done ){
  done( null, {
    usersAnon     : { target: '/call/usersAnon',      idProperty: '_id', sortParam: 'sortBy', },
    workspacesAnon: { target: '/call/workspacesAnon', idProperty: '_id', sortParam: 'sortBy', },

    workspacesUser: { target: '/call/workspacesUser', idProperty: '_id', sortParam: 'sortBy', },

    loginAnon     : { target: '/call/loginAnon',      idProperty: '_id', sortParam: 'sortBy', },
    recoverAnon   : { target: '/call/recoverAnon',    idProperty: '_id', sortParam: 'sortBy', },
    logoutUser    : { target: '/call/logoutUser',     idProperty: '_id', sortParam: 'sortBy', },
  });
}

/* **************************************************
 *
 * Pages
 *
 * **************************************************
*/

var pageLoginWorkspace = function( req, res, next ){


  var Workspace = mongoose.model('Workspace');


  // If the URL has workspaceName, the user requested /pages/login/<workspacename>, in
  // which case the page will need to check that it exists!
  if( typeof( req.params.workspaceName ) !== 'undefined' ){

    Workspace.findOne({ name: req.params.workspaceName.toLowerCase()}, function(err, doc){
      if(err){
         res.status = 500;
         hotplate.get('errorPage')(req, res, next);
      } else {
        if(doc){
          next();
        } else {
          res.status = 404;
          hotplate.get('errorPage')(req, res, next);
        }
      }
    });
  } else {
    next();
  }
}


var pageLogin = function(req, res, next){

    var Workspace = mongoose.model('Workspace');

    // CASE #1: The user IS NOT logged in. Show the straight login form,
    //          after setting the right variables

    if(! req.session.loggedIn ){

      var extraJses = (new hotPage.Jses).add('hotDojoAuth', 'login.js');
      var extraCsses = (new hotPage.Csses).add('hotDojoAuth', 'rrl.css');
      var extraVars = new hotPage.Vars();

      extraVars.add('hotDojoAuth', 'loggedIn', false );
      extraVars.add('hotDojoAuth', 'login', typeof( req.session.login ) === 'undefined' ? '' : req.session.login );

      hotPage.processPageTemplate( {
        jses:extraJses,
        csses:extraCsses,
        vars:extraVars,
        body: '<body class="claro"><div id="loginForm"></div></body>'
      }, function( result ){
        res.send( result );
        logger.log( { message: "Login page served" } );
      } );
      return;
    }

    // CASE #2: The user IS logged in. In this case, they might be either
    //          * accessing access a specific workspace (/login/someworkspacename). Redirect straight there.
    //          * accessing just the login form (/login). Redirect to /pick


    // If they are trying to access a specific workspace, and have
    // access to it, then simply redirect there
    if( req.application && req.application.workspaceId ){

      Workspace.findOne( { '_id': req.workspaceId, 'access.userId' : req.session.userId }, function(err, doc){
        if( err ){
          logger.log({ logLevel: 4, errorName: err.name, message: err.message });
          res.status = 500;
          hotplate.get('errorPage')(req, res, next);
        } else {
          if(doc){
            res.redirect( hotplate.get('afterLoginPage') + req.workspaceId);
          } else {
            res.redirect('/pages/pick');
          }
        }

      }); // Workspace.findOne()

    // No specific worskspace: just go and pick
    } else {
      res.redirect('/pages/pick');
    }

  };


var pageRegister = function(req, res, next){

    var extraJses = (new hotPage.Jses).add('hotDojoAuth', 'register.js');
    var extraCsses = (new hotPage.Csses).add('hotDojoAuth', 'rrl.css');
    var extraVars = new hotPage.Vars();

    // This will tell the Javascript in the register page that the user is already
    // logged in. We set the "login" variable so that the form can also pre-set the
    // login field, which is a nice bonus
    if( req.session.loggedIn){
      extraVars.add('hotDojoAuth', 'loggedIn', true );
      extraVars.add('hotDojoAuth', 'login', req.session.login );
    } else {
      extraVars.add('hotDojoAuth', 'loggedIn', false );
      extraVars.add('hotDojoAuth', 'login', typeof( req.session.login ) === 'undefined' ? '' : req.session.login );
    }

    result = hotPage.processPageTemplate( { 
      jses:extraJses,
      csses:extraCsses,
      vars: extraVars,
      body: '<body class="claro"><div id="registerForm"></div></body>' 
    }, function( result ){
      res.send( result );
      logger.log( { message: "Register page served" } );
    });

  };


var pagePick = function(req, res, next){

    // hotplate.log("WS: %j" , req.session );
    // User is not logged in: redirect to the login page
    if(! req.session.loggedIn ){
      res.redirect('/pages/login');
      return;
    }

    // Make up a list of workspaces user has access to, and pass it to the jade template
    var list = [];
    var Workspace = mongoose.model('Workspace');
    Workspace.find( { 'access.userId': req.session.userId }, function(err, docs){
      if( err ){
        Logger({ logLevel: 4, errorName: err.name, message: err.message, req: req });
        res.status = 500;
        hotplate.get('errorPage')(req, res, next);
      } else {
        docs.forEach( function(workspace){
          list.push( { name: workspace.name, description: workspace.description, id: workspace._id } );
        });

        // hotplate.log("%j", list );

        // There are no workspaces available
        if( list.length == 0){
          var extraCsses = (new hotPage.Csses).add('hotDojoAuth', 'rrl.css');
          hotPage.processPageTemplate( { csses:extraCsses, body: '<body class="claro"><div id="pickForm">No workspace to pick!</div></body>' }, function(result){
           res.send( result );
         });

        // If there is only one workspace in the list, there is no point in having to pick: goes straight there
        } else if( list.length == 1){
          res.redirect( hotplate.get('afterLoginPage') + list[0].id);

        // There is a proper list of workspaces -- let the user pick
        } else {

          // Render the pick list 
          var pickList = '<ul class="simpleList">' + "\n";
          list.forEach(function(item){
            pickList += '<li><a href="' + hotplate.get('afterLoginPage') + item.id + '">' + item.name + '</a></li>' + "\n";
          });
          pickList += "</ul>" + "\n";

          var extraCsses = (new hotPage.Csses).add('hotDojoAuth', 'rrl.css');
          hotPage.processPageTemplate( { csses:extraCsses, body: '<body class="claro"><div id="pickForm">' + pickList + '</div></body>' }, function( result ){
            res.send( result );
            logger.log( { message: "Pick page served" } );

          } );
        }
      }
    });

  };





/* **************************************************
 *
 * Parameters
 *
 * **************************************************
*/

paramWorkspaceIdPages = function( req, res, next, workspaceId ){

  var Workspace = mongoose.model('Workspace');
  req.application = {};

  // User is not logged in (?!?): redirect to the login page
  if(! req.session.loggedIn ){
   res.redirect( '/pages/login' );
   return;
  }

  // FIXME http://stackoverflow.com/questions/12192463/error-handler-when-throwing-in-express
  // Check that the workspaceId is in a valid format
  if(  ! hotplate.objectIdCheck(workspaceId)){
    res.status = 404;
    hotplate.get('errorPage')(req, res, next);
    return;
  }

  Workspace.findOne({ _id: mongoose.Types.ObjectId(workspaceId), 'access.userId':req.session.userId }, function(err, doc){
    if(err){
       res.status = 500;
       hotplate.get('errorPage')(req, res, next);
    } else {
      if(doc){
        req.application.workspaceId = doc._id;
        req.application.workspaceName = doc.name;
        req.application.userId = req.session.userId;
        req.application.login = req.session.login;
        req.application.token = doc.access.filter(function(entry){ return entry.userId == req.session.userId;  } )[0].token;

        next();
      } else {
        res.redirect('/pages/login') ;
      }
    }
  });
};


paramWorkspaceIdCall = function( req, res, next, workspaceId ){
  var Workspace = mongoose.model('Workspace');
  req.application = {};

  // Not authorized to do anything as not logged in
  if(! req.session.loggedIn){
    next( new e.ForbiddenError() );
    return;
  }
  
  // Check that the workspaceId is in a valid format
  if( ! hotplate.objectIdCheck(workspaceId) ) {
      next( new e.ValidationError( "Workspace id not valid" ) );
      return;
  }

  // Attempts to set the required variables
  Workspace.findOne({ _id: mongoose.Types.ObjectId(workspaceId), 'access.userId':req.session.userId }, function(err, doc){
    if(err){
      next( new e.RuntimeError( err ) );
    } else {
      if(doc){
        req.application.workspaceId = doc._id;
        req.application.workspaceName = doc.name;
        req.application.userId = req.session.userId;
        req.application.login = req.session.login;
        req.application.token = doc.access.filter(function(entry){ return entry.userId == req.session.userId;  } )[0].token;

        next();
      } else {
        next( new e.ForbiddenError() );
      }
    }
  });
};

var paramIdCall = function( req, res, next, id ){

  // Check that the workspaceId is in a valid format
  if( ! hotplate.objectIdCheck(id) ) {
      next( new e.ValidationError( "ID not valid:" + id) );
      return;
  }
  next();
}

var paramTokenCall = function( req, res, next, token ){

  var Workspace = mongoose.model('Workspace'),
      User = mongoose.model('User'),
      accessEntry;

  req.application = {};

  // Find the token
  Workspace.findOne({ 'access.token': token } , function(err, doc){
    if(err){
      next( new e.RuntimeError( err ) );
    } else {
      if(! doc ){
        next( new e.BadTokenError() );
      } else {
        accessEntry = doc.access.filter(function(entry){ return entry.token == token;  } )[0];

        req.application.workspaceId = doc._id;
        req.application.workspaceName = doc.name;
        req.application.userId = accessEntry.userId;
        req.application.login =  accessEntry.login;
        req.application.token = token;

        next();
      }
    }
  });
}


/* 
 **************************************************
 *
 * Actual callbacks
 *
 * **************************************************
*/


/*
  RESTful call: getUsersAnon
  Example     : GET /UsersAnon?login=something
  Params      : * login: Mandatory. Login name
  Notes       : It's an anonymous RESTful call to check if a login name is
                taken or not. Used in registration form. It will never
                work as a generic filter, and that's why the parameter is required
*/

var getUsersAnon = function(req, res, next){

  var login = req.query.login;
     
  // Looks for a workspace. If it's there, answers without errors. If not,
  // answers with a very short error
  User = mongoose.model('User');
  if( typeof(login) === 'undefined' ){
    next(new e.ValidationError("'login' filter not passed", { name: 'parameter required'}) );
  } else {
    User.findOne({ login: login.toLowerCase() }, function(err, doc){
      if(err ){
        next(new e.RuntimeError( err ) );
      } else {
        // Note: returns a simplified version of the record as
        // this is asked from an anonymous source
        if(doc){
          sendResponse( res, { data: [ { login:login } ]  } );
        } else {
          sendResponse( res, { data: []  } );
       }
      }
    });
  }
}; 

function parametersAreThere(obj, attributes, errors){
  attributes.forEach(function(attribute){
    if( typeof(obj) == 'undefined' || typeof(obj[attribute]) == 'undefined'){
      errors.push( { field: attribute, message: 'Required attribute not provided: ' + attribute, mustChange: false } );
    }
  }); 
}

/*
  RESTful call: getWorkspaceAnon
  Example     : GET /WorkspaceAnon?name=something
  Params      : * name: Mandatory. Workspace name
  Notes       : It's an anonymous RESTful call to check if a workspace is
                taken or not. Used in registration form. It will never
                work as a generic filter, and that's why the parameter is required
*/
var getWorkspacesAnon = function(req, res, next){

  var name = req.query.name;

  // Looks for a workspace. If it's there, answers without errors. If not,
  // answers with a very short error
  Workspace = mongoose.model('Workspace');
  if( typeof( name ) === 'undefined' ){
    next(new e.ValidationError("'name' filter not passed", { name: 'parameter required'}) );
  } else {
    Workspace.findOne({ name: name.toLowerCase() }, function(err, doc){
      if(err ){
        next(new e.RuntimeError( err ) );
      } else {
        // Note: returns a simplified version of the record as
        // this is asked from an anonymous source
        if(doc){
          sendResponse( res, { data: [ { name: name } ]  } ); 
        } else {
          sendResponse( res, { data: []  } ); 
       }
      }
    });
  }
}


var postWorkspacesAnon = function(req, res, next){

  // *****
  setTimeout(function(){
  // *****

  var errors = [];
  var Workspace = mongoose.model("Workspace");
  var User = mongoose.model("User");


  // **************************************************************
  // PHASE #1: SOFT VALIDATION (NO DB INTERACTION YET)
  //           "Because you cannot trust Javascript validation"
  // **************************************************************


  // (Paranoid) Check of passed parameters
  parametersAreThere(req.body, ['password', 'workspace', 'login', 'email'], errors);

  if( typeof(req.body.password) !== 'object' ){
    errors.push( { field: 'password', message: 'Invalid parameter: password', mustChange: false } );
  } else {
    if( typeof( req.body.password[0] ) === 'undefined' || typeof( req.body.password[1] ) === 'undefined'){
      errors.push( { field: 'password', message: 'Missing parameter: password', mustChange: false } );
    }
  }

  // There were errors: end of story, don't even bother the database
  if(errors.length){
    next( new e.ValidationError('Required parameters missing or invalid', errors));
    return;
  }


  // Check if the password matches.
  // This will populate "errors", which will make things stop even if
  // user and workspace are not taken
  if( req.body.password[0] != req.body.password[1] ){
    errors.push( { field: 'password', message: 'Password does not match', mustChange: false } );
  }


  // Get the validators from hotplate's default ones
  // Note: I can do this as they are in hotplate's core
  Validators = hotplate.getModule('hotSharedCode').sharedFunctions.hotSharedValidators;

  // Validate workspace
  var validatorWorkspace = Validators.workspace(req.body.workspace);
  if( ! validatorWorkspace.result ){
    errors.push( {field: 'workspace' , message: validatorWorkspace.message });
  }

  // Validate user name
  var validatorLogin = Validators.login(req.body.login);
  if( ! validatorLogin.result ){
    errors.push( {field: 'login' , message: validatorLogin.message });
  }

  // Validate email
  var validatorEmail = Validators.email(req.body.email);
  if( ! validatorEmail.result ){
    errors.push( {field: 'email' , message: validatorEmail.message });
  }

  // There were errors: end of story, don't even bother the database
  if(errors.length){
    next( new e.ValidationError('Validation of parameters failed', errors));
    return;
  }
    
  // *******************************************************
  // PHASE #1: ADDING RECORDS TO DB (WITH CHECKS)
  // *******************************************************

  User.findOne( { login: req.body.login.toLowerCase() }, function(err, doc){
    // Log database error if it's there
    if(err ){
      next(new e.RuntimeError( err ) );
    } else {
      // If the user exists, add it to the error vector BUT keep going
      if(doc){
        errors.push({ field:'login', message: 'Login name taken, sorry!', mustChange: true } );
      }
      Workspace.findOne({ name: req.body.workspace.toLowerCase() }, function(err, doc){
        if(err ){
          next(new e.RuntimeError( err ) );
        } else {
          if(doc){
            errors.push( {field: "workspace", message: "Workspace taken, sorry!", mustChange: true} );
          } 

          // Check if there are any errors -- if so, return them and that's it
          if( errors.length ){
            next( new e.ValidationError('Validation of parameters failed', errors));
          } else { 

            //
            // AT THIS POINT, UNLESS SOMETHING JUMPS ON US, both user and workspace are available
            //

            // User doesn't exist: create it
            var u = new User();
            u.login = req.body.login;
            u.password = req.body.password[0];
            u.email = req.body.email;
            u.workspaceIds = [];
 
            u.save( function(err) {
              if(err){
                next( new e.RuntimeError( err ) );
              } else {
                var w = new Workspace();
                w.name = req.body.workspace;
                w.activeFlag = true;

                makeToken( function(err, token) {
                  if(err){
                    next(new e.RuntimeError( err ) );
                  } else {
                    w.access = {  userId: u._id, token:token, isOwner: true };
                    w.save( function(err){
                      if(err ){
                        next( new e.RuntimeError( err ) );
                      } else{
                        // Login and password correct: user is logged in, regardless of what workspace they were requesting access for.
                        req.session.loggedIn = true;
                        req.session.login = req.body.login;
                        req.session.userId = u._id;

                        sendResponse( res, { data: { workspaceId: w._id } } );
                      }
                    }) // w.save()
                  } 
                }) // makeToken()

              }
            }) // u.save

          } // if(errors.length != 0)
        }
      }) // Workspace.findOne()
    }
  }); // User.findOne()


  //
  } , 500); // Artificial timeout
  //

}



var postWorkspacesUser = function(req, res, next){

  // *****
  setTimeout(function(){
  // *****

  var Workspace = mongoose.model('Workspace');
  var User = mongoose.model('User');

  var errors = [];

  // Chuck user out if he's not logged in.
  // TODO: Move this into a middleware
  if(! req.session.loggedIn ){
    next( new e.ForbiddenError('Not logged in'));
    return; 
  }

  parametersAreThere(req.body, ['workspace'], errors);

  // There were errors: end of story, don't even bother the database
  if(errors.length){
    next( new e.ValidationError('Required parameters missing', errors));
    return;
  }

  // Step 1: Check that the workspace is not already taken
  Workspace.findOne({ name:req.body.workspace.toLowerCase() }, function(err, doc){
    if(err){
      next(new e.RuntimeError( err ) );
    } else {
      if(doc){
        errors.push( {field: "workspace", message: "Workspace taken, sorry!", mustChange: true} );
        next( new e.ValidationError('Validation failed', errors));
      } else {

        // Assign values
        var w = new Workspace();
        w.name = req.body.workspace;
        w.activeFlag = true;
        makeToken( function(err, token) {
          if(err){
             next(new e.RuntimeError( err ) );
          } else {
            w.access = {  userId: req.session.userId, token:token, isOwner: true }; 
            w.save( function(err){
              if(err){
                 next(new e.RuntimeError( err ) );
              } else{

                // Register the workspace, and return the worksapce Id in as an option (to allow redirect)
                sendResponse( res, { data: { workspaceId: w._id } } ); 

              }
            }); // w.save
          }
        }); // makeToken
      }
    }
  }); // Workspace.findOne


  //
  } , 500); // Artificial timeout
  //
}



var getLogoutUser = function(req, res, next){

  // *****
  setTimeout(function(){
  // *****

    // There is nothing to be checked: simply logs out by clearing the session variables
    // NOTE: req.session.login is properly set to null as the user really wanted to logout
    // NOTE2: Maybe not. In which case would this not be set to null...?
    req.session.loggedIn = false;
    // req.session.login = null;

    // Send an OK response. It's up to the client to redirect/etc.
    sendResponse( res, { } );

  //
  } , 500); // Artificial timeout
  //

}


var postRecoverAnon = function(req, res, next){

  // *****
  setTimeout(function(){
  // *****

  var errors = [];
  var Workspace = mongoose.model("Workspace");
  var User = mongoose.model("User");

  // Check that the email is indeed there
  parametersAreThere(req.body, ['email'], errors);
  if(errors.length){
    next( new e.ValidationError('Missing parameter: email', errors));
    return;
  }

  // **************************************************************
  // PHASE #1: SOFT VALIDATION (NO DB INTERACTION YET)
  //           "Because you cannot trust Javascript validation"
  // **************************************************************

  // Validate email
  var validatorEmail = Validators.email(req.body.email);
  if( ! validatorEmail.result ){
    errors.push( {field: 'email' , message: validatorEmail.message });
  }

  // There were errors: end of story, don't even bother the database
  if(errors.length){
    next( new e.ValidationError('Soft validation of parameters failed', errors));
    return;
  }
    
  // *******************************************************
  // PHASE #1: ADDING RECORDS TO DB (WITH CHECKS)
  // *******************************************************

  User.findOne( { login: req.body.email.toLowerCase() }, function(err, doc){
    // Log database error if it's there
    if(err ){
      next(new e.RuntimeError( err ) );
    } else {
      // If the user exists, add it to the error vector BUT keep going
      if(doc){
        hotplate.log("Sending email for " + doc.email);
        // TODO: SEND EMAIL USING NEW EMAIL INFRASTRUCTURE
      }
      sendResponse( res, { } );
    }
  }); // User.findOne()

  //
  } , 500); // Artificial timeout
  //
}




var postLoginAnon = function(req, res, next){

  // *****
  // setTimeout(function(){
  // *****

  var errors = [],
      User = mongoose.model("User"),
      Workspace = mongoose.model("Workspace");


  // **************************************************************
  // PHASE #1: SOFT VALIDATION (NO DB INTERACTION YET)
  //           "Because you cannot trust Javascript validation"
  // **************************************************************




  // **************************************************************
  // PHASE #1: SOFT VALIDATION (NO DB INTERACTION YET)
  //           "Because you cannot trust Javascript validation"
  // **************************************************************
    
  parametersAreThere(req.body, ['login', 'password'], errors);
  if(errors.length){
    next( new e.ValidationError('Missing required fields in request', errors));
    return;
  }

  var validatorLogin = Validators.login(req.body.login);
  if( ! validatorLogin.result ){
    errors.push( {field: 'login' , message: validatorLogin.message });
  }

  // There were errors: end of story, don't even bother the database
  if(errors.length){
    next( new e.ValidationError('Validation of some parameters failed', errors));
    return;
  }
    
  // *******************************************************
  // PHASE #2: POST THE DATA
  // Note: since we are posting username/password,
  // 
  // *******************************************************

  var forWorkspaceId = '';
  User.findOne( { login: req.body.login.toLowerCase()}, function(err, docUser){
    // Log database error if it's there
    if(err ){
      next(new e.RuntimeError( err ) );
    } else {
      // Password is incorrect: return errors
      if(! docUser || docUser.password != req.body.password){
          errors.push({ field:'password', message: 'Password incorrect', mustChange: false } );
          next( new e.ValidationError('Password incorrect', errors));
      } else {
        if( docUser.password == req.body.password ) {

          // Login and password correct: user is logged in, regardless of what workspace they were requesting access for.
          req.session.loggedIn = true;
          req.session.login = req.body.login;
          req.session.userId = docUser._id;

          // The client requested a login for a specific workspace name: attempt to set forWorkspaceId (if they have
          // access to that specific workspace)
          if( req.body.workspaceName != ''){

            User.findOne( { login: req.body.login.toLowerCase() } , function( err, docUser){
              if(err){
                 next(new e.RuntimeError( err ) );
              } else {
                

                Workspace.findOne( { 'name': req.body.workspaceName.toLowerCase(), 'access.userId' : docUser._id }, function(err, docWorkspace){
                  if(err ){
                    next(new e.RuntimeError( err ) );
                  } else {
                    if(docWorkspace){
                      forWorkspaceId = docWorkspace._id;
                    }
                    sendResponse( res, { data: { forWorkspaceId: forWorkspaceId } } );
                  }
                }); // Workspace.findOne(
              }
            }); //  User.findOne( 

          } // if( req.body.workspaceName != ''){


          // There was no specific requirement in terms of workspace, just return OK with empty forWorkspaceId
          else {

            // Finally send the OK response
            sendResponse( res, { data: { forWorkspaceId: '' } } );

          } // ELSE ( if( req.body.workspaceName != ''){ )


        } //if( docUser.password == req.body.password ) {
      }
    }
  }); // User.findOne()


  //
  // } , 500); // Artificial timeout
  //

}

var makeToken = function( callback ){

  var attempts = 0;
  look();

  function look(){
    Workspace = mongoose.model("Workspace");

    // Generate the token, check that it's indeed available
    var token = hat();
    Workspace.findOne( { 'access.token':token } , function(err, doc){

      // There is an error: call the callback returning an error
      if(err){
        callback(err, null);
      } else {

        // Token already there: either give up (too many attempts)...
        if( doc ){
          attempts ++;
          if( attempts == 5 ){
            callback( new Error("Cannot generate unique token"), null );
          } else {
            look();
          }
        // ... or try again by calling this function again!
        } else {
          callback(null, token );
        }
      }
    });
  }
}

