
define([
  "dojo/_base/declare",
  "dojo/json",
  "dojo/_base/lang",
  "dojo/request",
  "dojo/store/Observable",
  "dojo/topic",
  "dojo/on",
  "dojo/dom",
  "dojo/dom-class",
  "dojo/when",
  "dojo/Evented",

  "hotplate/hotDojoSubmit/defaultSubmit",
  "hotplate/hotDojoLogger/logger",
  "hotplate/hotDojoStores/stores",

   ], function(
     declare
     , json
     , lang
     , request
     , Observable
     , topic
     , on
     , dom
     , domClass
     , when
     , Evented

     , ds
     , Logger
     , stores

 ){

  var Messages = declare([Evented], {
 
    // Tab ID
    tabId: null,   
    registered: false,
    pollingNow: false,
    pollInterval: 20000,
    messages: [],
    timeoutId: 0,
    workspaceId: null,


    constructor: function(workspaceId){
      this.messages = [];

      // starts polling
      this.timeoutId = setTimeout( lang.hitch(this, this.poll), this.pollInterval );
    },
  
 
    register: function( workspaceId ){

      var that = this;

      // Set the workspace id, so that this library is at least
      // vaguely agnostic about its surrounding
      this.workspaceId = workspaceId;

      return request('/call/'+this.workspaceId+'/register',
              {
                method: 'get',
                handleAs: 'json',
              }
      ). then(

        function(res){
          that.tabId = res.tabId;
          return res._id;
        }

      );
    },

 
    poll: function(){

      var that = this;

      // If it's polling right now, don't do anything.
      if( this.pollingNow || ! this.workspaceId ){
         return;
      }
      this.pollingNow = true;

      // This came from Javascript, cancel the current timeout and a new one
      // will be created at the end
      if( this.timeoutId ){
        clearTimeout( this.timeoutId );
        this.timeoutId = 0;
      }

      // No polling possible: no tab id!
      if( ! this.tabId ){
        return;
      }

      request('/call/'+this.workspaceId+'/ping/'+this.tabId,
              {
                data: { 
                  tabId: this.tabId,
                  messages: json.stringify(this.messages)
                } ,
                method: 'post',
                handleAs: 'json',
              }
      ). then(

        function(res){

          // Check that a new tabId hasn't come back -- if it has,
          // refresh the object

          that.messages = [];       
 
          // Emit message events. The event name is "type"
          if( res && Array.isArray(res)  ){
            res.forEach( function(item) {
              // Wait! Amongst the results, there was "reset": it means that the
              // tabId has changed! Will need to get the new one
              if( item.type === 'reset' ){
                that.tabId = item.message.tabId;
              }

              that.emit( item.type, { from: item.from, message: item.message } );
            });
          } 

          that.timeoutId = setTimeout( lang.hitch(that, that.poll), that.pollInterval );
          that.pollingNow = false;
        },

        function(err){

          // There was an error: set the next timeout, stop the polling,
          // will try again later
          that.timeoutId = setTimeout( lang.hitch(that, that.poll), that.pollInterval );
          that.pollingNow = false;
        }

      );

    },

    propagate: function(toType, type, message){

      if( ! this.tabId ) return;

      if( toType === 'toMyTabs' || toType === 'toEverybody' ){
        this.messages.push( { toType: toType, type: type, message: message } ); 
      }
    }
     


  } );
   
  return new Messages();

});


