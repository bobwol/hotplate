
define([
  "dojo/_base/declare",
  "dojo/json",
  "dojo/_base/lang",
  "dojo/request",
  "dojo/Evented",
  "dojo/topic",

   ], function(
     declare
     , json
     , lang
     , request
     , Evented
     , topic

 ){

  var Messages = declare([Evented], {
 
    // Tab ID
    tabId: null,   
    registered: false,
    syncingNow: false,
    syncInterval: 4000,
    messages: [],
    timeoutId: 0,
    workspaceId: null,


    constructor: function(){
      this.messages = [];

    },
  
 
    register: function( workspaceId ){

      var that = this;

      // Set the workspace id, so that this library is at least
      // vaguely agnostic about its surrounding

      return request('/call/' + workspaceId + '/register',
              {
                method: 'get',
                handleAs: 'json',
              }
      ).then(

        function(res){
          that.tabId = res.tabId;
          that.workspaceId = workspaceId;
          
          // starts syncing
          this.timeoutId = setTimeout( lang.hitch(that, that.sync), that.syncInterval );

          return res._id;
        }

      );
    },


    unregister: function(){

      var that = this;

      if( ! this.workspaceId ){
        return;
      }

      return request('/call/' + this.workspaceId + '/unregister',
              {
                method: 'post',
                data: { tabId: this.tabId } 
              }
      ).then( function(res){
        this.workspaceId = null;
        this.tabId = null;
      });
    },

 
    sync: function(){

      var that = this;

      // this.workspaceId and this.tabId are 100% necessary -- if they are not here,
      // it means that it wasn't successfully registered. So, quit.
      if( ! this.workspaceId || ! this.tabId ) return;

      // If it's syncing right now, don't do anything.
      if( this.syncingNow ) return; 
      this.syncingNow = true;

      // This came from Javascript, cancel the current timeout and a new one
      // will be created at the end
      if( this.timeoutId ){
        clearTimeout( this.timeoutId );
        this.timeoutId = 0;
      }

      request('/call/' + this.workspaceId + '/sync/' + this.tabId,
              {
                data: { 
                  tabId: this.tabId + 'ee',
                  messages: json.stringify(this.messages)
                } ,
                method: 'post',
                handleAs: 'json',
              }
      ). then(

        function(res){

          // Check that a new tabId hasn't come back -- if it has,
          // refresh the object

          that.messages = [];       
 
          // Emit message events. The event name is "type"
          if( res && Array.isArray(res)  ){
            res.forEach( function(item) {
              // Wait! Amongst the results, there was "reset": it means that the
              // tabId has changed! Will need to get the new one
              if( item.type === 'reset' ){
                that.tabId = item.message.tabId;
              }
              topic.publish( item.type, item.from, item.message );
            });
          } 

          that.timeoutId = setTimeout( lang.hitch(that, that.sync), that.syncInterval );
          that.syncingNow = false;
        },

        function(err){

          // There was an error: set the next timeout, stop the syncing,
          // will try again later
          that.timeoutId = setTimeout( lang.hitch(that, that.sync), that.syncInterval );
          that.syncingNow = false;
        }

      );

    },

    queue: function(toType, type, message){

      if( ! this.tabId ) return;

      if( toType === 'toMyTabs' || toType === 'toEverybody' ){
        this.messages.push( { toType: toType, type: type, message: message } ); 
      }
    }
     
  } );
   
  return new Messages();

});


