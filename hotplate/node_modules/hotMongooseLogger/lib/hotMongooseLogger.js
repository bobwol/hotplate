
var util = require('util')
  , fs = require('fs')
  , url = require('url')
  , hotplate = require('hotplate')
  , mongoose = require('mongoose')
  , async = require('async')
  , app = hotplate.app
;


// Module's variables
var logModel = {};
var schemaObject = {};


exports.hotHooks = hooks = {}

hooks.init = function( done ){

  // Get all logFields from all modules, creating schemaObject
  hotplate.invokeAll('logFields', function(err, results){
    results.forEach(function(entry){
      var result = entry.result;
      for(var k in result){
        schemaObject[k] = result[k];
      }
    })
  });

  // Create logModel based on schemaObject
  logModel = mongoose.model('Log' , new mongoose.Schema( schemaObject ) ); 
  done( null );
}
hooks.init.invokes = [ 'logFields' ];

hooks.run = function( done ){

  // JSON get
  app.get( '/call/:workspaceIdCall/logs', logs );
  app.get(      '/api/1/:tokenCall/logs', logs );

  done( null );

}

hooks.log = function( done, entry){

  // Create the model
  var log = new logModel();

  // Cycle through the data to be logged...
  for(var k in entry){

    // If it's set to be serialised, to so.
    if( schemaObject[k] && schemaObject[k].serialize  ){
      entry[k] = JSON.stringify(entry[k]);
    }

    // Assign it.
    log[k] = entry[k];
  }

  // Save the record.
  log.save();

  done( null );

}


hooks.stores = function( done ){
  done( null, {
    logs: { target: '/call/:workspaceIdCall/logs', idProperty: '_id', sortParam: 'sortBy', },
  } );

}


function logs( req, res, next ){
  
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;
  var query;


  Workspace = mongoose.model('Log');
  query = Workspace.find({});


  enrich(req, res, query, { operator:'or', partial: { errorName: true}  },  function( err ){
    if( err ){
      console.log(err);
      next( new e.RuntimeError( err ) );
    } else { 

      query.exec( function( err, doc ){
        if(err ){
          next(new e.RuntimeError( err ) );
        } else {
          sendResponse( res, { data: doc  } );
        }
      });
    }
  });
}


/* TODO:
   Check for nasty characters in filters. At the moment, I don't do any sanitizing of the
   filters, and I probably should. I will do tests when I have a checkbox to set filters
*/
function enrich(req, res, query, options, callback ){

  var cachePaging = {};

  function enrichWhereSort( next ){ 
    var url_parts = url.parse(req.url, false );
    var q = url_parts.query || '';
    var sortBy;
    var rangefrom;
    var rangeTo;
    var tokens, subTokens, i;
    var orArray = []; 

    options = typeof(options) === 'object' ? options : {};
    options.partial = typeof(options.partial) === 'object' ? options.partial : {};

    tokens = q.split('&').forEach( function( item ) {
      var tokens = item.split('=');

      // CASE 1: it's a sorting option
      if(tokens[0] === 'sortBy'){
        subTokens = tokens[1].split(',');
        for( i = 0; i < subTokens.length; i++ ){
          if(subTokens[i].match(/[\+\-][a-zA-Z]+/)){
            sortBy = subTokens[i].replace('+', '');
            query.sort(sortBy);
          }
        }

      // CASE #2: It's a filter
      } else {

        if(tokens[0].match(/[a-zA-Z]+/)){

          // It's an "or" operator: add the condition to the array
          if( options.operator === 'or'){
            tmp = {}
            if( options.partial[ tokens[0] ]){
              tmp[ tokens[0] ] = new RegExp('^' + tokens[1] + '.*' );
            } else {
              var tmp = {};
              tmp[ tokens[0] ] = tokens[1];
            }
            orArray.push( tmp );

          // It's an "and" operator (default): add it using Mongoose's magic
          } else {
            if( options.partial[ tokens[0] ]){
              query.where( tokens[0]).regex( new RegExp('^' + tokens[1] + '.*' ) );
            } else {
              query.where( tokens[0]).equals(tokens[1] );
            }
          }
        }
      } 
    });

    // Add the ors (which at this point are still just conditions in the
    // orArray variable
    if( options.operator === 'or' && orArray.length ){
      query.or( orArray );
    }
     

    // If there was a range request, then set the range to the
    // query and return the count
    var hr;
    if( (hr = req.headers['range']) && ( tokens = hr.match(/items=([0-9]+)\-([0-9]+)$/))  ){
      rangeFrom = tokens[1];
      rangeTo = tokens[2];
      // hotplate.log(rangeFrom);
      // hotplate.log(rangeTo);

      query.skip(rangeFrom).limit(rangeTo - rangeFrom + 1 );

      // Hack to run the count on the query with the current _conditions
      // var countQuery = query.count();
      //query.model.collection.count(query._conditions, function(err, total){
      query.count( function( err, total ) {
        query.find();
        if( err ){
          next( err );
        } else {
          res.setHeader('Content-Range', 'items ' + rangeFrom + '-' + rangeTo + '/' + total );
          next( null );
        }
      });
    } else {
      next( null );
    }
  }

  // Run all of them
  async.series( [ enrichWhereSort ] , callback );

}
