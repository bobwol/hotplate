
var util = require('util')
  , fs = require('fs')
  , url = require('url')
  , hotplate = require('hotplate')
  , mongoose = require('mongoose')
  , async = require('async')
  , app = hotplate.app
;


// Module's variables
var logModel = {};
var schemaObject = {};


exports.hotHooks = hooks = {}

hooks.init = function( done ){

  // Get all logFields from all modules, creating schemaObject
  hotplate.invokeAll('logFields', function(err, results){
    results.forEach(function(entry){
      var result = entry.result;
      for(var k in result){
        schemaObject[k] = result[k];
      }
    })
  });

  // Create logModel based on schemaObject
  logModel = mongoose.model('Log' , new mongoose.Schema( schemaObject ) ); 
  done( null );
}
hooks.init.invokes = [ 'logFields' ];

hooks.run = function( done ){

  // JSON get
  app.get( '/call/:workspaceIdCall/logs', logs );
  app.get(      '/api/1/:tokenCall/logs', logs );

  done( null );

}

hooks.log = function( done, entry){

  // Create the model
  var log = new logModel();

  // Cycle through the data to be logged...
  for(var k in entry){

    // If it's set to be serialised, to so.
    if( schemaObject[k] && schemaObject[k].serialize  ){
      entry[k] = JSON.stringify(entry[k]);
    }

    // Assign it.
    log[k] = entry[k];
  }

  // Save the record.
  log.save();

  done( null );

}


hooks.stores = function( done ){
  done( null, {
    logs: { target: '/call/:workspaceIdCall/logs', idProperty: '_id', sortParam: 'sortBy', },
  } );

}


function logs( req, res, next ){
  
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;
  var query;


  // TODO: Add filtering and ordering, make functions about them (good luck with that), enjoy

  // Looks for a workspace. If it's there, answers without errors. If not,
  // answers with a very short error
  Workspace = mongoose.model('Log');
  query = Workspace.find({});

  enrich(req, res, query, {},  function( err ){
    if( err ){
      next( new e.RuntimeError( err ) );
    } else { 

      query.exec( function( err, doc ){
        if(err ){
          next(new e.RuntimeError( err ) );
        } else {
          sendResponse( res, { data: doc  } );
        }
      });
    }
  });
}



/* TODO:
  * Fix the issue of the "count query" (see Google Group's post)
  * Fix the problem that it will only sort if one sorting parameter is specified (parse better)
  * Maybe add options to specify 1) To do OR or AND 2) For each parameter, to do regexp or equals 
  * Write another function that will filter by workspaceId 
*/
function enrich(req, res, query, options, callback ){

  function enrichWhereSort( next ){ 
    var url_parts = url.parse(req.url, false );
    var q = url_parts.query || '';
    var sortBy;
    var rangefrom;
    var rangeTo;

    var countQuery = query.model.find({});    

    var tokens = q.split('&').forEach( function( item ) {
      console.log( item );
      var tokens = item.split('=');

      // Add the correct sort or filter
      if(tokens[0] === 'sortBy'){
        if(tokens[1].match(/[\+\-][a-zA-Z]+/)){
          sortBy = tokens[1].replace('+', '');
          query.sort(sortBy);
          countQuery.sort(sortBy);
        }
      } else {
        if(tokens[0].match(/[a-zA-Z]+/)){
          query.where(tokens[0]).equals(tokens[1]);
          countQuery.where(tokens[0]).equals(tokens[1]);
          //query.where(tokens[0]).regex( new RegExp('^' +  tokens[1] + '.*' ) );
          //countQuery.where(tokens[0]).regex( new RegExp('^' +  tokens[1] + '.*' ) );
        }
      }
    });

    // If there was a range request, then set the range to the
    // query and return the count
    var hr;
    if( (hr = req.headers['range']) && ( tokens = hr.match(/items=([0-9]+)\-([0-9]+)$/))  ){
      rangeFrom = tokens[1];
      rangeTo = tokens[2];
      console.log(rangeFrom);
      console.log(rangeTo);

      query.skip(rangeFrom).limit(rangeTo - rangeFrom );
      countQuery.count().exec(function( err, total ) {
        if( err ){
          next( err );
        } else {
          res.setHeader('Content-Range', 'items ' + rangeFrom + '-' + rangeTo + '/' + total );
          next( null );
        }
      });
    } else {
      next( null );
    }
  }

  // Run all of them
  async.series( [ enrichWhereSort ] , callback );

}
