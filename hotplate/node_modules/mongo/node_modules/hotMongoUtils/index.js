
var 
  dummy
, hotplate =  require('hotplate')
, url = require('url')
, async = require('async')
, checkObjectId = require('mongoWrapper').checkObjectId
, ObjectId = require('mongoWrapper').ObjectId
;


exports.hotHooks = hooks = {}


var MongoStore = function( options ){
  var i;

  // Mixin the options en masse
  for( var i in options ) this[i] = options[i];

  // Sets collectionObject based on the `collection` parameter
  this.collectionObject = db.collection( options.collection );  

  // This.storeName will default to the collection's name if not set
  this.storeName = typeof( this.storeName ) === 'undefined' ? this.collection : this.storeName;
}

MongoStore.prototype.e = hotplate.getModule('hotError').errors;

MongoStore.prototype.findOne = function( req, next,   cb ) {
  if( this.paramsIds.length === 1 ) {
    this.collectionObject.findOne( {_id: ObjectId( req.params[this.paramsIds[0]] ) }, cb );
  } else {
    cb( new Error("findOne needs to be defined manually when paramsIds > 1") );
  }
}




MongoStore.prototype.setUpdateObject = function( req, next, cleanBody, cb ){

  var updateObject = {}, i;
  var updateObjectPrefix

  // Set updatePrefix to either its `this` counterpart ot to ''
  updateObjectPrefix = typeof( this.updateObjectPrefix ) === 'undefined' ? '' : this.updateObjectPrefix;

  // Simply copy values over from `req.body`
  for( i in cleanBody ){
      updateObject[ updateObjectPrefix + i ] = cleanBody[ i ];
  }
  // Sets `this.updateObject`
  this.updateObject = { $set: updateObject }    
  cb();
}


MongoStore.prototype.setBroadcastObject = function( req, next, cb ){
  this.broadcastObject = this.docSection;
  cb();
}

MongoStore.prototype.setDocSection = function( req, next, cb ){
  this.docSection = this.fetchedDoc;
  cb();
}

MongoStore.prototype.checkPermissionsGet = function( req, next, cb ){
  cb();
}
MongoStore.prototype.checkPermissionsPut = function( req, next, cb ){
  cb();
}

MongoStore.prototype.prepareDocSectionBeforeSend = function( req, next, cb ){
  cb();
}

MongoStore.prototype.findAndModify = function( req, next,  cb ){
  var findAndModifySelector;

  // Works out findAndModifySelector, by either getting it from the options, or trying to make one up
  if( this.findAndModifySelector ){
     findAndModifySelector = this.findAndModifySelector;
  } else {
    if( this.paramsIds.length === 1 ) {
      findAndModifySelector = { _id: ObjectId( req.params[this.paramsIds[0]]) };
    } else {
      cb( new Error("findAndModify OR findAndModifySelector need to be defined manually when paramsIds > 1") );
    }
  }
      
  // At this point, either cb() was called with an error, or the object findAndModifySelector is ready to be rolled
  if( findAndModifySelector ){
    this.collectionObject.findAndModify( findAndModifySelector, {}, this.updateObject, {new: true}, cb );
  }
}


MongoStore.prototype.validate = function( req, next, errors, cb ){
  cb();
}


MongoStore.prototype.makeGet = function(  ){

  var self = this;
  return function( req, res, next ){

    var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
    var perms = hotplate.getModule('hotPerms');
    var errors = [];
    var collectionObject = db.collection( self.collection  );

     // Check that paramsId are actually IDs. If there is a problem, fire a synthetic "not found"
    var fireSyntheticNotFound = false;
    if( self.paramsIds ){
      self.paramsIds.forEach( function(k){
        if( ! checkObjectId( req.params[k]  ) )
          errors.push( { field: k, message: 'Invalid ID in URL: ' + k, mustChange: false } );
      });
    }
    if( errors.length ){
      next( new self.e.ValidationError('Validation problems', errors));
      return;
    }

    self.findOne( req, next, function( err, doc ){
      exports.checkFindOneResponse( err, doc, next, function(){
        // This is expected to be set  before checkPermissions
        self.fetchedDoc = doc;
        self.setDocSection( req, next, function(){
          self.checkPermissionsGet( req, next, function(){
            self.prepareDocSectionBeforeSend(req, next,  function(){
              sendResponse( res, self.docSection );
             });
          });
        });
      });
    });
  }
}


exports.MongoStore = MongoStore;
exports.Config = MongoStore;



exports.makeGet = function( options ){

  return function( req, res, next ){
    
    var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
    var perms = hotplate.getModule('hotPerms');
    var errors = [];

    var collectionObject = db.collection( options.collection  );

   
     // Check that paramsId are actually IDs. If there is a problem, fire a synthetic "not found"
    var fireSyntheticNotFound = false;    
    if( options.paramsIds ){
      options.paramsIds.forEach( function(k){
        if( ! checkObjectId( req.params[k]  ) )
          errors.push( { field: k, message: 'Invalid ID in URL: ' + k, mustChange: false } );
      });
    }
    if( errors.length ){
      next( new options.e.ValidationError('Validation problems', errors));
      return;
    } 


    options.findOne( req, next, function( err, doc ){
      exports.checkFindOneResponse( err, doc, next, function(){
        // This is expected to be set  before checkPermissions
        options.fetchedDoc = doc;
        options.setDocSection( req, next, function(){
          options.checkPermissionsGet( req, next, function(){
            options.prepareDocSectionBeforeSend(req, next,  function(){
              sendResponse( res, options.docSection );
             });
          });
        });
      });
    });
  }

}

exports.makePut = function( options ){

  return function( req, res, next ){

    var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
    var e = hotplate.getModule('hotError').errors;
    var perms = hotplate.getModule('hotPerms');
    var messages = hotplate.getModule('hotMongoCometMessages');
    var k, errors = [];
    var collection, validate, findOne;
    var cleanBody;

    // Set the collection
    options.collectionObject = db.collection( options.collection );

    // Check that paramsId are actually IDs
    if( options.paramsIds ){
      options.paramsIds.forEach( function(k){
        if( ! checkObjectId( req.params[k] ) )
          errors.push( { field: k, message: 'Invalid ID in URL: ' + k, mustChange: false } );
      });
    } 
   
    options.schema.cast(  req.body );
    options.schema.check( req.body, errors );

    options.validate( req, next,    errors, function(){
      if( errors.length ){
        next( new e.ValidationError('Validation problems', errors));
      } else {

        // Get the workspace, for permission checking
        options.findOne( req, next,   function( err, doc ){
          exports.checkFindOneResponse( err, doc, next, function(){

            // Sets options.fetchedDoc so that the following functions
            // can use it if they like
            options.fetchedDoc = doc;

            // Sets this.docSection, which is by default the whole fetched doc. However,
            // if there was an elemMatch and daling with a sub-document, the
            // logic to isolate the actual portion being fetch should be here.
            // this.docSection is what will actually get broadcast
            options.setDocSection( req, next, function(){

              // Actually check permissions
              options.checkPermissionsPut( req, next, function(){

 
                cleanBody = {};
                for( var k in req.body )
                  if( ! options.schema.structure[ k ].doNotSave )
                    cleanBody[ k ] = req.body[ k ];
           
                // Al clear: set this.updateObject
                options.setUpdateObject( req, next, cleanBody, function(){

                  // Modify the object. findAndModify instead of update, as we need the record to broadcast changes 
                  options.findAndModify( req, next, function( err, doc ) {
                    exports.checkErr( err, doc, next, function(){

                      // Reset fetchedDoc to the latest doc
                      options.fetchedDoc = doc;

                      // Reset docSection once again, now that fetchedDoc has changed
                      options.setDocSection( req, next, function(){

                        // Send empty response as by protocol
                        sendResponse( res );
                    
                        if( ! options.killComet ){
                          options.setBroadcastObject( req, next, function(){
              
                            // Broadcast the change
                            messages.sendToTabsOfWorkspace(

                              // These ones never change
                              req.application.workspace._id,
                              ObjectId( req.body._tabId ),
                              req.application.user._id,
                              'storeUpdate',

                              // These ones do change: it's the message to broadcast
                              { storeName: options.storeName, 
                                objectId: options.broadcastObject._id.toString(),
                                object: options.broadcastObject, 
                                remote: true 
                              } );
                          });
                        }
                      }); // setDocSection

                    }); // checkErr
                  });// findAndModify

                });// setUpdateObject

              });// checkPermissions

            }); // setDocSection

          }); // checkFindOneResponse
        }); // findOne
      }
    }); // validate
  }
}


exports.checkFindOneResponse = function( err, doc, next, cb) {
  var e = hotplate.getModule('hotError').errors;

  if( err ){
    next( new e.RuntimeError( err ) );
  } else {
    if( ! doc ){
      next( new e.NotFoundError() );
    } else {
      cb();
    }
  }
}

exports.checkErr = function( err, doc, next, cb) {
  var e = hotplate.getModule('hotError').errors;

  if( err ){
    next( new e.RuntimeError( err ) );
  } else {
    if( ! doc ){
      next( new Error("Document empty when it really shouldn't be") );
    } else {
      cb();
    }
  }
}







exports.enrichCursorSort = function(urlToParse, cursor, options ){

  var url_parts = url.parse( urlToParse, false );
  var q = url_parts.query || '';
  var sortBy;
  var tokens, subTokens, i;

  options = typeof( options) === 'object' ? options : {};
  options.allowedFields = typeof(options.allowedFields) === 'object' ? options.allowedFields : {};

  tokens = q.split( '&' ).forEach( function( item ) {

    var tokens = item.split('=');
    var tokenLeft = tokens[0];
    var tokenRight = tokens[1];

    // CASE 1: it's a sorting option
    // FIXME: Change make 'sortBy' configurable
    if(tokenLeft === 'sortBy'){
      sortArray = [];
      subTokens = tokenRight.split(',');
      for( i = 0; i < subTokens.length; i++ ){
        // TODO: Check if subTokens[i] is actually allowed as criteria
        if(subTokens[i].match(/[\+\-][a-zA-Z]+/)){
          var sortDirection = subTokens[i][0] == '+' ? 1 : -1;
          sortBy = subTokens[ i ].replace( '+', '' ).replace( '-', '' );
          sortArray.push( [ sortBy, sortDirection ] );
        }
      }
      // Add sorting to the cursor
      if( sortArray.count ){
        cursor.sort(sortArray);
      }
    }
  });
}

exports.enrichCursorRange = function( req, res, cursor, options, cb ){

  var tokens, i;

  options = typeof( options) === 'object' ? options : {};

  // If there was a range request, then set the range to the
  // query and return the count
  var hr;
  if( (hr = req.headers['range']) && ( tokens = hr.match(/items=([0-9]+)\-([0-9]+)$/))  ){
    rangeFrom = tokens[1];
    rangeTo = tokens[2];

    console.log("Requested range from client: " + rangeFrom + '-' + rangeTo );

    cursor.skip( rangeFrom - 0 );
    cursor.limit( rangeTo - rangeFrom + 1);
    console.log("Limiting to " + ( rangeTo - rangeFrom + 1 ) );

    cursor.count( function( err, total ) {
      if( err ){
        cb( err );
      } else {

        res.setHeader('Content-Range', 'items ' + rangeFrom + '-' + rangeTo + '/' + total );
        console.log("Setting header: " + 'items ' + rangeFrom + '-' + rangeTo + '/' + total );
        cb( null );
      }
    });
  } else {
    cb( null );
  }

}



exports.enrichSelector = function( urlToParse, selector, options ){

  var url_parts = url.parse( urlToParse, false );
  var q = url_parts.query || '';
  var tokens, i;
  var tmp;
  var selectorArray = [];

  options = typeof( options) === 'object' ? options : {};
  options.partial = typeof(options.partial) === 'object' ? options.partial : {};

  tokens = q.split( '&' ).forEach( function( item ) {

    var tokens = item.split('=');
    var tokenLeft  = tokens[0];
    var tokenRight = tokens[1];


    if(tokenLeft != 'sortBy' && tokenLeft.match(/[a-zA-Z]+/)){

      tmp = {}
      if( options.partial[ tokenLeft ]){
        tmp[ tokenLeft ] = { $regex: new RegExp('^' + tokenRight + '.*' ) };
      } else {
        // If it is a number, interprets it as a number. This is a bit of guesswork,
        // I think it will be best to have an option to cast values from strings
        if( ! isNaN(tokenRight) ) tokenRight = tokenRight - 0;
        tmp[ tokenLeft ] = tokenRight;
      }
      selectorArray.push( tmp );
    }

  });

  if( selectorArray.length ){
    if( options.operator === 'or'){
      selector['$or'] = selectorArray;
    } else {
      selector['$and'] = selectorArray;
    }
  }




}


