
var util = require('util')
  , fs = require('fs')
  , url = require('url')
  , hotplate = require('hotplate')
  , mongoose = require('mongoose')
  , async = require('async')
  , app = hotplate.app
  , ObjectId = require('mongoWrapper').ObjectId
  , db = hotplate.get('db')
;


// Module's variables
var logFields = {};

exports.hotHooks = hooks = {}

hooks.init = function( done ){

  var logs = db.collection('logs');
  var index = {};

  // Get all logFields from all modules, creating indexes if necessary
  hotplate.invokeAll( 'logFields', function( err, results ){
    results.forEach( function(entry){
      for( var k in entry ){
        // Gets the field cached by the module. Only these fields will actually get written to the DB
        logFields[ k ] = entry[ k ];
        if(  entry[ k ].index ) {
          index[ k ] = 1;
          hotplate.log( "Ensuring indexes for %s", k );
          logs.ensureIndex( index, function( err, res ){
            if( err ) console.log("Error creating index for %s!" ,k );
          });
        }
      }
    })
    done( null );

  });
}
hooks.init.invokes = [ 'logFields' ];

hooks.run = function( done ){


  app.get( '/call/:workspaceIdCall/logs', logs );
  app.get(      '/api/1/:tokenCall/logs', logs );

  done( null );

}

hooks.log = function( done, entry){

  var logs = db.collection('logs');
  var log = {};

  // Cycle through the data to be logged...
  for(var k in entry){

    // It will only ever log fields defined by the logFields callback
    if( logFields[ k ] ){

      // If it's set to be serialised, to so.
      if( logFields[ k ].serialize  ){
        entry[ k ] = JSON.stringify( entry[ k ] );
      }

      // Assign it
      log[k] = entry[k];

    } else {
      console.log("Ignoring field %s as it wasn't defined as a logging field", k );
    }

  }

  // Save the record. If it doesn't work, it's not the end of the world
  logs.insert( log, function() {} );

  done( null );

}


hooks.stores = function( done ){
  done( null, {
    logs: { target: '/call/:workspaceIdCall/logs/', idProperty: '_id', sortParam: 'sortBy', },
  } );

}

function logs( req, res, next ){
  
  var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
  var e = hotplate.getModule('hotError').errors;
  var resUtils = hotplate.getModule('hotResUtils');
  var mongoUtils = hotplate.getModule('hotMongoUtils');
  var cursor;

  logs = db.collection('logs');

  var selector = {};

  mongoUtils.enrichSelector( req.url, selector, { operator: 'or', partial: { errorName: true } } );
  cursor = logs.find(selector);
  mongoUtils.enrichCursorSort( req.url, cursor, {} );
  mongoUtils.enrichCursorRange( req, res, cursor, {}, function( err ){
    cursor.toArray( function( err, docs ){
      if( err ){
        next(new e.RuntimeError( err ) );
      } else {
        sendResponse( res, docs );
      }
    });
  });
}

