
var 
  dummy
, hotplate =  require('hotplate')
, url = require('url')
, async = require('async')
;


exports.hotHooks = hooks = {}

exports.checkFindOneResponse = function( err, doc, next, cb ){
  var e = hotplate.getModule('hotError').errors;

  if(err ){
    next(new e.RuntimeError( err ) );
  } else {
    if( ! doc  ){
      next( new e.NotFoundError() );
    } else {
      cb();
    }
  }
}

exports.checkFindResponse = function( err, doc, next, cb ){
  var e = hotplate.getModule('hotError').errors;

  if(err ){
    next(new e.RuntimeError( err ) );
  } else {
    if( ! doc || doc.length == 0 ){
      next( new e.NotFoundError() );
    } else {
      cb();
    }
  }
}

exports.checkErr = function( err, doc, next, cb) {

  var e = hotplate.getModule('hotError').errors;

  if( err ){
    next( new e.RuntimeError( err ) );
  } else {
    if( ! doc ){
      next( new Error("Document empty when it really shouldn't be") );
    } else {
      cb();
    }
  }
}


exports.checkFindOneResponse = function( err, doc, next, cb) {

  var e = hotplate.getModule('hotError').errors;

  if( err ){
    next( new e.RuntimeError( err ) );
  } else {
    if( ! doc ){
      next( new e.NotFoundError() );
    } else {
      cb();
    }
  }
}



exports.makeUpdateObject = function(prefix, data){

  // Make up update object
  var updateObject = {}
   for( var k in data ){
     if( k != '__v')
       updateObject[ prefix + k ] = data[k];
  }
  
  var incUpdate = {}
  incUpdate[ prefix + '__v' ] = 1;
  return { 
           $inc: incUpdate, 
           $set: updateObject 
         } ;
}



exports.parametersAreMissing = function(obj, attributes, errors, next){

  var e = hotplate.getModule('hotError').errors;

  attributes.forEach(function(attribute){
    if( typeof(obj) === 'undefined' || typeof(obj[attribute]) == 'undefined'){
      errors.push( { field: attribute, message: 'Required attribute not provided: ' + attribute, mustChange: false } );
    }
  });

  if( errors.length && typeof(next) === 'function' ){
    next( new e.ValidationError( "Validation error, missing parameters", errors ) );
    return true;
  }
  return false;
}


exports.parametersAreEmpty = function(obj, attributes, errors, next){

  var e = hotplate.getModule('hotError').errors;

  attributes.forEach(function(attribute){
    if( typeof( obj[attribute] ) !== 'undefined' && obj[attribute] == '' ){
      errors.push( { field: attribute, message: 'Value cannot be empty', mustChange: false } );
    }
  });

  return exports.respondIfErrors( errors, next );

}

exports.respondIfErrors = function( errors, next ){

  var e = hotplate.getModule('hotError').errors;

  if( errors.length && typeof(next) === 'function' ) {
    next( new e.ValidationError('Validation error', errors ) );
    return true;
  }
  return false;
}



exports.findAndSave = function( model, query, updater, next ){

  model.findOne( query, function( err, doc ) {
    if( err ){
      next( err, null );
    } else {
      if(! doc ){
        next( new Error("Object to save not found"), null );
      } else {

        // Run the updater and save...
        updater( doc );
        doc.save( next );
      }
    }
  });
}



/* TODO:
   Check for nasty characters in filters. At the moment, I don't do any sanitizing of the
   filters, and I probably should. I will do tests when I have a checkbox to set filters
*/
exports.enrichQuery = function(req, res, query, options, callback ){

  var cachePaging = {};

  function enrichWhereSort( next ){ 
    var url_parts = url.parse(req.url, false );
    var q = url_parts.query || '';
    var sortBy;
    var rangefrom;
    var rangeTo;
    var tokens, subTokens, i;
    var orArray = []; 

    options = typeof(options) === 'object' ? options : {};
    options.partial = typeof(options.partial) === 'object' ? options.partial : {};
    options.allowedFields = typeof(options.allowedFields) === 'object' ? options.allowedFields : {};

    tokens = q.split('&').forEach( function( item ) {
      var tokens = item.split('=');

      // CASE 1: it's a sorting option
      if(tokens[0] === 'sortBy'){
        subTokens = tokens[1].split(',');
        for( i = 0; i < subTokens.length; i++ ){
          // TODO: Check if subTokens[i] is actually allowed
          if(subTokens[i].match(/[\+\-][a-zA-Z]+/)){
            sortBy = subTokens[i].replace('+', '');
            query.sort(sortBy);
          }
        }

      // CASE #2: It's a filter
      } else {

        if(tokens[0].match(/[a-zA-Z]+/)){

          // It's an "or" operator: add the condition to the array
          if( options.operator === 'or'){
            tmp = {}
            if( options.partial[ tokens[0] ]){
              tmp[ tokens[0] ] = new RegExp('^' + tokens[1] + '.*' );
            } else {
              var tmp = {};
              tmp[ tokens[0] ] = tokens[1];
            }
            orArray.push( tmp );

          // It's an "and" operator (default): add it using Mongoose's magic
          } else {
            if( options.partial[ tokens[0] ]){
              query.where( tokens[0]).regex( new RegExp('^' + tokens[1] + '.*' ) );
            } else {
              query.where( tokens[0]).equals(tokens[1] );
            }
          }
        }
      } 
    });

    // Add the ors (which at this point are still just conditions in the
    // orArray variable
    if( options.operator === 'or' && orArray.length ){
      query.or( orArray );
    }
     

    // If there was a range request, then set the range to the
    // query and return the count
    var hr;
    if( (hr = req.headers['range']) && ( tokens = hr.match(/items=([0-9]+)\-([0-9]+)$/))  ){
      rangeFrom = tokens[1];
      rangeTo = tokens[2];
      // hotplate.log(rangeFrom);
      // hotplate.log(rangeTo);

      query.skip(rangeFrom).limit(rangeTo - rangeFrom + 1 );

      // Hack to run the count on the query with the current _conditions
      // var countQuery = query.count();
      //query.model.collection.count(query._conditions, function(err, total){
      query.count( function( err, total ) {
        query.find();
        if( err ){
          next( err );
        } else {
          res.setHeader('Content-Range', 'items ' + rangeFrom + '-' + rangeTo + '/' + total );
          next( null );
        }
      });
    } else {
      next( null );
    }
  }

  // Run all of them
  async.series( [ enrichWhereSort ] , callback );
}

/*

// UNUSED
function makeValidationErrorFromMongoose(err, prefix, message){

  var errors = [];
  var e = hotplate.getModule('hotError').errors; 

  for( var y in err.errors ){
    var yy = y.replace(prefix, '');
    errors.push( { field: yy, message:err.errors[y].type } );
  }
  return new e.ValidationError(message, errors) ;
}
*/


