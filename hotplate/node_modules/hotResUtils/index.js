
var 
  dummy
, hotplate =  require('hotplate')
, url = require('url')
, async = require('async')
, checkObjectId = require('mongoWrapper').checkObjectId
, ObjectId = require('mongoWrapper').ObjectId
;


exports.hotHooks = hooks = {}


var SimpleSchema = function( structure ){
  this.structure = structure;
}

SimpleSchema.prototype.cast = function( object, errors ){

/*
    schema: {
      longName: { type: 'string', isRequired: true, notEmpty: true, trim: 35 },
      tag     : { type: 'number', notEmpty: true, max: 30 },
      _id     : { type: 'id', isRequired: true },
      _tabId  : { type: 'id', doNotSave: true },
    }
  */

  var type;

  if( ! Array.isArray( errors ) ) errors = [];

  // Scan passed object
  for( var k in object ){

      type = this.structure[ k ];

      switch(type.type){

        case 'string':

          // Cast it
          object[ k ] = object[ k ].toString();
          // Trim it if necessary
          if( type.trim ) object[ k ] = object[ k ].substr( 0, type.trim );
        break;
   
        case 'number':
          // Cast it
          object[ k ] = Number( object[k] );

          // Check its range
          if( typeof( type.max ) !== 'undefined'  && object[k] > type.max )
            errors.push( { field: k, message: 'Field is too high: ' + k, mustChange: true } );
          if( typeof( type.min ) !== 'undefined'  && object[k] < type.min )
            errors.push( { field: k, message: 'Field is too low: ' + k, mustChange: true } );
        break;

        case 'date':
          object[ k ] = new Date( object[ k ] );
        break;

        case 'id':
          if( ! checkObjectId( object[ k ] ) )
            errors.push( { field: k, message: 'Invalid ID: ' + k, mustChange: false } );
        break;
      }
 
  }
  
}

SimpleSchema.prototype.check = function( object, errors ){

/*
    schema: {
      longName: { type: 'string', isRequired: true, notEmpty: true, trim: 35 },
      tag     : { type: 'number', notEmpty: true, max: 30 },
      _id     : { type: 'id', isRequired: true },
      _tabId  : { type: 'id', doNotSave: true },
    }
  */

  var type;

  if( ! Array.isArray( errors ) ) errors = [];

  // Scan passed object
  for( var k in object ){

    // First of all, if it's not in the schema, it's not allowed
    if( typeof( this.structure[ k ] ) === 'undefined' ){
      errors.push( { field: k, message: 'Field not allowed: ' + k, mustChange: false } );
    } else {

      // Get the value type
      type = this.structure[ k ];
    
      // Check if the value was required
      if( type.isRequired ){
        if( typeof( object[ k ] ) === 'undefined' )
          errors.push( { field: k, message: 'Field required: ' + k, mustChange: true } );
      }
    
      // Check if the value was empty and it shouldn't have been
      if( type.notEmpty ){
        if( object[ k ] == '' )
          errors.push( { field: k, message: 'Field cannot be empty: ' + k, mustChange: true } );
      }

    }
 
  }
  
}


exports.SimpleSchema = SimpleSchema;


var Config = function( options ){
  var i;

  // Mixin the options en masse
  for( var i in options ) this[i] = options[i];

  // Sets collectionObject based on the `collection` parameter
  this.collectionObject = db.collection( options.collection );  

  // This.storeName will default to the collection's name if not set
  this.storeName = typeof( this.storeName ) === 'undefined' ? this.collection : this.storeName;
}

Config.prototype.e = hotplate.getModule('hotError').errors;

Config.prototype.findOne = function( req, next,   cb ) {
  if( this.paramsIds.length === 1 ) {
    this.collectionObject.findOne( {_id: ObjectId( req.params[this.paramsIds[0]] ) }, cb );
  } else {
    cb( new Error("findOne needs to be defined manually when paramsIds > 1") );
  }
}



Config.prototype.setUpdateObject = function( req, next, cleanBody, cb ){

  var updateObject = {}, i;
  var updateObjectPrefix

  // Set updatePrefix to either its `this` counterpart ot to ''
  updateObjectPrefix = typeof( this.updateObjectPrefix ) === 'undefined' ? '' : this.updateObjectPrefix;

  // Simply copy values over from `req.body`
  for( i in cleanBody ){
      updateObject[ updateObjectPrefix + i ] = cleanBody[ i ];
  }
  // Sets `this.updateObject`
  this.updateObject = { $set: updateObject }    
  cb();
}


Config.prototype.setBroadcastObject = function( req, next, cb ){
  this.broadcastObject = this.fetchedDoc;
  cb();
}


Config.prototype.checkPermissions = function( req, next, cb ){
  cb();
}

Config.prototype.findAndModify = function( req, next,  cb ){
  var findAndModifySelector;

  // Works out findAndModifySelector, by either getting it from the options, or trying to make one up
  if( this.findAndModifySelector ){
     findAndModifySelector = this.findAndModifySelector;
  } else {
    if( this.paramsIds.length === 1 ) {
      findAndModifySelector = { _id: ObjectId( req.params[this.paramsIds[0]]) };
    } else {
      cb( new Error("findAndModify OR findAndModifySelector need to be defined manually when paramsIds > 1") );
    }
  }
      
  // At this point, either cb() was called with an error, or the object findAndModifySelector is ready to be rolled
  if( findAndModifySelector ){
    this.collectionObject.findAndModify( findAndModifySelector, {}, this.updateObject, {new: true}, cb );
  }
}


Config.prototype.validate = function( req, next, errors, cb ){
  cb();
}

exports.Config = Config;




exports.makeGet = function( options ){

  return function( req, res, next ){
    
    var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
    var perms = hotplate.getModule('hotPerms');
    var errors = [];

    var collectionObject = db.collection( options.collection  );

   
     // Check that paramsId are actually IDs. If there is a problem, fire a synthetic "not found"
    var fireSyntheticNotFound = false;    
    if( options.paramsIds ){
      options.paramsIds.forEach( function(k){
        if( ! checkObjectId( req.params[k]  ) )
          errors.push( { field: k, message: 'Invalid ID in URL: ' + k, mustChange: false } );
      });
    }
    if( errors.length ){
      next( new options.e.ValidationError('Validation problems', errors));
      return;
    } 


    options.findOne( req, next, function( err, doc ){
      exports.checkFindOneResponse( err, doc, next, function(){
        // This is expected to be set  before checkPermissions
        options.fetchedDoc = doc;
        options.checkPermissions( req, next, function(){
          options.manipulateDocBeforeSend(req, next,   doc, function( changedDoc ){
            sendResponse( res, changedDoc );
           });
        });
      });
    });
  }

}

exports.makePut = function( options ){

  return function( req, res, next ){

    var sendResponse = hotplate.getModule('hotProtocol').sendResponse;
    var e = hotplate.getModule('hotError').errors;
    var perms = hotplate.getModule('hotPerms');
    var messages = hotplate.getModule('hotMessages');
    var k, errors = [];
    var collection, validate, findOne;
    var cleanBody;

    // Set the collection
    options.collectionObject = db.collection( options.collection );

    // Check that paramsId are actually IDs
    if( options.paramsIds ){
      options.paramsIds.forEach( function(k){
        if( ! checkObjectId( req.params[k] ) )
          errors.push( { field: k, message: 'Invalid ID in URL: ' + k, mustChange: false } );
      });
    } 
   
    options.schema.cast(  req.body, errors );
    options.schema.check( req.body, errors );

    options.validate( req, next,    errors, function(){
      if( errors.length ){
        next( new e.ValidationError('Validation problems', errors));
      } else {

        // Get the workspace, for permission checking
        options.findOne( req, next,   function( err, doc ){
          exports.checkFindOneResponse( err, doc, next, function(){

            // Sets options.fetchedDoc so that the following functions
            // can use it if they like
            options.fetchedDoc = doc;

            // Actually check permissions
            options.checkPermissions( req, next, function(){
 
              cleanBody = {};
              for( var k in req.body )
                if( ! options.schema.structure[ k ].doNotSave )
                  cleanBody[ k ] = req.body[ k ];
           
              // Al clear: set this.updateObject
              options.setUpdateObject( req, next, cleanBody, function(){

                // Modify the object. findAndModify instead of update, as we need the record to broadcast changes 
                options.findAndModify( req, next, function( err, doc ) {
                  exports.checkErr( err, doc, next, function(){
 
                    // Send empty response as by protocol
                    sendResponse( res );
                    
                    options.setBroadcastObject( req, next, function(){
              
                      // Broadcast the change
                      messages.sendToTabsOfWorkspace(

                        // These ones never change
                        req.application.workspace._id,
                        ObjectId( req.body._tabId ),
                        req.application.user._id,
                        'storeUpdate',

                        // These ones do change: it's the message to broadcast
                        { storeName: options.storeName, 
                          objectId: options.broadcastObject._id.toString(),
                          object: options.broadcastObject, 
                          remote: true 
                        } );

                    });
                  }); // checkErr
                });// findAndModify
              });// setUpdateObject
            });// checkPermissions
          }); // checkFindOneResponse
        }); // findOne
      }
    }); // validate
  }
}


exports.currentUserInWorkspaceAccess = function( req, workspaceObject ){
  return  workspaceObject.access.filter( function(o){ 
     return o._id.toString() === req.application.user._id.toString(); } ).length > 0;
}


exports.checkFindOneResponse = function( err, doc, next, cb) {
  var e = hotplate.getModule('hotError').errors;

  if( err ){
    next( new e.RuntimeError( err ) );
  } else {
    if( ! doc ){
      next( new e.NotFoundError() );
    } else {
      cb();
    }
  }
}

exports.checkErr = function( err, doc, next, cb) {
  var e = hotplate.getModule('hotError').errors;

  if( err ){
    next( new e.RuntimeError( err ) );
  } else {
    if( ! doc ){
      next( new Error("Document empty when it really shouldn't be") );
    } else {
      cb();
    }
  }
}










exports.parametersAreMissing = function(obj, attributes, errors, next){

  var e = hotplate.getModule('hotError').errors;

  attributes.forEach(function(attribute){
    if( typeof(obj) === 'undefined' || typeof(obj[attribute]) == 'undefined'){
      errors.push( { field: attribute, message: 'Required attribute not provided: ' + attribute, mustChange: false } );
    }
  });

  if( errors.length && typeof(next) === 'function' ){
    next( new e.ValidationError( "Validation error, missing parameters", errors ) );
    return true;
  }
  return false;
}


exports.parametersAreEmpty = function(obj, attributes, next){

  var e = hotplate.getModule('hotError').errors;
  var errors = [];

  attributes.forEach(function(attribute){
    if( typeof( obj[attribute] ) !== 'undefined' && obj[attribute] == '' ){
      errors.push( { field: attribute, message: 'Value cannot be empty', mustChange: false } );
    }
  });

  return exports.respondIfErrors( errors, next );

}

exports.parametersAllowed = function(obj, allowedFields, next){

  var e = hotplate.getModule('hotError').errors;
  var errors = [];

  console.log(obj);
  console.log(allowedFields);

  for( var k in obj ){
    if( allowedFields.indexOf( k ) == -1 ){
      errors.push( { field: k, message: 'Value not accepted: ' + k, mustChange: false } );
    }
  };
  return exports.respondIfErrors( errors, next );

}

exports.respondIfErrors = function( errors, next ){

  var e = hotplate.getModule('hotError').errors;

  if( errors.length && typeof(next) === 'function' ) {
    next( new e.ValidationError('Validation error', errors ) );
    return true;
  }
  return false;
}








exports.enrichCursorSort = function(urlToParse, cursor, options ){

  var url_parts = url.parse( urlToParse, false );
  var q = url_parts.query || '';
  var sortBy;
  var tokens, subTokens, i;

  options = typeof( options) === 'object' ? options : {};
  options.allowedFields = typeof(options.allowedFields) === 'object' ? options.allowedFields : {};

  tokens = q.split( '&' ).forEach( function( item ) {

    var tokens = item.split('=');
    var tokenLeft = tokens[0];
    var tokenRight = tokens[1];

    // CASE 1: it's a sorting option
    // FIXME: Change make 'sortBy' configurable
    if(tokenLeft === 'sortBy'){
      sortArray = [];
      subTokens = tokenRight.split(',');
      for( i = 0; i < subTokens.length; i++ ){
        // TODO: Check if subTokens[i] is actually allowed as criteria
        if(subTokens[i].match(/[\+\-][a-zA-Z]+/)){
          var sortDirection = subTokens[i][0] == '+' ? 1 : -1;
          sortBy = subTokens[ i ].replace( '+', '' ).replace( '-', '' );
          sortArray.push( [ sortBy, sortDirection ] );
        }
      }
      // Add sorting to the cursor
      if( sortArray.count ){
        cursor.sort(sortArray);
      }
    }
  });
}

exports.enrichCursorRange = function( req, res, cursor, options, cb ){

  var tokens, i;

  options = typeof( options) === 'object' ? options : {};

  // If there was a range request, then set the range to the
  // query and return the count
  var hr;
  if( (hr = req.headers['range']) && ( tokens = hr.match(/items=([0-9]+)\-([0-9]+)$/))  ){
    rangeFrom = tokens[1];
    rangeTo = tokens[2];

    console.log("Requested range from client: " + rangeFrom + '-' + rangeTo );

    cursor.skip( rangeFrom - 0 );
    cursor.limit( rangeTo - rangeFrom + 1);
    console.log("Limiting to " + ( rangeTo - rangeFrom + 1 ) );

    cursor.count( function( err, total ) {
      if( err ){
        cb( err );
      } else {

        res.setHeader('Content-Range', 'items ' + rangeFrom + '-' + rangeTo + '/' + total );
        console.log("Setting header: " + 'items ' + rangeFrom + '-' + rangeTo + '/' + total );
        cb( null );
      }
    });
  } else {
    cb( null );
  }

}



exports.enrichSelector = function( urlToParse, selector, options ){

  var url_parts = url.parse( urlToParse, false );
  var q = url_parts.query || '';
  var tokens, i;
  var tmp;
  var selectorArray = [];

  options = typeof( options) === 'object' ? options : {};
  options.partial = typeof(options.partial) === 'object' ? options.partial : {};

  tokens = q.split( '&' ).forEach( function( item ) {

    var tokens = item.split('=');
    var tokenLeft  = tokens[0];
    var tokenRight = tokens[1];


    if(tokenLeft != 'sortBy' && tokenLeft.match(/[a-zA-Z]+/)){

      tmp = {}
      if( options.partial[ tokenLeft ]){
        tmp[ tokenLeft ] = { $regex: new RegExp('^' + tokenRight + '.*' ) };
      } else {
        // If it is a number, interprets it as a number. This is a bit of guesswork,
        // I think it will be best to have an option to cast values from strings
        if( ! isNaN(tokenRight) ) tokenRight = tokenRight - 0;
        tmp[ tokenLeft ] = tokenRight;
      }
      selectorArray.push( tmp );
    }

  });

  if( selectorArray.length ){
    if( options.operator === 'or'){
      selector['$or'] = selectorArray;
    } else {
      selector['$and'] = selectorArray;
    }
  }




}



/*

// UNUSED
function makeValidationErrorFromMongoose(err, prefix, message){

  var errors = [];
  var e = hotplate.getModule('hotError').errors; 

  for( var y in err.errors ){
    var yy = y.replace(prefix, '');
    errors.push( { field: yy, message:err.errors[y].type } );
  }
  return new e.ValidationError(message, errors) ;
}
*/

/*
exports.checkFindResponse = function( err, docs, next, cb ){
  var e = hotplate.getModule('hotError').errors;

  if(err ){
    next(new e.RuntimeError( err ) );
  } else {
    if( ! docs || docs.length == 0 ){
      next( new e.NotFoundError() );
    } else {
      cb();
    }
  }
}
*/

/* exports.makeUpdateObject = function(prefix, data){

  // Make up update object
  var updateObject = {}
   for( var k in data ){
     updateObject[ prefix + k ] = data[k];
  }
  
  return { $set: updateObject } ;
}
*/


