
var 
  dummy
, hotplate =  require('hotplate')
, url = require('url')
, async = require('async')
;


exports.hotHooks = hooks = {}


exports.checkFindOneResponse = function( err, doc, next, cb) {
  var e = hotplate.getModule('hotError').errors;

  if( err ){
    next( new e.RuntimeError( err ) );
  } else {
    if( ! doc ){
      next( new e.NotFoundError() );
    } else {
      cb();
    }
  }
}

exports.checkFindResponse = function( err, docs, next, cb ){
  var e = hotplate.getModule('hotError').errors;

  if(err ){
    next(new e.RuntimeError( err ) );
  } else {
    if( ! docs || docs.length == 0 ){
      next( new e.NotFoundError() );
    } else {
      cb();
    }
  }
}

exports.checkErr = function( err, doc, next, cb) {
  var e = hotplate.getModule('hotError').errors;

  if( err ){
    next( new e.RuntimeError( err ) );
  } else {
    if( ! doc ){
      next( new Error("Document empty when it really shouldn't be") );
    } else {
      cb();
    }
  }
}



exports.makeUpdateObject = function(prefix, data){

  // Make up update object
  var updateObject = {}
   for( var k in data ){
     if( k != '__v')
       updateObject[ prefix + k ] = data[k];
  }
  
  return { $set: updateObject } ;
}



exports.parametersAreMissing = function(obj, attributes, errors, next){

  var e = hotplate.getModule('hotError').errors;

  attributes.forEach(function(attribute){
    if( typeof(obj) === 'undefined' || typeof(obj[attribute]) == 'undefined'){
      errors.push( { field: attribute, message: 'Required attribute not provided: ' + attribute, mustChange: false } );
    }
  });

  if( errors.length && typeof(next) === 'function' ){
    next( new e.ValidationError( "Validation error, missing parameters", errors ) );
    return true;
  }
  return false;
}


exports.parametersAreEmpty = function(obj, attributes, errors, next){

  var e = hotplate.getModule('hotError').errors;

  attributes.forEach(function(attribute){
    if( typeof( obj[attribute] ) !== 'undefined' && obj[attribute] == '' ){
      errors.push( { field: attribute, message: 'Value cannot be empty', mustChange: false } );
    }
  });

  return exports.respondIfErrors( errors, next );

}

exports.respondIfErrors = function( errors, next ){

  var e = hotplate.getModule('hotError').errors;

  if( errors.length && typeof(next) === 'function' ) {
    next( new e.ValidationError('Validation error', errors ) );
    return true;
  }
  return false;
}


exports.enrichCursorSort = function(urlToParse, cursor, options ){

  var url_parts = url.parse( urlToParse, false );
  var q = url_parts.query || '';
  var sortBy;
  var tokens, subTokens, i;

  options = typeof( options) === 'object' ? options : {};
  options.allowedFields = typeof(options.allowedFields) === 'object' ? options.allowedFields : {};

  tokens = q.split( '&' ).forEach( function( item ) {

    var tokens = item.split('=');
    var tokenLeft = tokens[0];
    var tokenRight = tokens[1];

    // CASE 1: it's a sorting option
    // FIXME: Change make 'sortBy' configurable
    if(tokenLeft === 'sortBy'){
      sortArray = [];
      subTokens = tokenRight.split(',');
      for( i = 0; i < subTokens.length; i++ ){
        // TODO: Check if subTokens[i] is actually allowed as criteria
        if(subTokens[i].match(/[\+\-][a-zA-Z]+/)){
          var sortDirection = subTokens[i][0] == '+' ? 1 : -1;
          sortBy = subTokens[ i ].replace( '+', '' ).replace( '-', '' );
          sortArray.push( [ sortBy, sortDirection ] );
        }
      }
      // Add sorting to the cursor
      if( sortArray.count ){
        cursor.sort(sortArray);
      }
    }
  });
}

exports.enrichCursorRange = function( req, res, cursor, options, cb ){

  var tokens, i;

  options = typeof( options) === 'object' ? options : {};

  // If there was a range request, then set the range to the
  // query and return the count
  var hr;
  if( (hr = req.headers['range']) && ( tokens = hr.match(/items=([0-9]+)\-([0-9]+)$/))  ){
    rangeFrom = tokens[1];
    rangeTo = tokens[2];

    console.log("Requested range from client: " + rangeFrom + '-' + rangeTo );

    cursor.skip( rangeFrom - 0 );
    cursor.limit( rangeTo - rangeFrom + 1);
    console.log("Limiting to " + ( rangeTo - rangeFrom + 1 ) );

    cursor.count( function( err, total ) {
      if( err ){
        cb( err );
      } else {

        res.setHeader('Content-Range', 'items ' + rangeFrom + '-' + rangeTo + '/' + total );
        console.log("Setting header: " + 'items ' + rangeFrom + '-' + rangeTo + '/' + total );
        cb( null );
      }
    });
  } else {
    cb( null );
  }

}



exports.enrichSelector = function( urlToParse, selector, options ){

  var url_parts = url.parse( urlToParse, false );
  var q = url_parts.query || '';
  var tokens, i;
  var tmp;
  var selectorArray = [];

  options = typeof( options) === 'object' ? options : {};
  options.partial = typeof(options.partial) === 'object' ? options.partial : {};

  tokens = q.split( '&' ).forEach( function( item ) {

    var tokens = item.split('=');
    var tokenLeft  = tokens[0];
    var tokenRight = tokens[1];


    if(tokenLeft != 'sortBy' && tokenLeft.match(/[a-zA-Z]+/)){

      tmp = {}
      if( options.partial[ tokenLeft ]){
        tmp[ tokenLeft ] = { $regex: new RegExp('^' + tokenRight + '.*' ) };
      } else {
        // If it is a number, interprets it as a number. This is a bit of guesswork,
        // I think it will be best to have an option to cast values from strings
        if( ! isNaN(tokenRight) ) tokenRight = tokenRight - 0;
        tmp[ tokenLeft ] = tokenRight;
      }
      selectorArray.push( tmp );
    }

  });

  if( selectorArray.length ){
    if( options.operator === 'or'){
      selector['$or'] = selectorArray;
    } else {
      selector['$and'] = selectorArray;
    }
  }




}



/*

// UNUSED
function makeValidationErrorFromMongoose(err, prefix, message){

  var errors = [];
  var e = hotplate.getModule('hotError').errors; 

  for( var y in err.errors ){
    var yy = y.replace(prefix, '');
    errors.push( { field: yy, message:err.errors[y].type } );
  }
  return new e.ValidationError(message, errors) ;
}
*/


