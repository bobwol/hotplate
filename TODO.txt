
+++ THE LOGIN (10 days)

  "THE WORKSPACES"
- * C/S   : * The app URL must always have /workspacename at the end
            * When loading app, the workspace name is set as a global variable just like loginValue (workspaceIdValue)
            * Change JsonRest call in client so that it automatically appends workspaceIdValue as workspaceId. Every call to the server 
              will have to have either tokenId or workspaceId, always
            * On the server side, a middleware will set req.application.workspaceId and req.application.userId:
              - If there is tokenId with the request, the values will be based on the token's value
              - If there is just workspaceId with the request, the values will be based on the session's login and the workspace's id
              If the middleware finds that the user is not logged in, needs to return the right 4xx error. If the middleware finds out
              that the user IS logged in, but doesn't actually have access to that specific workspace, it needs to return a different
              error (and at that point the client needs to redirect to /login immediately)
            * Change existing calls (the ones that expect a login) so that they use the new middleware value, except the 'Anon" ones
            * Check whether we want the user id in the session too (most likely, since all real calls will use it). Check the whole
              "are we using workspace/login names or workspace/login IDs
            
- * C/S   : Make sure that the workspace name can be appended to the login screen, and that users are automatically redirected there if
            login has worked and user has access to it
- * C/S   : Change login screen so that if you login and have only one workspace, redirects there; if you have several workspaces, don't
            redirect: pull out a list of workspaces instead, and let user pick (open them in a new window)

  * C/S   : Think of something if there is NO workspace available (possible). Where is the user directed? Possibly to the "user config"
            widget which they would normally access from the top in the normal application? Yes, make an empty one

  "THE LAST TOUCHES"

  * SERVER: Make sure that all servers calls don't BOMB if parameters are not passed.
  * SERVER: Set an expiration time to the login, check that it can be "since last communication"
  * CLIENT: Fix problem where field with focus lose manually added tooltip straight away. It's making "wrong password" disappear.
  * C/S   : Encrypt passwords
  * CLIENT: Check for "styles" in templates, and "height", make sure that widgets don't have useless parameters


+++ MESSAGES
  * SERVER: Write messages infrastructure, where app can send messages (email, sms) and then a queue manager sends them recording the
            status
  * SERVER: Write the password recovery script: work out accounts linked, sets a hash for each one, sends email out with a change password
            link and a list of workspaces attached. NOTE: the change password link should be a simple form, which then redirects to /login
            which in turns should output the list of workspaces (since the user is already logged in)
  * C/S   : Write an "invite user" mechanism where users can be invited into the system (they receive an email, will redirect to a screen
            which allows them to register a new user (if available, etc.) or link the workspace to their existing user. Good chance to
            write a bit of a wizard.

+++ BROWSING DATA
  * SERVER: Create generic functions to parse the query launched by JsonRest queries (filter, range)
  * CLIENT: Show a bunch of records (grid, etc.) using the data stores. Make sure there is proper error recovery with
          reload if there are network issues. 

+++ SETTINGS
  * Write basic "User settings" screen where people can update their info (Name, Photo, others). This will possibly be what comes out
    if a user logs in without ANY workspaces
  * Write basic "settings" screen with sub-tabs where people can set things for their workspace. Decide on a few, generic, basic settings
  * Write a widget that allows users to create line-records and edit them (account types, booking types, and so on)

                          -------------------------
                          !! YOU ARE NOW ALL SET !!
                          -------------------------

  * Add customer form
  * Browse customers widget
  * See messages widget
  * Ability to send messages (email and SMS) depending on configured/existing subsystems
  * Ability to create bookings
  * Ability to send invoices AND store invoices
  * Basic accounting
  * First version finished

  DONE:
  * Password1 and password2, fields, make dependent on each other
  * Understand, fully, the whole "events" on widgets and DOM nodes http://livedocs.dojotoolkit.org/quickstart/events
  * Add a busybutton -- Look into dojox/widgets/standby and forms/busybutton
  * Check things with server, make sure server can respond with form setting error messages
  * Understand _fully_ the whole promise thing in Dojo
  * Write functions for server (sending errors) to keep things dry
  * Initial data saving with MongoDB
  * Write async code to save everything, MAYBE using Async library https://github.com/caolan/async#series (niiice!)
  * Actually create account/workspace with MongoDB
  * CLIENT: Fix forms, as it turns out we don't really need labels (not possible, I was dreaming)
  * Validation/error manager framework:
  -- Change client so that it shows which fields had what problem from the server adding validators on the fly
  -- CLIENT: Add a xhr function for client (making request, writing a message) to keep things dry. Do it with promises and new Form
  -- CLIENT: Make sure that the busybutton itself cancels itself if the form doesn't validate _somehow_
  -- CLIENT: Finish the new warning bar!
  -- CLIENT: Make error printing MUCH nicer than a bloody alert() using the new great bar!
  -- CLIENT: Simplify IFs so that it only needs to cancel if it didn't validate, and do anything if it worked OK. Errors
             and messages handled by generic function 
  -- C/S   : Complete the validation server-side and client-size properly (use the same validators as client side!)
  --SERVER: Make up log library to log ANYTHING with Workspace as a key (not just errors). Log ALL activity
  --CLIENT: Enable logging of all activity with Console.log (to be turned on, so wrap console.log in function)
    +++ THE INTERACTION GALORE (2 days)
  --CLIENT: Create initial models on the client side for Mongo's data ('workspace')
  --CLIENT: Write more models for future use/reference (won't work until implemented on server)
    CLIENT: Change COMPLETELY the logic for forms. Make stores "NewWorkspaces" and "NewWorkspacesAsUser" 
  --SERVER: Write function part on server for workspace and username checking (store: "Workspaces" which only works with the
            right filter).
  --CLIENT: Actually check workspace names and user names using AJAX on the client side (don't allow submit if duplicate)
  * SERVER: Reinstall Express, work out what's in the "-s" field (see differences with and without) AND check that app still runs
  * SERVER: Have a look at the middleware used to refresh your memory a little
  * SERVER: Configure a store with Mongodb
  * SERVER: Get familiar with sessions
  * C/S   : Set "logged in variable" when login is successful (store password unencrypted for now)
  * CLIENT: Slim up the submit function, avoid ANY code repetition that is not 100% strictly necessary
  * CLIENT: Write a basic empty applicationwith a simple button to interact with server
  * C/S   : Restructure the whole directory tree so that it makes a lot more sense and can use Dojo 1.8 as a library
  * C/S   : Add logout button to the app and to the server and to the application (make widget), so that we can test things out
  * C/S   : Change app so that if a request is made and response is "unauthorised", asks for login 3 times and after that redirects to login
  * CLIENT: Make sure logging in will _actually_ direct to the app
  * CLIENT: Decide how to store the login name client-side, get client to re-send it
  * C/S   : Change app so that if you are not logged in it will send TO login screen (redirect straight from the jade page)
  * CLIENT: Change login form so that if the user is already set, it will not ask for it again (and option to change user)
  * SERVER: Put the login/logout/register pages (non-data ones) in a separate module
  * C/S   : Add a proper button that does something to test the "session expires" thing to test things properly
  * C/S   : Change the "register" page so that if you are logged in, it redirects to the login page
  * C/S   : Change register form so that if user is already logged in it only asks for the workspace name
- * C/S   : In case user already is logged in, register form should have an info box and explain that they are already logged in and
            the workspace will be registered under their username, providing a logout link too.
  * CLIENT: In case user is not logged in, warn users that if they already are customers, they should login so that
            the workspace will fall under their existing username (with link to a login page)
