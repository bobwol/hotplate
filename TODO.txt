
  "MODULARISATION" (ACTUAL TODO)

   * Port the Dojo widgets "as they are", make application work "as is"
   ROUTES:
     * Add function to add per-module routes
     * Add functions to hotplate.use() routes allowing definition of stores at the same time (add stores use existing function)


   * Move the "auth" side of the story into core in the sanest possible way for hotplate
     * Add function to add per-module routes that only work on authentication with session or API token
   * Check that coreAuth can be used for other systems (like passport, for example)
   * Add function to log to console if turned on (add it to logger), put log messages using that from now on
   * Comment each function, client and server, decide on a standard (probably node's)

   "VANITY"

   * Add counter again: cat `find . -type f | grep -v \.git | grep -v \.sw ` | wc

  "PERMISSIONS"

  * Before starting, check how feasible it is to create hook-driven "gets" and "sets" so that the application
    can query *every* available module for a determined list (roles? defined widgets?). How could this work, staying
    simple and generic? Could this work both for roles, and for widget registration and location?

  * Write a permission system Ways to go about this:
     - Hook to define roles (each module can define some)
     - Hooks to define permission lists for each module
     - Hooks to return, for each role, an associative array of module-defined permissions to which the role has access AND
       function to return all module-defined permissions for a specified role. NOTE: initially, this could well be a static
       module, which will define both roles and module-defined permissions for that role. However, hopefully in the future there
       might well be a user interface to do that too
     - Export the permission matrix to Javascript (for that particular user). Permissions are basically another variable (like "stores"
       and "vars"). It's up to the framework to use it. Since this is _very_ widget-agnostic, ideally there will be a javascript
       function defined which will return permissions on the client-side (no widgets etc.). THIS MIGHT WELL MEAN that I will need
       a widget-agnostic topic/subscription system similar to what I did for the server.

  "DOJO HOOKS"

  * Write a topic/publish system, client side, where clients can change other client's forms, templates etc. before they get
    sent to the client. For example, another mixin to _templatedMixin which calls hotplate's hooks?

  "LAST TOUCHES"

  * C/S   : Make sure that workspace names are registered as lowercase, AND that searching them is case insensitive!
  * SERVER: Make sure that all servers calls don't BOMB if parameters are not passed (use custom function)
  * SERVER: Set an expiration time to the login, check that it can be "since last communication"
  * CLIENT: Fix problem where field with focus lose manually added tooltip straight away. It's making "wrong password" disappear.
  * C/S   : Encrypt passwords (!)
  * CLIENT: Check for "styles" in templates, and "height", make sure that widgets don't have useless parameters

  "BROWSING DATA + LOGS"

  * SERVER: Create generic functions to parse the query launched by JsonRest queries (filter, range) use it for invites sent
  * CLIENT: Show a bunch of records (grid, etc.) using the data stores. Make sure there is proper error recovery with
            reload if there are network issues. 
  * SERVER: Write a query adding _perms to the results: _perms is an object where the keys 'get', 'put', 'post' may be defined. This
            is so that clients know what they can and cannot do on results.
  * SERVER: Write a "Dashboard" page for the "system" workspace, with a tab that displays logs (filter by time, user, workspace, gravity)
            Improve logging accordingly

  "SETTINGS" (module)

  * Think about for a moment if we need a good way to allow modules to have "settings". Probably not, as this could well become
    _extremely_ complicated if we are to keep database and widget agnostic. -- UPDATE: It doesn't have to be agnostic at all
  * Write basic "User settings" screen where people can update their info (Name, Photo, others).
  * Add a link to the user profile in the workspace picker if a user logs in without ANY workspaces
  * Write basic "settings" screen with sub-tabs where people can set things for their workspace. Decide on a few, generic, basic settings
  * Write a widget that allows users to create line-records and edit them (account types, booking types, and so on)
  * CLIENT: Make app look a little nicer (login button, small avatar, at the top, etc.)

  "A WORKING USE CASE" (module)

  * Add a "customer" form, and a customers browser. In order to test the system, also add the ability to have
    "private" customers

  "MESSAGES AND INVITES" (module)

  * SERVER: Write messages infrastructure, where app can send messages (email, sms) and then a queue manager sends them recording the
            status
  * CLIENT: Write configuration for messenging infrastructure. Each subsystem can be able to send, receive or both. 
  * SERVER: Write the password recovery script: work out accounts linked, sets a hash for each one, sends email out with a change password
            link and a list of workspaces attached. NOTE: the change password link should be a simple form, which then redirects to /login
            which in turns should output the list of workspaces (since the user is already logged in)
  * C/S   : Write an "invite user" mechanism where users can be invited into the system (they receive an email, will redirect to a screen
            which allows them to register a new user (if available, etc.) or link the workspace to their existing user. Good chance to
            write a bit of a wizard.
  * CLIENT: Write a "message browser" system for the workspace admin so that they can see exactly what was sent, when, and see the logs

                          ----------------------------
                          !!  HOTPLATE IS FINISHED  !!
                          ----------------------------

  The following is the short TODO list for my own booking system, which is what I was meant to start from day 1 (and was "slightly"
  side tracked by writing a "boilerplate"... err...)

  * Add messages *receiving* infrastructure (smtp mx, pop, sms), with configuration and setting of default for receiving email
  * "View messages" widget under customers with ability to send messages using one of the subsystems
  * Inbox: ability to see the inbox, and match a "from" to a contact (note: maybe make this "soft": contacts have several email addresses,
    and viewing messages will include seeing email from and to any one of their email addresses)
  * Ability to create bookings
  * Ability to match incoming (and outgoing) messages to bookings
  * Ability to send invoices and _store_ received invoices
  * Ability to set templates for messages of different types
  * Basic accounting

  DONE:
  * Password1 and password2, fields, make dependent on each other
  * Understand, fully, the whole "events" on widgets and DOM nodes http://livedocs.dojotoolkit.org/quickstart/events
  * Add a busybutton -- Look into dojox/widgets/standby and forms/busybutton
  * Check things with server, make sure server can respond with form setting error messages
  * Understand _fully_ the whole promise thing in Dojo
  * Write functions for server (sending errors) to keep things dry
  * Initial data saving with MongoDB
  * Write async code to save everything, MAYBE using Async library https://github.com/caolan/async#series (niiice!)
  * Actually create account/workspace with MongoDB
  * CLIENT: Fix forms, as it turns out we don't really need labels (not possible, I was dreaming)
  * Validation/error manager framework:
  -- Change client so that it shows which fields had what problem from the server adding validators on the fly
  -- CLIENT: Add a xhr function for client (making request, writing a message) to keep things dry. Do it with promises and new Form
  -- CLIENT: Make sure that the busybutton itself cancels itself if the form doesn't validate _somehow_
  -- CLIENT: Finish the new warning bar!
  -- CLIENT: Make error printing MUCH nicer than a bloody alert() using the new great bar!
  -- CLIENT: Simplify IFs so that it only needs to cancel if it didn't validate, and do anything if it worked OK. Errors
             and messages handled by generic function 
  -- C/S   : Complete the validation server-side and client-size properly (use the same validators as client side!)
  --SERVER: Make up log library to log ANYTHING with Workspace as a key (not just errors). Log ALL activity
  --CLIENT: Enable logging of all activity with Console.log (to be turned on, so wrap console.log in function)
    +++ THE INTERACTION GALORE (2 days)
  --CLIENT: Create initial models on the client side for Mongo's data ('workspace')
  --CLIENT: Write more models for future use/reference (won't work until implemented on server)
    CLIENT: Change COMPLETELY the logic for forms. Make stores "NewWorkspaces" and "NewWorkspacesAsUser" 
  --SERVER: Write function part on server for workspace and username checking (store: "Workspaces" which only works with the
            right filter).
  --CLIENT: Actually check workspace names and user names using AJAX on the client side (don't allow submit if duplicate)
  * SERVER: Reinstall Express, work out what's in the "-s" field (see differences with and without) AND check that app still runs
  * SERVER: Have a look at the middleware used to refresh your memory a little
  * SERVER: Configure a store with Mongodb
  * SERVER: Get familiar with sessions
  * C/S   : Set "logged in variable" when login is successful (store password unencrypted for now)
  * CLIENT: Slim up the submit function, avoid ANY code repetition that is not 100% strictly necessary
  * CLIENT: Write a basic empty applicationwith a simple button to interact with server
  * C/S   : Restructure the whole directory tree so that it makes a lot more sense and can use Dojo 1.8 as a library
  * C/S   : Add logout button to the app and to the server and to the application (make widget), so that we can test things out
  * C/S   : Change app so that if a request is made and response is "unauthorised", asks for login 3 times and after that redirects to login
  * CLIENT: Make sure logging in will _actually_ direct to the app
  * CLIENT: Decide how to store the login name client-side, get client to re-send it
  * C/S   : Change app so that if you are not logged in it will send TO login screen (redirect straight from the jade page)
  * CLIENT: Change login form so that if the user is already set, it will not ask for it again (and option to change user)
  * SERVER: Put the login/logout/register pages (non-data ones) in a separate module
  * C/S   : Add a proper button that does something to test the "session expires" thing to test things properly
  * C/S   : Change the "register" page so that if you are logged in, it redirects to the login page
  * C/S   : Change register form so that if user is already logged in it only asks for the workspace name
- * C/S   : In case user already is logged in, register form should have an info box and explain that they are already logged in and
            the workspace will be registered under their username, providing a logout link too.
  * CLIENT: In case user is not logged in, warn users that if they already are customers, they should login so that
            the workspace will fall under their existing username (with link to a login page)
            * The app URL must always have /workspacename at the end
  * C/S     Do things so that the workspace ID is part of the URL, and not the workspace name, so that URLs stay forever even
            if workspace name changes
  * C/S     Make sure that the workspace name can be appended to the login screen, and that users are automatically redirected there if
            login has worked and user has access to it. To do this, get the login screen to be there with workspaceId set as a variable
            if present, and get the login routine to check if that is available.
  * C/S     Change login screen so that if you login and have only one workspace, redirects there; if you have several workspaces, don't
            redirect: pull out a list of workspaces instead, and let user pick (open them in a new window)
  * CLIENT: Make LoginForm functional, needs to find out the workspace to redirect to from the URL bar using a path
  * SERVER: Finish (write) the picker
  * CLIENT: Add roundForm classes to CSS so that notFound and "error" don't have the loginForm class (silly)
  * CLIENT: Make picker way prettier, 
  * SERVER: Fix problem where if user is logged in, and creates a workspace, he is not added to the permissions (DB changed)
  * SERVER: Change req.XXXX set by workspaceName and workspaceId tokens so that they are under "app", to keep namespace clean
            grep 'req\.[^sbqu]' `find .` Note: change workspaceId's parameter string into workspaceIdPages 
  * SERVER: Tidy up code for middleware, put it in a different file.
  * SERVER: Get TOKENS (rename "key" in db and code) actually created when a user is added.
  * SERVER: Set the token as a global variable in the ws page. The key is worked out by User (from Session) + Workspace id (from page)
  * CLIENT: Change JsonRest call in client so that it automatically appends, to call URL, the key from the global variable
  * C/S   : Revise all code, make sure that names of stores are consistent, place pages under /pages/login, pages/register etc,
            change the store names
  * C/S   : On the server side, a middleware will read the token from URL and set req.application.workspaceId and req.application.userId:
            If the middleware finds that the user is not logged in, needs to return the right 4xx error.
  * SERVER: Check that middleware tokenApi actually works (check by getting Javascript to provide the wrong API key).
  * CLIENT: Hide passwords
  * SERVER: Rename error objects so that make more sense, _and_ make sure that original error is kept in case of "Runtime error".
  * SERVER: Improve the Log() function so that IT does all the work (lookup etc.) and stores things right
  * C/S   : Since 403 is for "user is not logged in", return a different error in case the user IS logged in but has no access to
            the url requested. (It shouldn't happen, and it will only really happen when a permission change happens while the
            user is using the application).
  * SERVER: Find a _good_ way to keep the original error when throwing messages in db errors, maybe providing info to the user? Check
            logging too -- check that logging is happening properly (sent email to stack overflow)
  * SERVER: Uniform the way things are set, into req.application, regardless of what middleware is called
            
  * SERVER: Check logging, and Check that things haven't bombed after latest extensive changes, and that logging still happens OK.
  * C/S   : Revise "protocol", make it a lot better and nicer so that the response is always, always the same (and extra "things" can
            be sent to the app in terms of what to refresh, for example). MAKE SURE THAT IT'S ALWAYS THE SAME FORMAT FOR EVERY ERROR
  * CLIENT: Fix password so that it's not "mustChange" in login form (user might decide to change username and not password)
  * SERVER: Change the login scheme completely. The client mustn't send the token for each call, but simply "session" (as an option). On
            the server, the "session" needs to go by workspace. So, when token is "session", setting of variables will depend on
            the session rather than the passed token. (the "login" request makes sense)
  * SERVER: Make a middleware that requires the person to be logged in  (silly idea)
  * SERVER: Understand how the error management works, discovered that throw(err) is the very same as next(err) for the catch{} there
  * SERVER: Change page middleware so that it redirects automatically, without getting the actual routes methods to do it
  * SERVER: Write a middleware for the ID
  * SERVER: Implement logging in case of server problems when delivering pages (add logging calls manually where needed?)
  * SERVER: [NOT DONE] Write a function to check if a user has access to a specific workspace, use that instead of current find() in 3 spots
  * SERVER: Fixed IDIOTIC way I used to give access to workspaces, based on used name rather than ids.
  * SERVER: Major, major reorganisation of the code, errors are now in their own little files, etc.
  * Fixed order of things, so that it makes more sense. This framework is bigger than I expected, will I ever get to write
    the _actual_ booking system I wanted to write? I am amazed something like this didn't exist already
  * SERVER: Made sessions persistent using connect-mongod, fixed a silly bug in the creation of the stores client-side (left from testing)
  * SERVER: Added the first query call
  * CLIENT: Improved the code in _AjaxValidatorMixin.js so that it can work both if search is good or not, improved that code in the meantime
  * Write a module loader which will load all modules in a specific directory and run init(), as well as create a list of
    loaded modules
  * Move the existing calls into a module called "system"
  * Create system so that modules have a public directory
  * Make sure that the application runs some init() method javascript-side as well, so that modules can add their widgets to the app
  * Empty root directory completely (including errors.js etc.), turn it into a straight Express server with modules
  * Write a hook system, server and client side, where other modules can listen and "enrich" each other's objects, forms, etc.
  * Write a topic/publish system, server side, where things can happen
  * Add function to add fields that will be logged by the logger, defining them as "indexes" or not. (This will be used to
    make up the schema on the spot by the mongologger)
   * Add ability to register a module later (change the load function so that it calls register, and then
     make sure that the template is recalculated after the registration for that particular module so that
     JS and CSSes are added). Also, see if it's possible to make file loading work as well (!), this will require
     one middleware call per module). This way, people can use *any* module to integrate with hotplate -- the modules will
     just need to provide the right hooks
   * Put core modules into a "core" directory somehow (revise the way modules are loaded, allow two stage loading and THEN init() )
  * Write dependency system so that init() methods are called in the right order
