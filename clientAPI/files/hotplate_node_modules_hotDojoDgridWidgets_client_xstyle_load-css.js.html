<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>hotplate/node_modules/hotDojoDgridWidgets/client/xstyle/load-css.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g-DELETED header-DELETED">
        <div class="yui3-u-3-4-DELETED">



 <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mercmobily/hotplate">View on GitHub</a>

          <h1 id="project_title">Hotplate -- documentation</h1>
          <h2 id="project_tagline">Multi-homed SaaS with NodeJs, Express, (any)DB, Dojo</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/mercmobily/hotplate/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/mercmobily/hotplate/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>



           <!-- 
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
            -->

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: hotplate/node_modules/hotDojoDgridWidgets/client/xstyle/load-css.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * This includes code from https://github.com/unscriptable/cssx
 * Copyright (c) 2010 unscriptable.com
 */

/*jslint browser:true, on:true, sub:true */

define([], function(){
&quot;use strict&quot;;

/*
 * AMD css! plugin
 * This plugin will load and wait for css files.  This could be handy when
 * loading css files as part of a layer or as a way to apply a run-time theme.
 * Most browsers do not support the load event handler of the link element.
 * Therefore, we have to use other means to detect when a css file loads.
 * (The HTML5 spec states that the LINK element should have a load event, but
 * not even Chrome 8 or FF4b7 have it, yet.
 * http://www.w3.org/TR/html5/semantics.html#the-link-element)
 *
 * This plugin tries to use the load event and a universal work-around when
 * it is invoked the first time.  If the load event works, it is used on
 * every successive load.  Therefore, browsers that support the load event will
 * just work (i.e. no need for hacks!).  FYI, Feature-detecting the load
 * event is tricky since most browsers have a non-functional onload property.
 *
 * The universal work-around watches a stylesheet until its rules are
 * available (not null or undefined).  There are nuances, of course, between
 * the various browsers.  The isLinkReady function accounts for these.
 *
 * Note: it appears that all browsers load @import&#x27;ed stylesheets before
 * fully processing the rest of the importing stylesheet. Therefore, we
 * don&#x27;t need to find and wait for any @import rules explicitly.
 *
 * Note #2: for Opera compatibility, stylesheets must have at least one rule.
 * AFAIK, there&#x27;s no way to tell the difference between an empty sheet and
 * one that isn&#x27;t finished loading in Opera (XD or same-domain).
 *
 * Options:
 *      !nowait - does not wait for the stylesheet to be parsed, just loads it
 *
 * Global configuration options:
 *
 * cssDeferLoad: Boolean. You can also instruct this plugin to not wait
 * for css resources. They&#x27;ll get loaded asap, but other code won&#x27;t wait
 * for them. This is just like using the !nowait option on every css file.
 *
 * cssWatchPeriod: if direct load-detection techniques fail, this option
 * determines the msec to wait between brute-force checks for rules. The
 * default is 50 msec.
 *
 * You may specify an alternate file extension:
 *      require(&#x27;css!myproj/component.less&#x27;) // --&gt; myproj/component.less
 *      require(&#x27;css!myproj/component.scss&#x27;) // --&gt; myproj/component.scss
 *
 * When using alternative file extensions, be sure to serve the files from
 * the server with the correct mime type (text/css) or some browsers won&#x27;t
 * parse them, causing an error in the plugin.
 *
 * usage:
 *      require([&#x27;css!myproj/comp&#x27;]); // load and wait for myproj/comp.css
 *      define([&#x27;css!some/folder/file&#x27;], {}); // wait for some/folder/file.css
 *      require([&#x27;css!myWidget!nowait&#x27;]);
 *
 * Tested in:
 *      Firefox 1.5, 2.0, 3.0, 3.5, 3.6, and 4.0b6
 *      Safari 3.0.4, 3.2.1, 5.0
 *      Chrome 7 (8+ is partly b0rked)
 *      Opera 9.52, 10.63, and Opera 11.00
 *      IE 6, 7, and 8
 *      Netscape 7.2 (WTF? SRSLY!)
 * Does not work in Safari 2.x :(
 * In Chrome 8+, there&#x27;s no way to wait for cross-domain (XD) stylesheets.
 * See comments in the code below.
 * TODO: figure out how to be forward-compatible when browsers support HTML5&#x27;s
 *  load handler without breaking IE and Opera
*/


	var
		// compressibility shortcuts
		onreadystatechange = &#x27;onreadystatechange&#x27;,
		onload = &#x27;onload&#x27;,
		createElement = &#x27;createElement&#x27;,
		// failed is true if RequireJS threw an exception
		failed = false,
		doc = document,
		cache = typeof _css_cache == &quot;undefined&quot; ? {} : _css_cache,
		undef,
		features = {
			&quot;event-link-onload&quot;: document.createElement(&quot;link&quot;).onload === null &amp;&amp;
				// safari lies about the onload event
				!navigator.userAgent.match(/AppleWebKit/),
			&quot;dom-create-style-element&quot;: !document.createStyleSheet
		},
		// find the head element and set it to it&#x27;s standard property if nec.
		head = doc.head || (doc.head = doc.getElementsByTagName(&#x27;head&#x27;)[0]);

	function has (feature) {
		return features[feature];
	}
	function createLink (doc, optHref) {
		var link = doc[createElement](&#x27;link&#x27;);
		link.rel = &quot;stylesheet&quot;;
		link.type = &quot;text/css&quot;;
		if (optHref) {
			link.href = optHref;
		}
		return link;
	}
	function nameWithExt (name, defaultExt) {
		return name.lastIndexOf(&#x27;.&#x27;) &lt;= name.lastIndexOf(&#x27;/&#x27;) ?
			name + &#x27;.&#x27; + defaultExt : name;
	}
	function parseSuffixes (name) {
		// creates a dual-structure: both an array and a hashmap
		// suffixes[0] is the actual name
		var parts = name.split(&#x27;!&#x27;),
			suf, i = 1, pair;
		while ((suf = parts[i++])) { // double-parens to avoid jslint griping
			pair = suf.split(&#x27;=&#x27;, 2);
			parts[pair[0]] = pair.length == 2 ? pair[1] : true;
		}
		return parts;
	}
		

	if(!has(&quot;bundled-css&quot;)){ // if all the CSS is bundled, we don&#x27;t need to the loader code
		var loadDetector = function(params, cb){ 
			// failure detection
			// we need to watch for onError when using RequireJS so we can shut off
			// our setTimeouts when it encounters an error.
			if (require.onError) {
				require.onError = (function (orig) {
					return function () {
						failed = true;
						orig.apply(this, arguments);
					}
				})(require.onError);
			}
		
			/***** load-detection functions *****/
		
			function loadHandler (params, cb) {
				// We&#x27;re using &#x27;readystatechange&#x27; because IE and Opera happily support both
				var link = params.link;
				link[onreadystatechange] = link[onload] = function () {
					if (!link.readyState || link.readyState == &#x27;complete&#x27;) {
						features[&quot;event-link-onload&quot;] = true;
						cleanup(params);
						cb();
					}
				};
			}
		
		
			function isLinkReady (link) {
				// based on http://www.yearofmoo.com/2011/03/cross-browser-stylesheet-preloading.html
				// Therefore, we need
				// to continually test beta browsers until they all support the LINK load
				// event like IE and Opera.
				// webkit&#x27;s and IE&#x27;s sheet is null until the sheet is loaded
				var sheet = link.sheet || link.styleSheet;
				if(sheet){
					var styleSheets = document.styleSheets;
					for(var i = styleSheets.length; i &gt; 0; i--){
						if(styleSheets[i-1] == sheet){
							return true;
						}
					}
				}
			}
		
			function ssWatcher (params, cb) {
				// watches a stylesheet for loading signs.
				if (isLinkReady(params.link)) {
					cleanup(params);
					cb();
				}
				else if (!failed) {
					setTimeout(function () { ssWatcher(params, cb); }, params.wait);
				}
			}
		
			function cleanup (params) {
				var link = params.link;
				link[onreadystatechange] = link[onload] = null;
			}
			// It would be nice to use onload everywhere, but the onload handler
			// only works in IE and Opera.
			// Detecting it cross-browser is completely impossible, too, since
			// THE BROWSERS ARE LIARS! DON&#x27;T TELL ME YOU HAVE AN ONLOAD PROPERTY
			// IF IT DOESN&#x27;T DO ANYTHING!
			var loaded;
			function cbOnce () {
				if (!loaded) {
					loaded = true;
					cb();
				}
			}
			loadHandler(params, cbOnce);
			if (!has(&quot;event-link-onload&quot;)) ssWatcher(params, cbOnce);
		
		};
	}
	function insertCss(css){
		if(has(&quot;dom-create-style-element&quot;)){
			// we can use standard &lt;style&gt; element creation
			styleSheet = document.createElement(&quot;style&quot;);
			styleSheet.setAttribute(&quot;type&quot;, &quot;text/css&quot;);
			styleSheet.appendChild(document.createTextNode(css));
			head.insertBefore(styleSheet, head.firstChild);
			return styleSheet;
		}
		else{
			var styleSheet = document.createStyleSheet();
			styleSheet.cssText = css;
			return styleSheet.owningElement;
		}
	}
	/***** finally! the actual plugin *****/
	return function (resourceDef, callback, config) {
				var resources = resourceDef.split(&quot;,&quot;),
					loadingCount = resources.length,

				// all detector functions must ensure that this function only gets
				// called once per stylesheet!
					loaded = 
				function () {
					// load/error handler may have executed before stylesheet is
					// fully parsed / processed in Opera, so use setTimeout.
					// Opera will process before the it next enters the event loop
					// (so 0 msec is enough time).
					if(--loadingCount == 0){
						// TODO: move this setTimeout to loadHandler
						callback(link.sheet || link.styleSheet)
						// TODO: Is this need for Opera?
						//setTimeout(onCssLoaded,0);
					}
				}

				// after will become truthy once the loop executes a second time
				for(var i = 0, after; i &lt; resources.length; i++, after = url){
					resourceDef = resources[i];
					var cached = cache[resourceDef]; 
					if(cached){
						link = insertCss(cached);
						return loaded();
					}
					var
						// TODO: this is a bit weird: find a better way to extract name?
						opts = parseSuffixes(resourceDef),
						name = opts.shift(),
						url = nameWithExt(name, &quot;css&quot;),
						link = createLink(doc),
						nowait = &#x27;nowait&#x27; in opts ? opts.nowait != &#x27;false&#x27; : !!(config &amp;&amp; config.cssDeferLoad),
						params = {
							link: link,
							url: url,
							wait: config &amp;&amp; config.cssWatchPeriod || 25
						};
					// hook up load detector(s)
					loadDetector(params, loaded);
					if (nowait) {
						callback(link);
					}

					// go!
					link.href = url;

					head.appendChild(link);
				}
			};

});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
