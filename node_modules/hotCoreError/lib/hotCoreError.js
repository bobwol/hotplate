"use strict";
/*!
 * Module dependencies.
 */

var dummy
  , hotplate = require('hotplate')

  , e = require('allhttperrors')

  , logger = require('hotCoreServerLogger')
  , sendResponse = require('hotCoreErrorProtocol').sendResponse
;

// Set some sane defaults

hotplate.config.set('hotCoreError.errorPage', function( req, res, next ){

  var errorString = "ERROR: " + req.hotError + ", NAME: " + req.hotError.name;
  var httpError = req.hotError ? req.hotError.httpError : 200;

  res.send( httpError, errorString + " -- CUSTOMISE YOUR ERROR PAGE BY SETTING hotCoreError.errorPage IN YOUR SERVER FILE" );
});


// Sets logLEvels for errors, _and_ sets some more friendly defaults in terms of messages etc.

Object.keys( e ).forEach( function( o ){

  var proto = e[ o ].prototype;

  switch( o ){
    case 'ServiceUnavailableError':
      proto.logLevel = 5;
      proto.message = "Server error";
    break;

    case 'BadRequestError':
      proto.logLevel = 2;
    break;

    case 'UnprocessableEntityError':
      proto.logLevel = 2;
      proto.message = "Validation Error";
    break;

  }
})


// exports.errors = e;

exports.hotCoreErrorHandler = function( err, req, res, next){

  var accept = req.headers.accept || '';
  var env = process.env.NODE_ENV || 'development';

  // Print the stack to console in any case
  if( env !== 'test' && err.stack ) console.error( err.stack );

  // It's not an HTTP error: make a "system" log entry for it, as this
  // should never ever happen. This entry will be on TOP of the "normal" entry
  // (which the user will be able to see)
  if( typeof( e[ err.name ] ) === 'undefined' ){
    // Log the error
    logger.log({
      logLevel     : 5,
      errorName    : err.name,
      message      : err.message,
      errors       : [],
      system       : true,
      data         : { error: err, trace: err.stack },
    });
  }

  // It's not an HTTP error: make up a new one, and incapsulate original error in it
  if( typeof( e[ err.name ] ) === 'undefined'  ){
    err = new e.ServiceUnavailableError( { originalErr: err } );
  }

  // Log the error, in 
  logger.log({
    logLevel     : err.logLevel || 3,
    errorName    : err.name,
    message      : err.message,
    errors       : err.errors || [],
    system       : false,
    data         : { error: err },
  });

  // If it was an HTML page that generated the error, return hotplate's error page
  if( ~accept.indexOf('html') ){
    req.hotError = err; // FIXME
    hotplate.config.get('hotCoreError.errorPage')(req, res, next);    

  // If it was a JSON request, do a sendResponse following the protocol
  } else if (~accept.indexOf('json') || ~accept.indexOf('*/*') ) {
    sendResponse( res, { message: err.message, errors: err.errors }, err.httpError );

  // Otherwise, just print the output out...
  } else {
    res.writeHead(err.httpError, { 'Content-Type': 'text/plain' });
    res.end( err.message );
  }  
  
}



