var dummy
  , hotplate = require('hotplate')

  , e = require('allhttperrors')

  , Schema = require('simpleschema')
  , MongoSchemaMixin = require('simpleschema/MongoSchemaMixin.js')

  , Store = require('jsonreststores')
  , MongoDriverMixin = require('jsonreststores/MongoDriverMixin.js')

  , declare = require('simpledeclare')
;


// Define store and mongo drivers.

var app = hotplate.app;

var hooks = exports.hotHooks = {}

var TABLIFESPAN = 16000;
var CLEANUPINTERVAL = 2000;


hooks.init = function( done ){

  var hotCoreJsonRestStores = hotplate.getModule( 'hotCoreJsonRestStores' );
  var hotCoreStoreConfig = hotplate.getModule( 'hotCoreStoreConfig' );
  var hotCoreMultiHome = hotplate.getModule( 'hotCoreMultiHome' );

  var PermStore = declare( [ Store, MongoDriverMixin ],   { db: hotplate.get('db') } );
  var PermSchema = declare( [ Schema, MongoSchemaMixin ], { db: hotplate.get('db') } );


  // Clean up Tabs collection every 30 seconds, so that
  // dead tabs are gotten rid of
  var cleaningUp = false;
  setInterval( function(){
    if( cleaningUp ) return;
    cleaningUp = true;
    
    Tabs.MassDelete( { filters: { toLastSync: new Date() - TABLIFESPAN } }, function ( err ){
      //TODO: Log error
      TabMessages.MassDelete( { filters: { toAdded: new Date() - TABLIFESPAN } }, function ( err ){
        // TODO: Log error
        cleaningUp = false;
      });
    });
 
  }, CLEANUPINTERVAL );


  // ***********************************
  // *** OPEN TABS   *******************
  // ***********************************

  var Tabs = exports.Tabs = declare( PermStore, {

    schema: new PermSchema({
      tabId:         { type: 'id' },
      userId:        { type: 'id' },
      lastSync:      { type: 'date', required: true, default: function(){ return new Date() } },
    }),

    searchSchema: new PermSchema({
      tabId:         { type: 'id' },
      userId:        { type: 'id' },
      lastSync:      { type: 'date' },

      // Ordering filters
      fromLastSync:  { type: 'date', filterType: { type: 'range', direction: 'from', field: 'lastSync' } },
      toLastSync:    { type: 'date', filterType: { type: 'range', direction: 'to', field: 'lastSync' }  },
    }),

    handlePost: true,
    handleDelete: true,

    storeName:  'tabs',
    paramIds: [ 'tabId' ],

    publicURL: '/tabs/',

    // TODO: Maybe I need an extra hook, this is not quite about permissions...
    checkPermissionsPost: function( params, body, options, cb ){
      var self = this;

      // It's a local request: always work, set null to userId
      if( ! self.remote) {
        body.userId = null;
        cb( null, true );

      // It's a remote request: fail if not logged in
      } else {
        if( ! self._req.session.userId ){
          cb( null, false );
        } else {
          body.userId = self._req.session.userId;
          cb( null, true );
        }
      }
    },
   
    // Delete ALL entries in TabMessages when a tab gets deleted
    afterDelete: function( params, body, options, doc, fullDoc, cb ){
      TabMessages.MassDelete( { filters: { tabId: body.tabId } }, function( err ) {
        // TODO: Log err
      }  );
      cb( null );
    },

  });

  var TabMessages = exports.TabMessages = declare( PermStore, {

    // COMMON
    schema: new PermSchema({
      messageId:     { type: 'id' },
      tabId:         { type: 'id' },
      fromUserId:    { type: 'id' },
      message:       { type: 'serialize' },
      added:         { type: 'date', required: true, default: function() { return new Date() } },
    }),

    // COMMON
    searchSchema: new PermSchema({
      messageId:     { type: 'id' },
      tabId:         { type: 'id' },
      fromUserId:    { type: 'id' },
      message:       { type: 'serialize' },
      added:         { type: 'date' },

      fromAdded:     { type: 'date', filterType: { type: 'range', direction: 'from', field: 'added' }  },
      toAdded:       { type: 'date', filterType: { type: 'range', direction: 'to', field: 'added' }  },
    }),

    storeName:  'tabMessages',
    paramIds: [ 'tabId', 'messageId' ],
    killComet: true,
  });

  
  // PSEUDO-STORE, sends an object out with all of the messages
  // It will return an array of unserialised messages in TabMessages for
  // a specific tabId, and then it will DELETE those messages
  var TabMessageDispatcher = exports.TabMessageDispatcher = declare( Store, {

    // COMMON
    schema: new PermSchema({
      tabId:         { type: 'string' },
      messages:      { type: 'none' },
    }),

    handleGet: true,

    handlePut: false,
    handlePost: false,
    handleGetQuery: false,
    handleDelete: false,
 
    storeName:  'tabMessageDispatcher',

    paramIds: [ 'tabId' ],

    publicURL: '/tabs/dispatcher/',

    killComet: true,

    // Check that the remote user requesting the tab is indeed the tab's owner
    checkPermissionsGet: function( params, body, options, doc, fullDoc, done ){
      
      var self = this;

      // User needs to be logged in
      if( ! self._req.session.userId ) return done( null, false );

      // TODO: Optimise a little here. Since checkPermissionsGet is called before driverAllDbFetch,
      // try and cache this result
      exports.Tabs.GetQuery( { filters: { fromLastSync: new Date() - TABLIFESPAN, tabId: params.tabId } }, function( err, tab ){
        if( err ){
          done( err );
        } else {

          // This may seem strange, but always pass authentication if the tab is not
          // there, as the store will need to accept the get and return the "storeReset"
          // message after returning the new tab
          if( tab.length == 0 ){
             done( null, true );

          } else {
            tab = tab[0];
            done( null, tab.userId.toString() === self._req.session.userId );
          }
        }
      });

 
    },

    driverAllDbFetch: function( params, body, options, done ){

      var messages = [];
      var self = this;

      // If it's not a remote call, always return empty result
      if( ! self.remote ) return done( null, { messages: [] } );

      var headersWorkspaceId = self._req.headers[ 'x-hotplate-workspaceid' ];

      // Return all messages for that tab, REMOVING after fetching
      exports.Tabs.GetQuery( { filters: { tabId: params.tabId, fromLastSync: new Date() - TABLIFESPAN } }, function( err, tab ){
        if( err ){
          done( err );
        } else {
          if( tab.length != 1 && tab.length != 0 ){
            done( new self.NotFoundError() );

          } else if( tab.length == 0 ){

            // At this point, the tab wasn't found. If workspaceId was passed via headers,
            // the person will be returned the configuration for that workspace. We need to check
            // that the user actually has access to that workspaceId.

            hotCoreMultiHome.UserWorkspaces.GetQuery( { filters: { userId: self._req.session.userId, workspaceId: headersWorkspaceId } }, function( err, uwDocs){
              if( err ){
                done( err );
              } else {
                if( uwDocs.length == 0 ){
                  done( new self.NotFoundError() );
                } else {
           

                  // exports.Tabs.Post( { lastSync: new Date(), userId: self._req.session.userId }, {}, function( err, tab ){
                  exports.Tabs.Post( { userId: self._req.session.userId }, {}, function( err, tab ){
                    if( err ){
                       done( err );
                    } else {

                      hotCoreStoreConfig.getConfig( headersWorkspaceId, self._req.session.userId, function( err, storeRecords ){
                        if( err ){
                          done( err );
                        } else {
                          done( null, { messages: [ { fromUserId: self._req.session.userId, message: { type: 'resetStores', tabId: tab.tabId, storeRecords: storeRecords } } ] } );
                        };
                      });

                    }
                  }); // Tabs.Post()


                }
              }
            });//UserWorkspaces.GetQuer ()


          } else {

            // Write the new access time onto the tab's record; 
            tab = tab[ 0 ];
            tab.lastSync = new Date();
            exports.Tabs.Put( tab.tabId, tab, function( err, tab ){
              if( err ){
                done( err );
              } else {

                // Return all messages for that tab, REMOVING after fetching
                exports.TabMessages.GetQuery( { filters: { tabId: params.tabId, fromAdded: new Date() - TABLIFESPAN }, remove: true }, function( err, tabMessages ){
                  if( err ){
                    done( err );
                  } else {
         
                    tabMessages.forEach( function( tabMessage ){
                      delete tabMessage._id;
                      delete tabMessage.messageId;
                      delete tabMessage.tabId;

                      messages.push( tabMessage);
                    });
                    done( null, { messages: messages } );
                  }
                });
              }

            });

           }
        };
      });
    
    },

  });

  done( null );
}

hooks.init.after = [ 'hotCoreJsonRestStores', 'hotCoreMultiHome' ];

hooks.stores = function( done ){

  done( null,  {
    moduleName: 'hotCoreComet', result: [ exports.Tabs, exports.TabMessages, exports.TabMessageDispatcher ]
  });
}


hooks.cometBroadcast = function( userId, tabId, makeTabIdHash, message, done ){

  var self = this;

  // makeTabId function wasn't passed: just use the stock "send it to all tabs" function
  if( ! makeTabIdHash ) makeTabIdHash = allTabIdHash;

  // Get the list of tab ids
  makeTabIdHash( userId, tabId, message, function( err, tabIdHash ){

    // For each open tab, add the message to its queue 
    for( tabId in tabIdHash ){
      exports.TabMessages.Post( { tabId: tabId, fromUserId: userId, message: message }, function( err ) {
        if( err ){
          // TODO: log err
        }
      } );
    };
   
    done( null );

  });  


}

function allTabIdHash( userId, tabId, message, done ){

  var tabIdHash = {}; 

  // Just return all active tabs

  exports.Tabs.GetQuery( { filters: { fromLastSync: new Date() - TABLIFESPAN  }  }, function( err, docs ){
    if( err ){
      done( err );
    } else {
      docs.forEach( function( i ){
        if( i.tabId != tabId ) tabIdHash[ i.tabId ] = true;
      });
      done( null, tabIdHash );
    }
  });

}



