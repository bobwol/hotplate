"use strict";

var dummy
  , hotplate = require('hotplate')

  , declare = require('simpledeclare')

  , SimpleDbLayer = require( 'simpledblayer' )
  , SimpleSchema = require( 'simpleschema' )
  , JsonRestStores = require( 'jsonreststores' )

  , hotCoreStoreConfig = require( 'hotCoreStoreConfig' )
  , hotCoreStoreRegistry = require( 'hotCoreStoreRegistry' )
;


// Define store and mongo drivers.

var TABLIFESPAN = 180000;
var CLEANUPINTERVAL = 60000;

hotplate.hotEvents.on( 'stores', 'hotCoreComet', hotplate.cachable( function( done ){

  var stores = {};

  // This module only uses JsonRestStores as a way to access the DB and expose methods,
  // it doesn't mixin with hotJsonRestStores (which would do Comet event emission etc.)

  var BasicDbStore = declare( JsonRestStores, {
    DbLayer: declare( [ SimpleDbLayer, hotplate.config.get('hotplate.DbLayerMixin') ], { db: hotplate.config.get( 'hotplate.db' ) } )
  });

  var BasicDbSchema = declare( [ SimpleSchema, hotplate.config.get( 'hotplate.SchemaMixin') ] );

  // ***********************************
  // *** OPEN TABS   *******************
  // ***********************************

  stores.Tabs = declare( BasicDbStore, {

    schema: new BasicDbSchema({
      id:         { type: 'id' },

      userId:        { type: 'id', required: true },
      lastSync:      { type: 'date', default: function(){ return new Date() } },
    }),

    searchSchema: new BasicDbSchema({
      id:            { type: 'id' },

      userId:        { type: 'id' },
      lastSync:      { type: 'date' },

      // Ordering filters
      fromLastSync:  { type: 'date', searchable: { type: 'gte', field: 'lastSync' } },
      toLastSync:    { type: 'date', searchable: { type: 'lte', field: 'lastSync' }  },
    }),

    handlePost: true,
    checkPermissionsPost: function( params, body, options, cb ){
      cb( null, true );
    },
 
    handleDelete: true,
    checkPermissionsDelete: function( params, body, options, doc, fullDoc, cb ){
      cb( null, true );
    },

    storeName:  'Tabs',
    paramIds: [ 'id' ],

    publicURL: '/tabs/',

    prepareBodyPost: function( body, cb ){

      if( this.remote ){
        if( this._req.session.userId ){
          body.userId = this._req.session.userId;
        }
      }
      cb( null, body );
    },

    // Delete ALL entries in TabMessages when a tab gets deleted
    afterDelete: function( params, body, options, doc, fullDoc, cb ){

      // Delete the tab messages
      (new stores.TabMessages()).dbLayer.delete( { conditions: { and: [ { field: 'tabId', type:'eq', value: body.tabId } ] } }, cb );
    },

  });

  stores.TabMessages = declare( BasicDbStore, {

    schema: new BasicDbSchema({
      id:            { type: 'id' },
      tabId:         { type: 'id' },

      fromUserId:    { type: 'id', required: true },
      message:       { type: 'serialize', required: true },
      added:         { type: 'date', default: function() { return new Date() } },
    }),

    searchSchema: new BasicDbSchema({
      id       : { type: 'id' },
      tabId    : { type: 'id' },

      fromAdded: { type: 'date', searchable: { type: 'gte', field: 'added' }  },
      toAdded  : { type: 'date', searchable: { type: 'lte', field: 'added' }  },
    }),

    storeName:  'TabMessages',
    paramIds: [ 'tabId', 'id' ],

  });

  
  // PSEUDO-STORE, sends an object out with all of the messages
  // It will return an array of unserialised messages in TabMessages for
  // a specific tabId, and then it will DELETE those messages
  stores.TabMessageDispatcher = declare( JsonRestStores, {

    // COMMON
    schema: new SimpleSchema({
      tabId:         { type: 'string' },
      messages:      { type: 'none' },
    }),

    DbLayer: SimpleDbLayer,

    storeName:  'TabMessageDispatcher',

    paramIds: [ 'tabId' ],

    publicURL: '/tabs/dispatcher/',


    handleGet: true,
    checkPermissionsGet: function( params, body, options, doc, fullDoc, done ){

      // Check that the remote user requesting the tab is indeed the tab's owner
      
      var self = this;

      // User needs to be logged in
      if( ! self._req.session.userId ) return done( null, false );

      // TODO: Optimise a little here. Since checkPermissionsGet is called before driverAllDbFetch,
      // try and cache this result
      stores.Tabs.GetQuery( { filters: { fromLastSync: new Date() - TABLIFESPAN, id: params.tabId } }, function( err, tab ){
        if( err ){
          done( err );
        } else {

          // This may seem strange, but always pass authentication if the tab is not
          // there, as the store will need to accept the get and return the "storeReset"
          // message after returning the new tab
          if( tab.length == 0 ){
             done( null, true );

          } else {
            tab = tab[0];
            done( null, tab.userId.toString() === self._req.session.userId.toString() );
          }
        }
      });

 
    },

    execAllDbFetch: function( params, body, options, done ){

      var messages = [];
      var self = this;

      // If it's not a remote call, always return empty result
      if( ! self.remote ) return done( null, { messages: [] } );

      var headersWorkspaceId = self._req.headers[ 'x-hotplate-workspaceid' ];

      // User is not logged in -- goodbye
      if( ! self._req.session.loggedIn || ! self._req.session.userId ){
        hotplate.log("A non-logged in user tried to fetch tabId %s for workspaceId %s, denying...", params.tabId, headersWorkspaceId );
        return done( new self.UnauthorizedError() );
      }

      hotplate.log("Looking for tab %s owned by user %s, x-workspaceId is %s", params.tabId, self._req.session.userId, headersWorkspaceId );

      // Return all messages for that tab, REMOVING after fetching
      stores.Tabs.GetQuery( { filters: { id: params.tabId, userId: self._req.session.userId, fromLastSync: new Date() - TABLIFESPAN } }, function( err, tab ){
        if( err ){
          done( err );
        } else {


          hotplate.log("Returned:");
          hotplate.log( tab );
          if( tab.length == 0 ){

            hotplate.log("Tab was NOT present. Trying to understand if I should create one");

            // At this point, the tab wasn't found. If workspaceId was passed via headers,
            // the person will be returned the configuration for that workspace. We need to check
            // that the user actually has access to that workspaceId.

            hotCoreStoreRegistry.getAllStores( function( err, storesData ){
              if( err ){
                done( err );
              } else {
                hotplate.log("Checking that user has access to the workspaceId she is trying to register for");
                storesData.stores.UsersWorkspaces.Store.GetQuery( { filters: { userId: self._req.session.userId, workspaceId: headersWorkspaceId } }, function( err, uwDocs){
                  if( err ){
                    done( err );
                  } else {
                    if( uwDocs.length == 0 ){
                      hotplate.log("No access -- user needs to (re?)login!");
                      done( new self.UnauthorizedError() );
                    } else {
               
    
                      hotplate.log("OK, access is cleared, creating the tab for the user...");
                      hotplate.log( self._req.session.userId );
                      stores.Tabs.Post( { userId: self._req.session.userId }, {}, function( err, tab ){
                        if( err ){
                           done( err );
                        } else {
    
                          
                          hotplate.log("...and ALSO returning the workspace configuration for that userId");
                          hotCoreStoreConfig.getConfigRecords( headersWorkspaceId, self._req.session.userId, function( err, storeRecords ){
                            if( err ){
                              done( err );
                            } else {
                              done( null, { messages: [ { fromUserId: self._req.session.userId, message: { type: 'resetStores', tabId: tab.id, storeRecords: storeRecords } } ] } );
                            };
                          });
    
                        }
                      }); // Tabs.Post()
    
    
                    }
                  }
                });//UsersWorkspaces.GetQuer ()
              }
            });


          } else {

            // Write the new access time onto the tab's record; 
            tab = tab[ 0 ];
            tab.lastSync = new Date();
            stores.Tabs.Put( tab.id, tab, function( err, tab ){
              if( err ){
                done( err );
              } else {

                // Return all messages for that tab, REMOVING after fetching
                stores.TabMessages.GetQuery( { filters: { tabId: params.tabId, fromAdded: new Date() - TABLIFESPAN }, delete: true }, function( err, tabMessages ){
                  if( err ){
                    done( err );
                  } else {
         
                    tabMessages.forEach( function( tabMessage ){
                      // delete tabMessage._\id;
                      delete tabMessage.messageId;
                      delete tabMessage.tabId;

                      messages.push( tabMessage);
                    });
                    done( null, { messages: messages } );
                  }
                });
              }

            });

           }
        };
      });
    
    },

  });

  done( null,  stores );

}))


hotplate.hotEvents.on( 'run', hotplate.cachable( function( done ){

  hotCoreStoreRegistry.getAllStores( function( err, storesData ){
    if( err ){
      done( err );
    } else {
      // Clean up Tabs collection every 30 seconds, so that
      // dead tabs are gotten rid of
      var cleaningUp = false;


      setInterval( function(){
        if( cleaningUp ) return;
        cleaningUp = true;

        hotplate.log("Cleaning up unused tabs...");

        //hotplate.log( "Cleaning up expired tabs and tab messages..." );

        storesData.stores.Tabs.storeObject.dbLayer.delete( { conditions: { and: [ { field: 'lastSync', type: 'lte', value: new Date( new Date() - TABLIFESPAN ) } ] } }, { multi: true }, function( err, howMany ){
          // hotplate.log( 'Tabs: error and howMany: ', err, howMany );
          //TODO: Log error

          storesData.stores.TabMessages.storeObject.dbLayer.delete( { conditions: { and: [ { field: 'added', type: 'lte', value: new Date( new Date() - TABLIFESPAN ) } ] } }, { multi: true }, function( err, howMany ){
            ////  hotplate.log( 'TabMessages: error and howMany: ', err, howMany );
            // TODO: Log error
            cleaningUp = false;
          });
        });
 
      }, CLEANUPINTERVAL );

    }
  });

  done( null );
}));


hotplate.hotEvents.on('cometBroadcast', 'hotCoreComet', function( userId, tabId, makeTabIdHash, message, done ){

  var self = this;

  hotCoreStoreRegistry.getAllStores( function( err, storesData ){
    if( err ){
      done( err );
    } else {

      // makeTabId function wasn't passed: just use the stock "send it to all tabs" function
      if( ! makeTabIdHash ){
        hotplate.logger.warn("Using allTabIdHash!");
        makeTabIdHash = allTabIdHash;
      } else {
        hotplate.logger.warn("Using PASSED makeTabIdHash!");
      }

      // Get the list of tab ids
      makeTabIdHash( userId, tabId, message, function( err, tabIdHash ){

        // For each open tab, add the message to its queue 
        for( tabId in tabIdHash ){
          storesData.stores.TabMessages.Store.Post( { tabId: tabId, fromUserId: userId, message: message }, function( err ) {
            if( err ){
              // TODO: log err
            }
          } );
        };
   
        done( null );
      })
    }

  });  

});

function allTabIdHash( userId, tabId, message, done ){

  hotplate.logger.warn("In allTabIdHash!" );

  hotCoreStoreRegistry.getAllStores( function( err, storesData ){
    if( err ){
      done( err );
    } else {

      var tabIdHash = {}; 

      // Just return all active tabs

      storesData.stores.Tabs.Store.GetQuery( { filters: { fromLastSync: new Date() - TABLIFESPAN  }  }, function( err, docs ){
        if( err ){
          done( err );
        } else {
          docs.forEach( function( i ){
            if( i.id != tabId ) tabIdHash[ i.id ] = true;
          });
          done( null, tabIdHash );
        }
      });
    }
  });

}



