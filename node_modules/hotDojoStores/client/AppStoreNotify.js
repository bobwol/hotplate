
define([
     "dojo/_base/declare",
     "dojo/topic",
     "dojo/_base/lang",
     "dojo/aspect",
     "dojo/when",
     "hotplate/hotDojoStores/stores",
     "hotplate/hotDojoComet/messages",
     "dojo/domReady!",
   ], function(
   declare
   , topic
   , lang
   , aspect
   , when
   , stores
   , messages
//   , Sync
 ){

  // TODO: Watch http://stackoverflow.com/questions/20735572/using-aspect-around-but-checking-for-methods-calling-each-other/20738272#20738272

  // When a 'resetStores' topic is published, all store's cache is deleted (as it's
  // most likely to be outdated)
  topic.subscribe( 'resetStores', function(){

    // Sets 'configStores' as the hash containing the config stores (they will NOT
    // get initialised)
    var configStores = {};
    if( typeof( vars['hotCoreStoreConfig'] ) === 'object' && typeof( vars['hotCoreStoreConfig'] ) !== null ){
      if( typeof( vars['hotCoreStoreConfig']['configStores'] ) === 'object' && typeof( vars['hotCoreStoreConfig']['configStores'] ) !== null ){
        configStores = vars['hotCoreStoreConfig']['configStores'];
      }
    }
 
    var allDefinedStores = stores();
    for( var storeName in allDefinedStores ){
      var definedStores = allDefinedStores[ storeName ];

      for( var target in definedStores ){
        var store = definedStores[ target ];
        if( ! configStores[ store.storeName ] ){
          store.memCache.setData( [] );
        }
      } 
     
    };
  });

  topic.subscribe( 'hotplate/hotDojoStores/newStore', function( storeName, store ){

    var inMethod;

    aspect.around( store, 'put', function( put ){

      return function( object, options ){

        if( inMethod ){
          return put.call( store, object, options );
        } else {

          inMethod = true;

          try {
            var results = put.call( store, object, options );
            when( results ).then( function( r ){
              var eventName;
              var identity = store.idProperty;
              eventName = object[ identity ] ? 'storeRecordUpdate' : 'storeRecordCreate';

              topic.publish( eventName, null, { type: eventName, storeName: storeName, objectId: r[ identity ], object: object }, false );
            });
            return results;
          } finally {
            inMethod = false;
          }

        }

      }
    });

    aspect.around( store, 'add', function( add ){
      return function( object, options ){

        if( inMethod ){
          return add.call( store, object, options );
        } else {

          inMethod = true;

          try {
            var results = add.call( store, object, options );
            when( results ).then(  function( r ){
              var identity = store.idProperty;
              topic.publish('storeRecordCreate', null, { type: 'storeRecordCreate', storeName: storeName, objectId: r[identity], object: object }, false );
            });
            return results;
          } finally {
            inMethod = false;
          }
        }
      }

    });

    aspect.around( store, 'remove', function( remove ){
      return function( objectId, options ){

        if( inMethod ){
          return remove.call( store, objectId, options );
        } else {

          inMethod = true;

          try {
            var results = remove.call( store, objectId, options );
            when( results ).then( function( r ) {
              topic.publish('storeRecordRemove', null, { type: 'storeRecordRemove', storeName: storeName, objectId: objectId }, false );
            });
          } finally {
            inMethod = false 
          }

        };
      };
    });

  });


  // CHANGES FROM THE OUTSIDE
  //
  // Update local stores according to Comet messages
  
  topic.subscribe('storeRecordUpdate', function( from, message, remote ){

    // A Comet changed a remote store. Refresh the Something came from a Comet. 
    if( remote ){

      var definedStores = stores( message.storeName );
      for( var k in definedStores ){
        var store = definedStores[ k ];

        store.memCache.put( message.object );
        store.notify( message.object, message.object[ store.idProperty ]);
      }

    }
  });

  topic.subscribe('storeRecordCreate', function( from, message, remote ){
    // A Comet changed a remote store. Refresh the Something came from a Comet. 
    if( remote ){

     var definedStores = stores( message.storeName );
      for( var k in definedStores ){
        var store = definedStores[ k ];

        store.memCache.put( message.object );
        store.notify( message.object );
      }
    }
  });

  topic.subscribe('storeRecordRemove', function( from, message, remote ){
    // A Comet changed a remote store. Refresh the Something came from a Comet. 
    if( remote ){

     var definedStores = stores( message.storeName );
      for( var k in definedStores ){
        var store = definedStores[ k ];
        store.memCache.remove( message.objectId );
        store.notify( undefined, message.objectId );
      }
    }
  });

  // Sync.ready('hotplate/hotDojoStores/newStore');
  return {};

});


