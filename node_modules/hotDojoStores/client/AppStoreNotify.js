
define([
     "dojo/_base/declare",
     "dojo/topic",
     "dojo/_base/lang",
     "dojo/aspect",
     "dojo/when",
     "hotplate/hotDojoStores/stores",
     "hotplate/hotDojoComet/messages",
     'hotplate/hotDojoWidgetHooks/SyncTopic',
     "hotplate/hotDojoWidgetHooks/SyncSubscriber!hotplate/hotDojoStores/newStore|AppStoreNotify",
     "dojo/domReady!",
   ], function(
   declare
   , topic
   , lang
   , aspect
   , when
   , stores
   , messages
   , Sync
 ){

  var storeList = [];

  // When a 'resetStores' topic is published, all store's cache is deleted (as it's
  // most likely to be outdated)
  topic.subscribe( 'resetStores', function(){

    // Sets 'configStores' as the hash containing the config stores (they will NOT
    // get initialised)
    var configStores = {};
    if( typeof( vars['hotCoreStoreConfig'] ) === 'object' && typeof( vars['hotCoreStoreConfig'] ) !== null ){
      if( typeof( vars['hotCoreStoreConfig']['configStores'] ) === 'object' && typeof( vars['hotCoreStoreConfig']['configStores'] ) !== null ){
        configStores = vars['hotCoreStoreConfig']['configStores'];
      }
    }
 
    // For each store defined, reset its cache if it's not a config store
    // (they get updated automatically)
    storeList.forEach( function( store ){
       if( ! configStores[ store.storeName ] ){
        store.memCache.setData( [] );
      } 

    });
  });

  topic.subscribe( 'hotplate/hotDojoStores/newStore', function( storeName, store ){

    // Add this store to the store registry
    storeList.push( store );

    // CHANGES WITHIN
    //
    // For each "put", "post" and "remove" in the store, publish a message locally
    // about the store being changed
    // Basically, after a put() or a remove(), it will publish a topic (storeRecordUpdate, storeRecordCreate or storeErase )
    // so that other parts of the application will be able to listen up.

    aspect.around( store, 'put', function( put ){

      return function( object, options ){

        return when( put.call( store, object, options ) ).then( function( r ) {
          var eventName;
          var identity = store.idProperty;
          eventName = object[ identity ] ? 'storeRecordUpdate' : 'storeRecordCreate';

          topic.publish( eventName, null, { storeName: storeName, storeTarget: store.target, objectId: r[ identity ], object: object }, false );

        } );

      }
    });

    /*
    aspect.around( store, 'add', function( add ){
      return function( object, options ){

        return when( add.call( store, object, options ) ).then( function( r ) {

          var identity = store.idProperty;

          topic.publish('storeRecordCreate', null, { storeName: storeName, storeTarget: storeTarget, objectId: r[identity], object: object }, false }  );

        });
      }
    });*/

    aspect.around( store, 'remove', function( remove ){
      return function( objectId, options ){

        return when( remove.call( store, objectId, options ) ).then( function( r) {

          topic.publish('storeRecordRemove', null, { storeName: storeName, storeTarget: store.target, objectId: objectId }, false );

        });
      };
    });

  });


  // CHANGES FROM THE OUTSIDE
  //
  // Update local stores according to Comet messages
  
  topic.subscribe('storeRecordUpdate', function( from, message, remote ){

    // A Comet changed a remote store. Refresh the Something came from a Comet. 
    if( remote ){

      // Inject the data into the store's cache, run a notify on the main store
      var store = stores( message.storeName, message.storeTarget );
      if( store ){
        store.memCache.put( message.object );
        store.notify( message.object, message.object[ store.idProperty ]);
      }

    }
  });

  topic.subscribe('storeRecordCreate', function( from, message, remote ){
    // A Comet changed a remote store. Refresh the Something came from a Comet. 
    if( remote ){

      // Inject the data into the store's cache, run a notify on the main store,
      // publish an afterCache event
      var store = stores( message.storeName, message.storeTarget );
      if( store ){
        store.memCache.put( message.object );
        store.notify( message.object );
      }
    }
  });

  topic.subscribe('storeRecordRemove', function( from, message, remote ){
    // A Comet changed a remote store. Refresh the Something came from a Comet. 
    if( remote ){

      // Inject the data into the store's cache, run a notify on the main store,
      // publish an afterCache event
      var store = stores( message.storeName, message.storeTarget );
      if( store ){
        store.memCache.remove( message.objectId );
        store.notify( undefined, message.objectId );
      }
    }
  });

  Sync.ready('hotplate/hotDojoStores/newStore');
  return {};

});


