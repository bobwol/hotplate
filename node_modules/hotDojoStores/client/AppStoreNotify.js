
define( [

  "dojo/_base/declare"
, "dojo/topic"
, "dojo/_base/lang"
, "dojo/aspect"
, "dojo/when"

, "hotplate/hotDojoStores/stores"

], function(

  declare
, topic
, lang
, aspect
, when

, stores

){

  // When a 'resetStores' topic is published, all store's cache is deleted (as it's
  // most likely to be outdated)
  topic.subscribe( 'resetStores', function(){

    // Sets 'configStores' as the hash containing the config stores (they will NOT
    // get zapped)
    var configStores = {};
    if( typeof( vars['hotCoreStoreConfig'] ) === 'object' && typeof( vars['hotCoreStoreConfig'] ) !== null ){
      if( typeof( vars['hotCoreStoreConfig']['configStores'] ) === 'object' && typeof( vars['hotCoreStoreConfig']['configStores'] ) !== null ){
        configStores = vars['hotCoreStoreConfig']['configStores'];
      }
    }
 
    var allDefinedStores = stores();
    for( var storeName in allDefinedStores ){
      var definedStores = allDefinedStores[ storeName ];

      // Zap all stores, except the config ones
      for( var target in definedStores ){
        var store = definedStores[ target ];
        if( ! configStores[ store.storeName ] ){

          if( store.memCache ) store.memCache.setData( [] );
        }
      } 
     
    };
  });

  // Utility function used to check if a target's placeholding elements
  // match a object's keys. For example:
  // * target: '/workspaces/workspaceId/users'
  // * targetHash: { workspaceId: 10 }
  // THEN:
  // * o == { user: 'Tony', workspaceId: 11} // RETURN FALSE
  // * o == { user: 'Tony', workspaceId: 10} // RETURN TRUE
  var objectValuesIn = function( target, targetHash, o ){

    // Get all tokens in the target.
    var elements = target.match(/:(\w*)/g);

    // No tokens: true by principle
    if( ! elements ) return true;
  
    // Go through tokens, and check that object being worked on
    // matches the passed hash for that store
    var equal = true;
    for( var i = 0, l = elements.length; i < l; i ++){
      var token = elements[ i ].substr( 1 );
      if( targetHash[ token ] != o[ token ] ){
        equal = false;
        break;
      }
    }

    return equal;
  }


  // Make sure that events are broadcast to alsoNotify stores and that alsoNotify store's
  // cache is updated accordingly

  topic.subscribe( 'hotplate/hotDojoStores/newStore', function( storeName, store ){

    store.on( 'add,update,remove', function( event ){

      if(  event.withinAlsoStoreNotification ) return;

      // Check if store.alsoNotify has elements -- if it does, they are "sibling" stores
      if( store.alsoNotify ){

        // Make up the new, enriched, event
        var newEvent = lang.mixin( event );
        newEvent.withinAlsoStoreNotification = true;

        // For each entry in alsoNotify, get the list of store instances (each one
        // might have a different target)
        for( var i = 0, l = store.alsoNotify.length; i < l; i ++){
          var alsoStores = stores( store.alsoNotify[ i ] );

          if( alsoStores ){

            // Go through each store instance
            for( var k in alsoStores ){
              var alsoStore = alsoStores[ k ];

              // If the paramIds matches, then add the item to the alsoStore cache
              // and issue a notify for the alsoStore for the object
              if( objectValuesIn( alsoStore.target, alsoStore.targetHash, event.target ) ){
                if( event.type == 'add' || event.type == 'update' ){

                  var options = {};
                  if( event.beforeId ) beforeId = event.beforeId;

                  alsoStore.memCache.put( event.target, options );
                  alsoStore.emit( newEvent );
              
                } else {
                  alsoStore.memCache.remove( event.target );
                  alsoStore.emit( newEvent );
                }
              }
            }
          }
        }
      }
    });
  });

  // CHANGES FROM THE OUTSIDE
  //
  // Update local stores according to Comet messages
  
  topic.subscribe('storeRecordUpdate', function( from, message ){

    var definedStores = stores( message.storeName );
    for( var k in definedStores ){
      var store = definedStores[ k ];

      if( objectValuesIn( store.target, store.targetHash, message.object ) ){

        var event = {}
        var params = {};

        // Sets event.target, taken from the message's object
        event.target = message.object;
        event.remote = true;

        // Copy the message over onto the event object
        // Note that `target`, `putBefore`, `putDefaultPosition` and `remote` are special
        for( var k in message ){
          if( k === 'putBefore' || k === 'putDefaultPosition' || k === 'object' || k === 'remote' ) continue;
          event[ k ] = message[ k ];
        }

        // Sets event.beforeId (for the event) and params.beforeId (for the put), 
        if( typeof( message.putBefore ) !== 'undefined' ){
          event.beforeId = message.putBefore;
          params.beforeId = message.putBefore;
        } else if( message.putDefaultPosition === 'end' ) {
          event.beforeId = null;
          params.beforeId = null;
        }

        // Place the item in the right spot in the cache
        if( store.memCache) store.memCache.put( message.object, params );

        // Emit the update event, which will effectively notify all tracking widgets
        store.emit( 'update', event );
      }
    }
  });

  topic.subscribe('storeRecordCreate', function( from, message, remote ){

    var definedStores = stores( message.storeName );
    for( var k in definedStores ){
      var store = definedStores[ k ];

      if( objectValuesIn( store.target, store.targetHash, message.object ) ){

        var event = {}
        var params = {}

        // Sets event.target, taken from the message's object
        event.target = message.object;
        event.remote = true;

        // Copy the message over onto the event object
        // Note that `target`, `putBefore`, `putDefaultPosition` and `remote` are special
        for( var k in message ){
          if( k === 'putBefore' || k === 'putDefaultPosition' || k === 'object' || k === 'remote' ) continue;
          event[ k ] = message[ k ];
        }

        // Sets event.beforeId (for the event) and params.beforeId (for the put), 
        if( typeof( message.putBefore ) !== 'undefined' ){
          event.beforeId = message.putBefore;
          params.beforeId = message.putBefore;
        } else if( message.putDefaultPosition === 'end' ) {
          event.beforeId = null;
          params.beforeId = null;
        }

        // Place the item in the right spot in the cache
        if( store.memCache) store.memCache.put( message.object, params );
        
        // Emit the update event, which will effectively notify all tracking widgets
        store.emit( 'add', event );
      }
    }
  });

  topic.subscribe('storeRecordRemove', function( from, message, remote ){

    var definedStores = stores( message.storeName );
    for( var k in definedStores ){
      var store = definedStores[ k ];

     if( objectValuesIn( store.target, store.targetHash, message.object ) ){

        var event = {}
        
        event.target = message.object;
        event.id = message.objectId;
        event.remote = true;

        // Copy the message over onto the event object
        // Note that `target`, `putBefore` and `putDefaultPosition` are special
        for( var k in message ){
          if( k === 'object' || k === 'remote' || k === 'id' ) continue;
          event[ k ] = message[ k ];
        }

        // Delete the element from the cache
        if( store.memCache) store.memCache.remove( message.objectId );

        // Emit the update event, which will effectively notify all tracking widgets
        store.emit( 'remove', event );
      }
    }
  });

  return {};

});


