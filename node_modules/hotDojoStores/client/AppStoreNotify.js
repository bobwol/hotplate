
define( [

  "dojo/_base/declare"
, "dojo/topic"
, "dojo/_base/lang"
, "dojo/aspect"
, "dojo/when"

, "hotplate/hotDojoStores/stores"

], function(

  declare
, topic
, lang
, aspect
, when

, stores

){


  var objectValuesIn = function( target, targetHash, o ){

    // Get all tokens in the target.
    var elements = target.match(/:(\w*)/g);

    // No tokens: true by principle
    if( ! elements ) return true;
  
    // Go through tokens, and check that object being worked on
    // matches the passed hash for that store
    var equal = true;
    for( var i = 0, l = elements.length; i < l; i ++){
      var token = elements[ i ].substr( 1 );
      if( targetHash[ token ] != o[ token ] ){
        equal = false;
        break;
      }
    }

    return equal;
  }

  function fillAndNotifyAlsoStores( op, store, object, options ){
    // Check if store.alsoNotify has elements -- if it does, they are "sister" stores
    if( store.alsoNotify ){

      // For each entry in alsoNotify, get the list of store instances (each one
      // might have a different target)
      for( var i = 0, l = store.alsoNotify.length; i < l; i ++){
        var alsoStores = stores( store.alsoNotify[ i ] );

        if( alsoStores ){

          // Go through each store instance
          for( var k in alsoStores ){
            var alsoStore = alsoStores[ k ];

            // If the paramIds matches, then add the item to the alsoStore cache
            // and issue a notify for the alsoStore for the object
            if( objectValuesIn( alsoStore.target, alsoStore.targetHash, object ) ){
              if( op == 'put' || op == 'add' ){

                // TODO: This is actually wrong. This might be creating a record with a put
                // if the id didn't exist beforehand. Instead, this way, it will
                // emit a "storeRecordUpdate" event in ANY case (whether the record already existed or not)
                var type = object[ store.idProperty ] ? 'update' : 'add';
                alsoStore.emit( type, { target: object } );

                // TODO dstore: uncomment when dstore caching works
                //alsoStore.memCache.put( object, options );
            
                //alsoStore.notify( object, options );
              } else {

                // TODO dstore: uncomment when dstore caching works
                //alsoStore.memCache.remove( object );

                alsoStore.emit( 'remove', { target: object[ store.idProperty ] } );

              }

            }
          }
        }
      }
    }
  }



  // When a 'resetStores' topic is published, all store's cache is deleted (as it's
  // most likely to be outdated)
  topic.subscribe( 'resetStores', function(){

    // Sets 'configStores' as the hash containing the config stores (they will NOT
    // get zapped)
    var configStores = {};
    if( typeof( vars['hotCoreStoreConfig'] ) === 'object' && typeof( vars['hotCoreStoreConfig'] ) !== null ){
      if( typeof( vars['hotCoreStoreConfig']['configStores'] ) === 'object' && typeof( vars['hotCoreStoreConfig']['configStores'] ) !== null ){
        configStores = vars['hotCoreStoreConfig']['configStores'];
      }
    }
 
    var allDefinedStores = stores();
    for( var storeName in allDefinedStores ){
      var definedStores = allDefinedStores[ storeName ];

      // Zap all stores, except the config ones
      for( var target in definedStores ){
        var store = definedStores[ target ];
        if( ! configStores[ store.storeName ] ){

          // TODO dstore: uncomment when dstore caching works
          // store.memCache.setData( [] );
        }
      } 
     
    };
  });


  // CHANGES FROM WITHIN
  //
 
  topic.subscribe( 'hotplate/hotDojoStores/newStore', function( storeName, store ){

    var inMethod;

    aspect.around( store, 'put', function( put ){

      return function( object, options ){

        if( inMethod ){
          return put.call( store, object, options );
        } else {

          inMethod = true;

          try {
            var results = put.call( store, object, options );
            when( results ).then( function( r ){

              // Fill and notify "also" stores, which were automatically affected at backend
              fillAndNotifyAlsoStores( 'put', store, r, options );
              
              // TODO: This is actually wrong. This might be creating a record with a put
              // if the id didn't exist beforehand. Instead, this way, it will
              // emit a "storeRecordUpdate" event in ANY case (whether the record already existed or not)

              var eventName;
              var identity = store.idProperty;
              eventName = object[ identity ] ? 'storeRecordUpdate' : 'storeRecordCreate';

              // Make up the parameters
              var message = { storeName: storeName, type: eventName, objectId: r[ identity ], object: r };

              // Add 'before' and 'justReposition' options to the broadcast
              if( typeof( options ) === 'object' && options !== null ){
                if( typeof( options.beforeId ) !== 'undefined' ) message.beforeId = options.beforeId;
                if( options.justReposition ) message.justReposition = true;
              }
              topic.publish( eventName, null, message, false );

              // Check if store.alsoNotify has elements -- if it does, they are "sister" stores
              if( store.alsoNotify ){
                for( var i = 0, l = store.alsoNotify.length; i < l; i ++){
                  // Publish the (local) topic for the alsoNotify store
                  messageCopy = lang.mixin( message );
                  messageCopy.storeName = store.alsoNotify[ i ];
                  topic.publish( eventName, null, messageCopy, false );
                }
              }
                

            });
            return results;
          } finally {
            inMethod = false;
          }

        }

      }
    });

    aspect.around( store, 'add', function( add ){
      return function( object, options ){

        if( inMethod ){
          return add.call( store, object, options );
        } else {

          inMethod = true;

          try {
            var results = add.call( 'add', store, object, options );
            when( results ).then(  function( r ){

              fillAndNotifyAlsoStores( 'add', store, r, options );

              var identity = store.idProperty;

              var message = { type: 'storeRecordCreate', storeName: storeName, objectId: r[identity], object: r };

              // Add 'before' and 'justReposition' options to the broadcast
              if( typeof( options ) === 'object' && options !== null ){
                if( typeof( options.beforeId ) !== 'undefined' ) message.beforeId = options.beforeId;
                if( options.justReposition ) message.justReposition = true;
              }

              topic.publish('storeRecordCreate', null, message, false );

              // Check if store.alsoNotify has elements -- if it does, they are "sister" stores
              if( store.alsoNotify ){
                for( var i = 0, l = store.alsoNotify.length; i < l; i ++){
                  // Publish the (local) topic for the main store
                  messageCopy = lang.mixin( message );
                  messageCopy.storeName = store.alsoNotify[ i ];
                  topic.publish( eventName, null, messageCopy, false );
                }
              }


            });
            return results;
          } finally {
            inMethod = false;
          }
        }
      }

    });

    aspect.around( store, 'remove', function( remove ){
      return function( objectId, options ){

        if( inMethod ){
          return remove.call( store, objectId, options );
        } else {

          inMethod = true;

          try {
            var results = remove.call( store, objectId, options );
            when( results ).then( function( r ) {

              fillAndNotifyAlsoStores( 'remove', store, r, options );

              topic.publish('storeRecordRemove', null, { type: 'storeRecordRemove', storeName: storeName, objectId: objectId }, false );

              // Check if store.alsoNotify has elements -- if it does, they are "sister" stores
              if( store.alsoNotify ){
                for( var i = 0, l = store.alsoNotify.length; i < l; i ++){
                // Publish the (local) topic for the main store
                  messageCopy = lang.mixin( message );
                  messageCopy.storeName = store.alsoNotify[ i ];
                  topic.publish( eventName, null, messageCopy, false );
                }
              }

            });
            return results;
          } finally {
            inMethod = false 
          }

        };
      };
    });

  });


  // CHANGES FROM THE OUTSIDE
  //
  // Update local stores according to Comet messages
  
  topic.subscribe('storeRecordUpdate', function( from, message, remote ){

    // A Comet changed a remote store. 
    if( remote ){
            
      function work( storeName ){

        var definedStores = stores( storeName );
        for( var k in definedStores ){
          var store = definedStores[ k ];

          if( objectValuesIn( store.target, store.targetHash, message.object ) ){
            var event = {}
            event.target = message.object;

            if( typeof( message.beforeId ) !== 'undefined' ) event.beforeId = message.beforeId;
            if( event.justReposition) event.justReposition = true;
            // TODO dstore: uncomment when dstore caching works
            //store.memCache.put( message.object, params );

            //store.notify( message.object, message.object[ store.idProperty ], params );
            store.emit( 'update', event );
          }
        }
      }

      // Do the work for the main store
      work( message.storeName );

      // Fill and notify stores connected to this one
      var alsoNotify = vars[ 'hotCoreStoreVars' ][ 'stores' ][ message.storeName ].alsoNotify;
      if( alsoNotify ){
        for( var i = 0, l = alsoNotify.length; i < l; i ++){
          work( alsoNotify );
        }
      }

    }
  });

  topic.subscribe('storeRecordCreate', function( from, message, remote ){


    // A Comet changed a remote store.
    if( remote ){

      function work( storeName ){

        //var definedStores = stores( message.storeName );
        var definedStores = stores( storeName );
        for( var k in definedStores ){
          var store = definedStores[ k ];

          var params = {}
          if( message.beforeId ) params.beforeId = message.beforeId;

          if( objectValuesIn( store.target, store.targetHash, message.object ) ){

            var event = {}
            event.target = message.object;
            if( typeof( message.beforeId ) !== 'undefined' ) event.beforeId = message.beforeId;

            // TODO dstore: uncomment when dstore caching works
            //store.memCache.put( message.object, params );

            //store.notify( message.object, params );

            store.emit( 'add', event );

          }
        }
      }

      // Do the work for the main store
      work( message.storeName );

      // Fill and notify stores connected to this one
      var alsoNotify = vars[ 'hotCoreStoreVars' ][ 'stores' ][ message.storeName ].alsoNotify;
      if( alsoNotify ){
        for( var i = 0, l = alsoNotify.length; i < l; i ++){
          work( alsoNotify );
        }
      }
    }
  });

  topic.subscribe('storeRecordRemove', function( from, message, remote ){
    // A Comet changed a remote store. 
    if( remote ){

      function work( storeName ){

        var definedStores = stores( storeName );
        for( var k in definedStores ){
          var store = definedStores[ k ];

         if( objectValuesIn( store.target, store.targetHash, message.object ) ){

            // TODO dstore: uncomment when dstore caching works
            //store.memCache.remove( message.objectId );

            //store.notify( undefined, message.objectId );
            store.emit( 'remove', { target: message.objectId } );
          }
        }
      }

      // Do the work for the main store
      work( message.storeName );

      // Fill and notify stores connected to this one
      var alsoNotify = vars[ 'hotCoreStoreVars' ][ 'stores' ][ message.storeName ].alsoNotify;
      if( alsoNotify ){
        for( var i = 0, l = alsoNotify.length; i < l; i ++){
          work( alsoNotify );
        }
      }
    }
  });

  return {};

});


