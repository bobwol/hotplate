
define( [

  "dojo/_base/declare"
, "dojo/topic"
, "dojo/_base/lang"
, "dojo/aspect"
, "dojo/when"

, "hotplate/hotDojoStores/stores"

], function(

  declare
, topic
, lang
, aspect
, when

, stores

){


  var objectValuesIn = function( o1, o2 ){

    // Check that the message's URL matches this specific store
    var equal = true;
    for(var k in o1){
      if( o1[ k ] != o2[ k ] ){
        equal = false;
        break;
      }
    }
    return equal;
  }

  function fillAndNotifyAlsoStores( op, store, object, options ){
    // Check if store.alsoNotify has elements -- if it does, they are "sister" stores
    if( store.alsoNotify ){

      // For each entry in alsoNotify, get the list of store instances (each one
      // might have a different target)
      for( var i = 0, l = store.alsoNotify.length; i < l; i ++){
        var alsoStores = stores( store.alsoNotify[ i ] );

        if( alsoStores ){

         // Go through each store instance
          for( var k in alsoStores ){
            var alsoStore = alsoStores[ k ];

           // If the paramIds matches, then add the item to the alsoStore cache
            // and issue a notify for the alsoStore for the object
            if( objectValuesIn( alsoStore.targetHash, object ) ){
              if( op == 'put' || op == 'add' ){
                alsoStore.memCache.put( object, options );
                alsoStore.notify( object, options );
              } else {
                alsoStore.memCache.remove( object );
                alsoStore.notify( undefined, object );
              }

            }
          }
        }
      }
    }
  }



  // When a 'resetStores' topic is published, all store's cache is deleted (as it's
  // most likely to be outdated)
  topic.subscribe( 'resetStores', function(){

    // Sets 'configStores' as the hash containing the config stores (they will NOT
    // get zapped)
    var configStores = {};
    if( typeof( vars['hotCoreStoreConfig'] ) === 'object' && typeof( vars['hotCoreStoreConfig'] ) !== null ){
      if( typeof( vars['hotCoreStoreConfig']['configStores'] ) === 'object' && typeof( vars['hotCoreStoreConfig']['configStores'] ) !== null ){
        configStores = vars['hotCoreStoreConfig']['configStores'];
      }
    }
 
    var allDefinedStores = stores();
    for( var storeName in allDefinedStores ){
      var definedStores = allDefinedStores[ storeName ];

      // Zap all stores, except the config ones
      for( var target in definedStores ){
        var store = definedStores[ target ];
        if( ! configStores[ store.storeName ] ){
          store.memCache.setData( [] );
        }
      } 
     
    };
  });




  // CHANGES FROM WITHIN
  //
 
  topic.subscribe( 'hotplate/hotDojoStores/newStore', function( storeName, store ){

    var inMethod;

    aspect.around( store, 'put', function( put ){

      return function( object, options ){

        if( inMethod ){
          return put.call( store, object, options );
        } else {

          inMethod = true;

          try {
            var results = put.call( store, object, options );
            when( results ).then( function( r ){

              // Fill and notify "also" stores, which were automatically affected at backend
              fillAndNotifyAlsoStores( 'put', store, r, options );
              
              var eventName;
              var identity = store.idProperty;
              eventName = object[ identity ] ? 'storeRecordUpdate' : 'storeRecordCreate';

              // HERE: PUBLISH A MESSAGE FOR EACH alsoNotify STORE

              // Make up the parameters
              var message = { type: eventName, objectId: r[ identity ], object: r };

              // Add 'before' and 'justReposition' options to the broadcast
              if( typeof( options ) === 'object' && options !== null ){
                if( typeof( options.before ) !== 'undefined' ) message.before = options.before;
                if( options.justReposition ) message.justReposition = true;
              }

              // Publish the (local) topic for the main store
              message.storeName = storeName;
              topic.publish( eventName, null, message, false );

              // Check if store.alsoNotify has elements -- if it does, they are "sister" stores
              if( store.alsoNotify ){
                for( var i = 0, l = store.alsoNotify.length; i < l; i ++){
                // Publish the (local) topic for the main store
                  messageCopy = lang.mixin( message );
                  messageCopy.storeName = storeName;
                  topic.publish( eventName, null, message,Copy false );
                }
              }
                

            });
            return results;
          } finally {
            inMethod = false;
          }

        }

      }
    });

    aspect.around( store, 'add', function( add ){
      return function( object, options ){

        if( inMethod ){
          return add.call( store, object, options );
        } else {

          inMethod = true;

          try {
            var results = add.call( 'add', store, object, options );
            when( results ).then(  function( r ){

              fillAndNotifyAlsoStores( store, r, options );

              var identity = store.idProperty;

              var message = { type: 'storeRecordCreate', storeName: storeName, objectId: r[identity], object: r };

              // Add 'before' and 'justReposition' options to the broadcast
              if( typeof( options ) === 'object' && options !== null ){
                if( typeof( options.before ) !== 'undefined' ) message.before = options.before;
                if( options.justReposition ) message.justReposition = true;
              }

              topic.publish('storeRecordCreate', null, message, false );
            });
            return results;
          } finally {
            inMethod = false;
          }
        }
      }

    });

    aspect.around( store, 'remove', function( remove ){
      return function( objectId, options ){

        if( inMethod ){
          return remove.call( store, objectId, options );
        } else {

          inMethod = true;

          try {
            var results = remove.call( store, objectId, options );
            when( results ).then( function( r ) {

              fillAndNotifyAlsoStores( 'remove', store, r, options );

              topic.publish('storeRecordRemove', null, { type: 'storeRecordRemove', storeName: storeName, objectId: objectId }, false );
            });
            return results;
          } finally {
            inMethod = false 
          }

        };
      };
    });

  });


  // CHANGES FROM THE OUTSIDE
  //
  // Update local stores according to Comet messages
  
  topic.subscribe('storeRecordUpdate', function( from, message, remote ){

    // A Comet changed a remote store. 
    if( remote ){

      function work( storeName ){

        var definedStores = stores( storeName );
        for( var k in definedStores ){
          var store = definedStores[ k ];

          if( objectValuesIn( store.targetHash, message.object ) ){
            var params = {}
           if( typeof( message.before ) !== 'undefined' ) params.before = message.before;
            if( message.justReposition) params.justReposition = true;
            store.memCache.put( message.object, params );
            store.notify( message.object, message.object[ store.idProperty ], params );
          }
        }
      }

      // Do the work for the main store
      work( message.storeName );

      // Fill and notify stores connected to this one
      var alsoNotify = vars[ 'hotCoreStoreVars' ][ 'stores' ][ message.storeName ].alsoNotify;
      if( alsoNotify ){
        for( var i = 0, l = alsoNotify.length; i < l; i ++){
          work( alsoNotify );
        }
      }

    }
  });

  topic.subscribe('storeRecordCreate', function( from, message, remote ){


    // A Comet changed a remote store.
    if( remote ){

      function work( storeName ){

        //var definedStores = stores( message.storeName );
        var definedStores = stores( storeName );
        for( var k in definedStores ){
          var store = definedStores[ k ];

          var params = {}
          if( message.before ) params.before = message.before;

          if( objectValuesIn( store.targetHash, message.object ) ){
            store.memCache.put( message.object, params );
            store.notify( message.object, params );
          }
        }
      }

      // Do the work for the main store
      work( message.storeName );

      // Fill and notify stores connected to this one
      var alsoNotify = vars[ 'hotCoreStoreVars' ][ 'stores' ][ message.storeName ].alsoNotify;
      if( alsoNotify ){
        for( var i = 0, l = alsoNotify.length; i < l; i ++){
          work( alsoNotify );
        }
      }
    }
  });

  topic.subscribe('storeRecordRemove', function( from, message, remote ){
    // A Comet changed a remote store. 
    if( remote ){

      function work( storeName ){

        var definedStores = stores( storeName );
        for( var k in definedStores ){
          var store = definedStores[ k ];

         if( objectValuesIn( store.targetHash, message.object ) ){
            store.memCache.remove( message.objectId );
            store.notify( undefined, message.objectId );
          }
        }
      }

      // Do the work for the main store
      work( message.storeName );

      // Fill and notify stores connected to this one
      var alsoNotify = vars[ 'hotCoreStoreVars' ][ 'stores' ][ message.storeName ].alsoNotify;
      if( alsoNotify ){
        for( var i = 0, l = alsoNotify.length; i < l; i ++){
          work( alsoNotify );
        }
      }
    }
  });

  return {};

});


