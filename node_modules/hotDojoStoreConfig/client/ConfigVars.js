
define([

  "dojo/_base/declare"
, "dojo/topic"
, "dojo/when"

, "hotplate/hotDojoStores/stores"
, "hotplate/hotDojoGlobals/globals"

], function(

  declare
, topic
, when

, stores
, globals

 ){

  var r = {};

  // Important note: this is a rare case where we can be sure that the store lookup using `store()` will
  // return always the same store, because the only parameters we ever pass to it are `workspaceId` and `userId`
  // (by design), which by definition are always the same in the life of the app.

  Object.keys( vars.hotCoreStoreConfig.configStores ).forEach( function( storeName ){

    // Loads the store
    var store = stores( storeName, { workspaceId: globals.workspaceId, userId: globals.userId } );

    // Sets "caching query" for the store to true. This means that hotplate's implementation
    // of cache.js will return cached results when `query()`ed. This is important for config stores,
    // since they are loaded from an in-page variable
    store.cacheQuery = true;

    // Get the config records value from the global variable on the page
    var storeRecords = vars.hotCoreStoreConfig.storeRecords[ storeName ];

    // It's a one-record value: assign its value to the `r` hash (to be returned), and then
    // turn it into an array, ready for setData
    if( store.idProperty == 'userId' || store.idProperty == 'workspaceId' ){
      r[ storeName ] = storeRecords;
      storeRecords = [ storeRecords ];
    }

    // Write the data into the cache (at this point, it's always an array)
    store.memCache.setData( storeRecords );

  });

  // The `r` value (that needs to be kept up-to-date at all times) can become out of sync if
  // another tab, or another user, changes it. Two messages can announce the change of
  // values: `storeRecordUpdate` (a record was updated) and `refreshData` (the tab has expired, the
  // computer was suspended/offline/whatever for longer than N minutes, and the app it HASN'T been
  // receiving the `storeRecordUpdate` messages).


  // `storeRecordUpdate`
  // Subscribe to changes to those records, so that the 'r' variable (representing the current
  // configuration for one-record config stores) always stays current
  //
  topic.subscribe('storeRecordUpdate', function( from, message, remote ){

    // Check that the message is indeed a config store
    if( typeof( r[ message.storeName ] ) !== 'undefined' ){

      // If it's a one-record config store...
      if( typeof( r[ message.storeName].length ) === 'undefined'  ){

        // ...update `r` and issue a configChange/storename
        r[ message.storeName ] = message.object;
        topic.publish('configChange/' + message.storeName, r[ message.storeName ] );
      }
    }
  });


  // `refreshData`
  // Subscribe to refreshData -- when it happens, it means that the application
  // has timed out and stores' cache has been updated. If that's the case,
  // the `r` variable will need to be updated with the values that came from
  // the refreshData message (if they are managed by `r` and are one-record ones)
  //
  topic.subscribe( 'refreshData', function( storeRecords ) {
    Object.keys( storeRecords ).forEach( function( storeName ){
      var storeData = storeRecords[ storeName ];

      // If it's a one-record value, and the storeName is in `r`...
      if( typeof( storeData.length ) === 'undefined' && typeof( r[ storeName ] !== 'undefined' ) ){

        // ...then update `r` and publish the `configChange` event
        r[ storeName ] = storeData;
        topic.publish('configChange/' + storeName, r[ storeName ] );
      }
    });

  });

  return r;

});


