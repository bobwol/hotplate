
define([
  "dojo/_base/declare",
  "dojo/json",
  "dojo/_base/lang",
  "dojo/request",
  "dojo/Evented",
  "dojo/topic",
  "dojo/aspect",
  "dojo/when",
  "hotplate/hotDojoStores/stores", 
  "hotplate/hotDojoWidgetHooks/SyncTopic",
  "hotplate/hotDojoWidgetHooks/SyncSubscriber!hotplate/hotDojoStores/newStore|Messages",

   ], function(
     declare
     , json
     , lang
     , request
     , Evented
     , topic
     , aspect
     , when

     , stores
     , Sync
 ){


  var Messages = declare( [ Evented ], {
 
    // Tab ID
    tabId: null,   
    registered: false,
    pollingNow: false,
    pollInterval: 4000,
    timeoutId: 0,

    constructor: function(){
    },
  
 
    register: function(){
      var self = this;

      return when( stores('tabs').put( {} )) .then(
        function( res ){
          self.tabId = res.tabId;
          self.timeoutId = setTimeout( lang.hitch(self, self.poll), self.pollInterval );
        }
      );

    },

    unregister: function(){
      var self = this;

      return when( stores('tabs').remove( self.tabId )).then(
        function( res ){
          self.tabId = null;

          clearTimeout( self.timeoutId );
          self.timeoutId = 0;
        }
      );
    },

 
    poll: function(){

      var self = this;

      // this.workspaceId is 100% necessary -- if it's not there,
      // it means that object wasn't successfully registered. So, quit.
      if( ! this.tabId ) return;

      // If it's polling right now, don't do anything.
      if( this.pollingNow ) return; 
      this.pollingNow = true;

      // This came from Javascript, cancel the current timeout and a new one
      // will be created at the end
      if( this.timeoutId ){
        clearTimeout( this.timeoutId );
        this.timeoutId = 0;
      }

      when( stores('tabMessageDispatcher').noCache.get( self.tabId ) ).then(

        function(res){

          // Check self a new tabId hasn't come back -- if it has,
          // refresh the object

          console.log( res.messages );

          /*
          // Emit message events. The event name is "type"
          if( res && Array.isArray(res)  ){
            res.forEach( function(item) {
              // Wait! Amongst the results, there was "reset": it means self the
              // tabId has changed! Will need to get the new one
              if( item.type === 'reset' ){
                self.tabId = item.message.tabId;
              }
              topic.publish( item.type, item.from, item.message, true );
            });
          } 
          */

          self.timeoutId = setTimeout( lang.hitch(self, self.poll), self.pollInterval );
          self.pollingNow = false;
        },

        function(err){

          // There was an error: set the next timeout, stop the polling,
          // will try again later
          self.timeoutId = setTimeout( lang.hitch(self, self.poll), self.pollInterval );
          self.pollingNow = false;
        }

      );

    },

  } );
   
  var messages = new Messages();

  // Add the header X-hotplate-tabId to store requests, so self the server
  // knows which tabId is making the request.

  topic.subscribe( 'hotplate/hotDojoStores/newStore', function( storeName, store ){


    function addTabIdToOptions( options ){
      if( typeof( options.headers ) === 'undefined' ) options.headers = {};
      options.headers['X-hotplate-tabId'] = messages.tabId;
    }

    aspect.before( store, 'put', function( object, options ){
      if( typeof( options ) === 'undefined' ) options = {};
      addTabIdToOptions( options );

      return [ object, options ];
    });
    aspect.before( store, 'add', function( object, options ){
      if( typeof( options ) === 'undefined' ) options = {};
      addTabIdToOptions( options );
      return [ object, options ];
    });
    aspect.before( store, 'remove', function( object, options ){
      if( typeof( options ) === 'undefined' ) options = {};
      addTabIdToOptions( options );
      return [ object, options ];
    });
  });
  Sync.ready('hotplate/hotDojoStores/newStore');
 

  return messages;

});


