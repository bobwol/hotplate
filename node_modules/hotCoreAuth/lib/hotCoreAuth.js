var dummy
  , path = require('path')
  , hotplate = require('hotplate')
  , declare = require('simpledeclare')

  , e = require('allhttperrors')

  // Stores
  , SimpleSchema = require('simpleschema')
  , MongoSchemaMixin = require('simpleschema/MongoSchemaMixin.js')

  , JsonRestStore = require('jsonreststores')
  , MongoDriverMixin = require('jsonreststores/MongoDriverMixin.js')

  // Passport stuff
  , passport = require('passport')
  , FacebookStrategy = require('passport-facebook').Strategy
  , LocalStrategy = require('passport-local').Strategy

  , hotCoreJsonRestStores = require( 'hotCoreJsonRestStores' )
;

/**
Provides authentication abilities to Hotplate

This module's goal is to do two things.

First of all , it defines all of the stores necessary for authentication. The stores in question are:

* Users. The list of users.
* UserStrategies. The list of strategies set bu that user.
* AuthStrategies. The complete list of auth strategies available
* UserLogins. A store that simply allows the search of username, used by Ajax to check if a username is already taken



@module hotCoreAuth
@main hotCoreAuth
@class hotCoreAuth
@static
*/

// Define store and mongo drivers.

var app = hotplate.app;

var hooks = exports.hotHooks = {}


/**
  Initialisation hook. It creates the basic authentication stores
  (Users, UserStrategies, AuthStrategies, UserLogins) 

  @event init
  @requires hotCoreJsonRestStores
*/

var getStores = exports.getStores = hotplate.cachable( function( done ){

  var stores = {}

  hotCoreJsonRestStores.getJsonRestStoresMixins( function( err, mixins ){
    if( err ){
      done( err );
    } else {

      var Store = declare( [ JsonRestStore, MongoDriverMixin, mixins.StoreMixin ] );
      var Schema = declare( [ SimpleSchema, MongoSchemaMixin, mixins.SchemaMixin ] );

      // ***********************************
      // *** USERS *************************
      // ***********************************
    
      stores.Users = declare( Store, {
    
        // COMMON
        schema: new Schema({
          _id:                 { type: 'id' },
    
          recoverToken:        { type: 'string', searchable: true, searchPartial: false, sortable: false, notempty: true },
          recoverTokenCreated: { type: 'date', searchable: true, searchPartial: false, sortable: false, notempty: true },
    
          // name: { type: 'string', searchable: true, searchPartial: false, sortable: false, notEmpty: true, sharedValidator: 'user', trim: 15 },
        }),
    
        publicURL: '/users/',
    
        storeName:  'users',
        paramIds: [ '_id' ],
    
      });
    
      stores.UserStrategies = declare( Store, {
    
        schema: new Schema({
          _id       :  { type: 'id' },
    
          strategyId:  { type: 'string', required: true, trim: 30 }  ,
          userId:      { type: 'id', required: true },
    
          field1:      { type: 'string', required: false, trim: 255 } ,
          field2:      { type: 'string', required: false, trim: 255 } ,
          field3:      { type: 'string', required: false, trim: 255 } ,
          field4:      { type: 'string', required: false, trim: 255 } ,
        }),
    
        searchSchema: new Schema({
          _id       :  { type: 'id' },
          strategyId:  { type: 'string', trim: 30 }  ,
          userId:      { type: 'id' },
    
          field1:      { type: 'string', trim: 255 } ,
          field2:      { type: 'string', trim: 255 } ,
          field3:      { type: 'string', trim: 255 } ,
          field4:      { type: 'string', trim: 255 } ,
    
        }),
    
    		storeName:  'userStrategies',
    
        // #3
     
        handleGet: true,
        checkPermissionsGet: function( params, body, options, doc, fullDoc, cb ){
          // Only their own strategies
          if( this._req.session.userId != params.userId ) return cb( null, false );
    
          cb( null, true );
        },
    
        handleGetQuery: true,
        checkPermissionsGetQuery: function( params, body, options, cb ){
          // Only their own strategies
          if( this._req.session.userId != params.userId ) return cb( null, false );
          
          // TODO: Don't filter by fieldX
          if( typeof( options.filters ) === 'object' && ( options.filters.field1 || options.filters.field2 || options.filters.field3 || options.filters.field4 )  ){
            cb( null, false );
          }
    
          cb( null, true );
        },
    
        // Make sure that, if the request is from the web, field3 and field4 are out of the equation as
        // they often include nice goodies like passwords etc.
        extrapolateDoc: function( params, body, options, fullDoc, cb ){
          if( ! this.remote ) return cb( null, fullDoc );
    
          // Copy body onto newBody, leaving out fieldX 
          var doc = {};
          for( var i in fullDoc ){
            if( i != 'field3' && i != 'field4' ) doc[ i ] = fullDoc[ i ];
          }
          cb( null, doc );
          
        },
    
    
        handleDelete: true,
        checkPermissionsDelete: function( params, body, options, doc, fullDoc, cb ){
    
          // Only their own strategies
          if( this._req.session.userId != params.userId ) return cb( null, false );
    
          UserStrategies.GetQuery( { filters: { userId: doc.userId } }, function( err, queryDocs, idProperty){
            if( queryDocs.length > 1 ){
              cb( null, true );
            } else {
              cb( null, false );
            }
          });
    
        },
    
        paramIds: [ 'userId', '_id' ],
    
        publicURL: '/user/:userId/strategies/',
    
      });
    
    
      stores.AuthStrategies = declare( JsonRestStore, {
    
        // COMMON
        schema: new Schema({
          strategyId:        { type: 'string', isRequired: true, trim: 30 }  ,
        }),
    
        handlePut: false,
        handlePost: false,
        handleGet: true,
        handleGetQuery: true,
        handleDelete: false,
    
        storeName:  'authStrategies',
        paramIds: [ 'strategyId' ],
    
        driverAllDbFetch: function( params, body, options, cb ){
          var strategies = hotplate.get('hotCoreAuth/strategies');
          var doc;
    
          // No strategies defined in Hotplate, end of story
          if( typeof( strategies ) === 'undefined' ){
            return cb( null, null );     
          }
     
          // Check if the strategy is one of the ones defined in Hotplate
          if( typeof( strategies[ params[ 'strategyId' ] ] ) !== 'undefined' ){
            doc = {}
            doc.strategyId = params[ 'strategyId' ];
          } else {
            doc = null;
          }
    
          // Return whatever was found
          cb( null, doc );
        },
    
        driverGetDbQuery: function( params, body, options, cb ){
          var strategies = hotplate.get('hotCoreAuth/strategies');
          var doc;
          var docs = [];
          
          for( var strategyId in strategies ){
            docs.push( { strategyId: strategyId } );
          }      
          cb( null, docs );
        },
    
        publicURL: '/authStrategies/',
    
      });
    
    
      // This is used so that an applicaton can know in advance if a user login is already taken
      stores.UserLogins = declare( JsonRestStore, {
    
        schema: new Schema({
          login     :  { type: 'string', required: true, lowercase: true, trim: 30, searchable: true },
        }),
    
    		storeName:  'userLogins',
    
        handlePut: false,
        handlePost: false,
        handleGet: false,
        handleGetQuery: true,
        handleDelete: false,
    
        paramIds: [ '_id' ],
    
        driverGetDbQuery: function( params, body, options, cb ){
          
          var self = this;
    
          UserStrategies.GetQuery( { filters: { strategyId: 'local', field1: options.filters.login } }, function( err, res ){
            if( err ){
              cb( err, null );
            } else {
              if( res.length ){
                self.schema.makeId( res, function( err, id ){
                  cb( null, [ { login: options.filters.login, _id: id } ] );
                });
              } else {
                cb( null, [ ] );
              }
            }
          });      
    
        },   
    
        publicURL: '/userLogins/',
    
      });
    
    
      done( null, stores );
    }
  });

})

/**
Sets recover URL `/recover/:recoverToken` (for token recovery).  
Also goes through the list of `AuthStrategies`, loads the right
files in `auth/{strategy name}.js` (e.g. {{#crossLink "hotCoreAuth.facebook"}}{{/crossLink}}), and runs them.
This basically ensures that all strategies have the right URLs all set for them to work.

@event run
*/
hooks.run = function( done ){

  getStores( function( err, stores ){
    if( err ){
      done( err );
    } else {


      app.get('/recover/:recoverToken', function( req, res, next ){
    
        stores.Users.GetQuery( { filters: { recoverToken: req.params[ 'recoverToken' ] } }, function( err, result ){
          if( err ){
            done( err, null );
          } else {
            if( result.length == 0 ){
              // Error page
    
              // Artificially create a TokenInvalid error, and next( err ) it 
              var error = new Error();
              error.name = "TokenInvalidError";
              error.message = "Token not valid!";
              req.hotError = error;
              next( error );
    
              // hotplate.get('errorPage')(req, res, next);
            } else {
            
              var user = result[0];
    
              if( ! user.recoverTokenCreated ){
    
                // Artificially create a TokenDateInvalid error, and next( err ) it 
                var error = new Error();
                error.name = "TokenDateInvalidError";
                error.message = "Token date invalid!";
                req.hotError = error;
                next( error );
    
                // hotplate.get('errorPage')(req, res, next);
              } else {
    
                // Get the important variables 
                var tokenAgeInSeconds = Math.round( ( (new Date() ) - user.recoverTokenCreated ) / 1000 );
                var recoverURLexpiry = hotplate.get( 'hotCoreAuth' ).recoverURLexpiry || 300; 
    
                var tokenIsGood = tokenAgeInSeconds < recoverURLexpiry;
    
                if( ! tokenIsGood ){
    
                  // Artificially create a TokenExpired error, and next( err ) it 
                  var error = new Error();
                  error.name = "TokenExpiredError";
                  error.message = "Token expired!";
                  req.hotError = error;
                  next( error );
    
                  // hotplate.get('errorPage')(req, res, next);
                } else {
    
                  delete user.recoverToken;
                  delete user.recoverTokenCreated;
    
                  stores.Users.Put( user._id, user, function( err, userNew ){
                    if( err ){
                      next( err );
                    } else {
    
                      // Log the user in using the token!
                      req.session.loggedIn = true;
                      req.session.userId = user._id;
    
                      // Redirect to the right URL
                      var redirectURLs = hotplate.get('hotCoreAuth/redirectURLs/success');
                      res.redirect( redirectURLs['recover' ] || '/' );
                    }
      
                  });
                }
                 
    
              }
              
            }
              
          }
        });
    
    
      }); 
    
    
    
      function makeResponder( req, res, next, strategyId, action ) {
    
        return function(err, user, profile ) {
    
          var responseType, strategies;
            
          // #2      
    
          var k = req.cookies[ strategyId + '-' + action ];
          if( typeof( k ) !== 'undefined' ){
            responseType = k;
          }
    
          // Fallback option
          if( ! responseType ) responseType = 'redirect';
    
          // Defaults to an empty profile object
          if( typeof( profile ) === 'undefined' ){
            profile = {};
          }
    
          // Error: just return/next that
          if( err ) { return next( err ); }
    
          // #1
    
          switch( responseType ){
    
            case 'content':
    
                // Work out the page's content by calling the user-set hotCoreAuth/responsePage function
                // Note: if hotCoreAuth/responsePage is not set, it will use a placeholder fallback string
                var content;
                var contentFunction = hotplate.get( 'hotCoreAuth/responsePage' );
                if( typeof( contentFunction ) === 'function' ){
                  content = contentFunction( strategyId, action, user, profile );
                } else {
                  content = "PLEASE SET hotCoreAuth/responsePage IN YOUR SERVER FILE TO CUSTOMIZE CONTENTS";
                }
    
    
                // Send the contents
                res.send( content );      
            break;
    
    
    
            case 'close':
    
              if( ! user && typeof( profile.message) !== 'undefined'  ){
                
                // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
                res.send('<html><script>window.opener.alert("' + profile.message + '");window.close();</script></html>');      
              } else {
                res.send('<html><script>window.close();</script></html>');      
              }
            break;
    
            case 'ajax':
    
              if( user ){
                res.json( 200, { user: user, profile: profile } );
              } else {
                var error = 'Authentication error';
                if( typeof( profile.message) !== 'undefined' ) error =  profile.message;
                res.json( 403, { message: error } );
              }
    
            break;
    
    
            case 'redirect-opener':
    
              if( ! user && typeof( profile.message) !== 'undefined'  ){
    
                // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
                res.send('<html><script>window.opener.alert("' + profile.message + '");window.close();</script></html>');      
                
              } else {
                var redirectURLs = hotplate.get('hotCoreAuth/redirectURLs/success') || {};
                var redirectURL = redirectURLs[ action ] || '/' ;
                console.log( "SUCCESS URL:" );
                console.log( redirectURL );
                res.send('<html><script>window.opener.location = "' + redirectURL + '";window.close();</script></html>');      
              }
            break;
    
    
            case 'redirect':
            default:
    
              if( user ){
    
                var redirectURLs = hotplate.get('hotCoreAuth/redirectURLs/success') || {};
                res.redirect( redirectURLs[ action ] || '/' );
              } else {
    
                // Add the error to the session messages
                if( typeof( profile.message) !== 'undefined'  ){
                  req.session.messages = req.session.messages || []; 
                  req.session.messages.push( { type: 'error', message: profile.message } );
                }
    
                var redirectURLs = hotplate.get('hotCoreAuth/redirectURLs/fail');
                res.redirect( redirectURLs[ action ] || '/' );
              }
            break;
    
          }
    
        }
      }
    
      if( typeof( hotplate.get('hotCoreAuth/strategies' )) === 'object' ){
        Object.keys( hotplate.get('hotCoreAuth/strategies' )).forEach( function( strategyName ) {
        
          // Get the strategy's data
          var strategyConfig = hotplate.get('hotCoreAuth/strategies' )[strategyName];
    
          // Gets the right strategy maker and runs it
          strategyMaker = require( './auth/' + strategyName );
          strategyMaker( strategyConfig, makeResponder, stores.AuthStrategies, stores.Users, stores.UserStrategies, stores.UserLogins );
        });
    
      }
    
      done( null );
    }
  });

}


hooks.stores = function( done ){

  getStores( function( err, stores ){
    if( err ){
      done( err );
    } else {

      done( null,  {
        moduleName: 'hotCoreAuth', result: [ stores.Users, stores.UserStrategies, stores.AuthStrategies, stores.UserLogins ]
      });
    }
  })
}


hooks.pageElements = function( done ){
  var strategyIds = Object.keys( hotplate.get('hotCoreAuth/strategies') ) || [];
  
  done( null, { moduleName: 'hotCoreAuth', result: {
    vars:  [
             { name: 'strategyIds',  value: strategyIds },
             { name: 'successURLs',  value: hotplate.get('hotCoreAuth/redirectURLs/success') },
             { name: 'failURLs',     value: hotplate.get('hotCoreAuth/redirectURLs/fail') },
           ],
  } } );
}


hooks.pageElementsPerPage = function( elements, req, pageName, done ){

  var vars = [];

  // Add the user ID to the page as a variable
  if( req.session.userId ) {
    vars.push( { name: 'userId', value: req.session.userId } );
  }

  // Add the successURL/failURLs objects, needed by authentication modules (such as hotDojoAuth)
  //vars.push( { name: 'successURLs', value: hotplate.get('hotCoreAuth/redirectURLs/success') } );
  //vars.push( { name: 'failURLs', value: hotplate.get('hotCoreAuth/redirectURLs/fail') } );
  //vars.push( { name: 'multiHomeURL', value: hotplate.get('hotCoreAuth').multiHomeURL } );

  done( null, { moduleName: 'hotCoreAuth', result: {
    vars: vars 
  } } );

}


