var dummy
  , path = require('path')
  , hotplate = require('hotplate')
  , declare = require('simpledeclare')

  , e = require('allhttperrors')

  // Stores
  , Schema = require('simpleschema')
  , MongoSchemaMixin = require('simpleschema/MongoSchemaMixin.js')

  , Store = require('jsonreststores')
  , MongoDriverMixin = require('jsonreststores/MongoDriverMixin.js')

  // Passport stuff
  , passport = require('passport')
  , FacebookStrategy = require('passport-facebook').Strategy
  , LocalStrategy = require('passport-local').Strategy
;



// Define store and mongo drivers.

var app = hotplate.app;

var hooks = exports.hotHooks = {}



hooks.init = function( done ){

  var hotCoreJsonRestStores = hotplate.getModule( 'hotCoreJsonRestStores' );

  Store = declare( [ Store, MongoDriverMixin, hotCoreJsonRestStores.StoreMixin ] );
  Schema = declare( [ Schema, MongoSchemaMixin, hotCoreJsonRestStores.SchemaMixin ] );

  BasicStore = require('jsonreststores');


  // ***********************************
  // *** USERS *************************
  // ***********************************

  exports.Users = declare( Store, {

    // COMMON
    schema: new Schema({
      _id:                 { type: 'id' },

      recoverToken:        { type: 'string', searchable: true, searchPartial: false, sortable: false, notempty: true },
      recoverTokenCreated: { type: 'date', searchable: true, searchPartial: false, sortable: false, notempty: true },

      // name: { type: 'string', searchable: true, searchPartial: false, sortable: false, notEmpty: true, sharedValidator: 'user', trim: 15 },
    }),

    // #4
    publicURL: '/users/',

    storeName:  'users',
    paramIds: [ '_id' ],

  });

  // Users.onlineAll( app, '/users/', ':_id' );

  var UserStrategies = exports.UserStrategies = declare( Store, {

    schema: new Schema({
      _id       :  { type: 'id' },

      strategyId:  { type: 'string', required: true, trim: 30 }  ,
      userId:      { type: 'id', required: true },

      field1:      { type: 'string', required: false, trim: 255 } ,
      field2:      { type: 'string', required: false, trim: 255 } ,
      field3:      { type: 'string', required: false, trim: 255 } ,
      field4:      { type: 'string', required: false, trim: 255 } ,
    }),

    searchSchema: new Schema({
      _id       :  { type: 'id' },
      strategyId:  { type: 'string', trim: 30 }  ,
      userId:      { type: 'id' },

      field1:      { type: 'string', trim: 255 } ,
      field2:      { type: 'string', trim: 255 } ,
      field3:      { type: 'string', trim: 255 } ,
      field4:      { type: 'string', trim: 255 } ,

    }),

		storeName:  'userStrategies',

    // #3
 
    handleGet: true,
    checkPermissionsGet: function( params, body, options, doc, fullDoc, cb ){
      // Only their own strategies
      if( this._req.session.userId != params.userId ) return cb( null, false );

      cb( null, true );
    },

    handleGetQuery: true,
    checkPermissionsGetQuery: function( params, body, options, cb ){
      // Only their own strategies
      if( this._req.session.userId != params.userId ) return cb( null, false );
      
      // TODO: Don't filter by fieldX
      if( typeof( options.filters ) === 'object' && ( options.filters.field1 || options.filters.field1 || options.filters.field3 || options.filters.field4 )  ){
        cb( null, false );
      }

      cb( null, true );
    },

    // Make sure that, if the request is from the web, field3 and field4 are out of the equation as
    // they often include nice goodies like passwords etc.
    extrapolateDoc: function( params, body, options, fullDoc, cb ){
      if( ! this.remote ) return cb( null, fullDoc );

      // Copy body onto newBody, leaving out fieldX 
      var doc = {};
      for( var i in fullDoc ){
        if( i != 'field3' && i != 'field4' ) doc[ i ] = fullDoc[ i ];
      }
      cb( null, doc );
      
    },


    handleDelete: true,
    checkPermissionsDelete: function( params, body, options, doc, fullDoc, cb ){

      // Only their own strategies
      if( this._req.session.userId != params.userId ) return cb( null, false );

      UserStrategies.GetQuery( { filters: { userId: doc.userId } }, function( err, queryDocs, idProperty){
        if( queryDocs.length > 1 ){
          cb( null, true );
        } else {
          cb( null, false );
        }
      });

    },

    paramIds: [ 'userId', '_id' ],

    publicURL: '/user/:userId/strategies/',

  });

  // UserStrategies.onlineAll( app, '/user/:userId/strategies/', ':_id' );


  var AuthStrategies = exports.AuthStrategies = declare( BasicStore, {

    // COMMON
    schema: new Schema({
      strategyId:        { type: 'string', isRequired: true, trim: 30 }  ,
    }),

    handlePut: false,
    handlePost: false,
    handleGet: true,
    handleGetQuery: true,
    handleDelete: false,

    storeName:  'authStrategies',
    paramIds: [ 'strategyId' ],

    driverAllDbFetch: function( params, body, options, cb ){
      var strategies = hotplate.get('hotCoreAuth/strategies');
      var doc;

      // No strategies defined in Hotplate, end of story
      if( typeof( strategies ) === 'undefined' ){
        return cb( null, null );     
      }
 
      // Check if the strategy is one of the ones defined in Hotplate
      if( typeof( strategies[ params[ 'strategyId' ] ] ) !== 'undefined' ){
        doc = {}
        doc.strategyId = params[ 'strategyId' ];
      } else {
        doc = null;
      }

      // Return whatever was found
      cb( null, doc );
    },

    driverGetDbQuery: function( params, body, options, cb ){
      var strategies = hotplate.get('hotCoreAuth/strategies');
      var doc;
      var docs = [];
      
      for( var strategyId in strategies ){
        docs.push( { strategyId: strategyId } );
      }      
      cb( null, docs );
    },

    publicURL: '/authStrategies/',

  });

  //AuthStrategies.onlineAll( app, '/authStrategies/', ':strategyId' );


  // This is used so that an applicaton can know in advance if a user login is already taken
  var UserLogins = exports.UserLogins = declare( BasicStore, {

    schema: new Schema({
      login     :  { type: 'string', required: true, lowercase: true, trim: 30, searchable: true },
    }),

		storeName:  'userLogins',

    handlePut: false,
    handlePost: false,
    handleGet: false,
    handleGetQuery: true,
    handleDelete: false,

    paramIds: [ '_id' ],

    driverGetDbQuery: function( params, body, options, cb ){
      
      var self = this;

      UserStrategies.GetQuery( { filters: { strategyId: 'local', field1: options.filters.login } }, function( err, res ){
        if( err ){
          cb( err, null );
        } else {
          if( res.length ){
            self.schema.makeId( res, function( err, id ){
              cb( null, [ { login: options.filters.login, _id: id } ] );
            });
          } else {
            cb( null, [ ] );
          }
        }
      });      

    },   

    publicURL: '/userLogins/',

  });

  //UserLogins.onlineAll( app, '/userLogins/', ':_id' );




  done( null );
}
hooks.init.after = [ 'hotCoreJsonRestStores' ];

hooks.run = function( done ){

  

  app.get('/recover/:recoverToken', function( req, res, next ){

    exports.Users.GetQuery( { filters: { recoverToken: req.params[ 'recoverToken' ] } }, function( err, result ){
      if( err ){
        done( err, null );
      } else {
        if( result.length == 0 ){
          // Error page

          // Artificially create a TokenInvalid error, and next( err ) it 
          var error = new Error();
          error.name = "TokenInvalidError";
          error.message = "Token not valid!";
          req.hotError = error;
          next( error );

          // hotplate.get('errorPage')(req, res, next);
        } else {
        
          var user = result[0];

          if( ! user.recoverTokenCreated ){

            // Artificially create a TokenDateInvalid error, and next( err ) it 
            var error = new Error();
            error.name = "TokenDateInvalidError";
            error.message = "Token date invalid!";
            req.hotError = error;
            next( error );

            // hotplate.get('errorPage')(req, res, next);
          } else {

            // Get the important variables 
            var tokenAgeInSeconds = Math.round( ( (new Date() ) - user.recoverTokenCreated ) / 1000 );
            var recoverURLexpiry = hotplate.get( 'hotCoreAuth' ).recoverURLexpiry || 300; 

            var tokenIsGood = tokenAgeInSeconds < recoverURLexpiry;

            if( ! tokenIsGood ){

              // Artificially create a TokenExpired error, and next( err ) it 
              var error = new Error();
              error.name = "TokenExpiredError";
              error.message = "Token expired!";
              req.hotError = error;
              next( error );

              // hotplate.get('errorPage')(req, res, next);
            } else {

              delete user.recoverToken;
              delete user.recoverTokenCreated;

              exports.Users.Put( user._id, user, function( err, userNew ){
                if( err ){
                  next( err );
                } else {

                  // Log the user in using the token!
                  req.session.loggedIn = true;
                  req.session.userId = user._id;

                  // Redirect to the right URL
                  var redirectURLs = hotplate.get('hotCoreAuth/redirectURLs/success');
                  res.redirect( redirectURLs['recover' ] || '/' );
                }
  
              });
            }
             

          }
          
        }
          
      }
    });


  }); 



  function makeResponder( req, res, next, strategyId, action ) {

    return function(err, user, profile ) {

      var responseType, strategies;
        
      // #2      

      var k = req.cookies[ strategyId + '-' + action ];
      if( typeof( k ) !== 'undefined' ){
        responseType = k;
      }

      // Fallback option
      if( ! responseType ) responseType = 'redirect';

      // Defaults to an empty profile object
      if( typeof( profile ) === 'undefined' ){
        profile = {};
      }

      // Error: just return/next that
      if( err ) { return next( err ); }

      // #1

      switch( responseType ){

        case 'content':

            // Work out the page's content by calling the user-set hotCoreAuth/responsePage function
            // Note: if hotCoreAuth/responsePage is not set, it will use a placeholder fallback string
            var content;
            var contentFunction = hotplate.get( 'hotCoreAuth/responsePage' );
            if( typeof( contentFunction ) === 'function' ){
              content = contentFunction( strategyId, action, user, profile );
            } else {
              content = "PLEASE SET hotCoreAuth/responsePage IN YOUR SERVER FILE TO CUSTOMIZE CONTENTS";
            }


            // Send the contents
            res.send( content );      
        break;



        case 'close':

          if( ! user && typeof( profile.message) !== 'undefined'  ){
            
            // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
            res.send('<html><script>window.opener.alert("' + profile.message + '");window.close();</script></html>');      
          } else {
            res.send('<html><script>window.close();</script></html>');      
          }
        break;

        case 'ajax':

          if( user ){
            res.json( 200, { user: user, profile: profile } );
          } else {
            var error = 'Authentication error';
            if( typeof( profile.message) !== 'undefined' ) error =  profile.message;
            res.json( 403, { message: error } );
          }

        break;


        case 'redirect-opener':

          if( ! user && typeof( profile.message) !== 'undefined'  ){

            // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
            res.send('<html><script>window.opener.alert("' + profile.message + '");window.close();</script></html>');      
            
          } else {
            var redirectURLs = hotplate.get('hotCoreAuth/redirectURLs/success') || {};
            var redirectURL = redirectURLs[ action ] || '/' ;
            console.log( "SUCCESS URL:" );
            console.log( redirectURL );
            res.send('<html><script>window.opener.location = "' + redirectURL + '";window.close();</script></html>');      
          }
        break;


        case 'redirect':
        default:

          if( user ){

            var redirectURLs = hotplate.get('hotCoreAuth/redirectURLs/success') || {};
            res.redirect( redirectURLs[ action ] || '/' );
          } else {

            // Add the error to the session messages
            if( typeof( profile.message) !== 'undefined'  ){
              req.session.messages = req.session.messages || []; 
              req.session.messages.push( { type: 'error', message: profile.message } );
            }

            var redirectURLs = hotplate.get('hotCoreAuth/redirectURLs/fail');
            res.redirect( redirectURLs[ action ] || '/' );
          }
        break;

      }

    }
  }

  if( typeof( hotplate.get('hotCoreAuth/strategies' )) === 'object' ){
    Object.keys( hotplate.get('hotCoreAuth/strategies' )).forEach( function( strategyName ) {
    
      // Get the strategy's data
      var strategyConfig = hotplate.get('hotCoreAuth/strategies' )[strategyName];

      // Gets the right strategy maker and runs it
      strategyMaker = require( './auth/' + strategyName );
      strategyMaker( strategyConfig, makeResponder, exports.AuthStrategies, exports.Users, exports.UserStrategies, exports.UserLogins );
    });

  }

  done( null );

}


hooks.stores = function( done ){

  done( null,  {
    moduleName: 'hotCoreAuth', result: [ exports.Users, exports.UserStrategies, exports.AuthStrategies, exports.UserLogins ]
  });

}

hooks.pageElements = function( done ){
  var strategyIds = Object.keys( hotplate.get('hotCoreAuth/strategies') ) || [];
  
  done( null, { moduleName: 'hotCoreAuth', result: {
    vars:  [
             { name: 'strategyIds',  value: strategyIds },
             { name: 'successURLs',  value: hotplate.get('hotCoreAuth/redirectURLs/success') },
             { name: 'failURLs',     value: hotplate.get('hotCoreAuth/redirectURLs/fail') },
           ],
  } } );
}


hooks.pageElementsPerPage = function( done, elements, req, pageName ){

  var vars = [];

  // Add the user ID to the page as a variable
  if( req.session.userId ) {
    vars.push( { name: 'userId', value: req.session.userId } );
  }

  // Add the successURL/failURLs objects, needed by authentication modules (such as hotDojoAuth)
  //vars.push( { name: 'successURLs', value: hotplate.get('hotCoreAuth/redirectURLs/success') } );
  //vars.push( { name: 'failURLs', value: hotplate.get('hotCoreAuth/redirectURLs/fail') } );
  //vars.push( { name: 'multiHomeURL', value: hotplate.get('hotCoreAuth').multiHomeURL } );

  done( null, { moduleName: 'hotCoreAuth', result: {
    vars: vars 
  } } );

}



/*

#1

      // If a user was actually created, call the appropriate callback if it's needed
      if( user ){
        hotplate.invokeAll('hotCoreAuth/userRegistered', user, function(){} );
      }

#2
      // If it was passed by a body parameter, then listen to it
      //if( typeof( req.body.responseType ) !== 'undefined' ){
      if( false ){
        responseType = req.body.responseType;

        console.log("GOT responseType FROM FORM!");

      // Otherwise, try to get it from a cookie
      } else {
        var k = req.cookies[ strategyId + '-' + action ];
        if( typeof( k ) !== 'undefined' ){
          responseType = k;
        }

      }



*/



    // #3
    /*
    // Put is managed to "save" strategy data (for strategies that store something in fields)
    handlePut: true,
    checkPermissionsPutExisting: function( params, body, options, doc, fullDoc, cb ){
      // Only their own strategies
      if( this._req.session.userId != params.userId ) return cb( null, false );
      cb( null, true );
    },
    checkPermissionsPutNew: function( params, body, options, cb ){
      // Only their own strategies
      if( this._req.session.userId != params.userId ) return cb( null, false );
      cb( null, true );
    },

    */

    // #4
     /*
    handlePut: true,
    checkPermissionsPutNew: function( params, body, options, cb ){
      if( params._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },
    checkPermissionsPutExisting: function( params, body, options, doc, fullDoc, cb ){
      if( doc._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },

    handlePost: true,
    checkPermissionsPost: function( params, body, options, cb ){
      if( params._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },

    handleGet: true,
    checkPermissionsGet: function( params, body, options, cb ) {
      if( doc._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },

    handleDelete: true,
    checkPermissionsDelete: function( params, body, options, doc, fullDoc, cb ){
      if( doc._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },
    */



