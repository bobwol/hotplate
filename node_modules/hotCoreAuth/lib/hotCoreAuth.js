var dummy
  , path = require('path')
  , hotplate = require('hotplate')

  , ObjectId = require('mongowrapper').ObjectId
  , checkObjectId = require('mongowrapper').checkObjectId

  , hat = require('hat')

  , bcrypt = require('bcrypt')
  , SALT_WORK_FACTOR = 15
  , db = hotplate.get('db')
  , e = require('allhttperrors')

  , Schema = require('simpleschema')
  , MongoSchemaMixin = require('simpleschema/MongoSchemaMixin.js')

  , Store = require('jsonreststores')
  , MongoDriverMixin = require('jsonreststores/MongoDriverMixin.js')

  , declare = require('simpledeclare')
  , passport = require('passport')
  , FacebookStrategy = require('passport-facebook').Strategy
  , LocalStrategy = require('passport-local').Strategy
;



// Define store and mongo drivers.

var app = hotplate.app;

var hooks = exports.hotHooks = {}


hooks.init = function( done ){

  done( null );
}


hooks.run = function( done ){

  var hotCoreJsonRestStores = hotplate.getModule( 'hotCoreJsonRestStores' );

  Store = declare.mixin( Store, [ MongoDriverMixin, hotCoreJsonRestStores.StoreMixin ] );
  Schema = declare.mixin( Schema, [ MongoSchemaMixin, hotCoreJsonRestStores.SchemaMixin ] );

  BasicStore = require('jsonreststores');

  // ***********************************
  // *** USERS *************************
  // ***********************************

  var Users = declare( Store, {

    // COMMON
    schema: new Schema({
      _id: { type: 'id' },

      name: { type: 'string', searchable: true, searchPartial: false, sortable: false, notEmpty: true, sharedValidator: 'user', trim: 15 },
    }),

    handlePut: true,
    handlePost: true,
    handleGet: true,
    handleGetQuery: true,
    handleDelete: true,

    storeName:  'Users',
    paramIds: [ '_id' ],
  });

  Users.onlineAll( app, '/users/', ':_id' );

  // ***********************************
  // *** WORKSPACES ********************
  // ***********************************


  var Workspaces = declare( Store, {

    // COMMON
    schema: new Schema({
      _id: { type: 'id' },
      workspaceName: { type: 'string', searchable: true, searchPartial: false,
                       sortable: false, notEmpty: true, sharedValidator: 'workspace', trim: 20 },
    }),

    handlePut: true,
    handlePost: true,
    handleGet: true,
    handleGetQuery: true,
    handleDelete: true,

    storeName:  'Workspaces',
    paramIds: [ '_id' ],
  });

  Users.onlineAll( app, '/workspaces/', ':_id' );


  // The basic schema for the WorkspaceUsers table
  var WorkspacesUsersBase = declare( Store, {

    schema: new Schema({
      userId:      { type: 'id' },
      workspaceId: { type: 'id' },
      _id:         { type: 'id' },
    }),

    collectionName: 'WorkspacesUsers',
    paramIds: [ '_id' ],
  });


  var WorkspaceUsers = declare( WorkspacesUsersBase, {
    handlePut: false,
    handlePost: true,
    handleGet: false,
    handleGetQuery: true,
    handleDelete: true,

    searchSchema: new Schema({
      workspaceId: { type: 'id' },
      userId:      { type: 'id' },
      _id:         { type: 'id' },
    }),

    storeName:  'WorkspaceUsers',
    paramIds: [ 'workspaceId', '_id' ],
  });
  WorkspaceUsers.onlineAll( app, '/workspaceUsers/:workspaceId/', ':_id' );

  var UserWorkspaces = declare( WorkspacesUsersBase, {

    handlePut: false,
    handlePost: true,
    handleGet: true,
    handleGetQuery: true,
    handleDelete: true,

    searchSchema: new Schema({
      userId:      { type: 'id' },
      workspaceId: { type: 'id' },
      _id:         { type: 'id' },
    }),

    storeName:  'UserWorkspaces',
    paramIds: [ 'userId', '_id' ],
  });

  UserWorkspaces.onlineAll( app, '/userWorkspaces/:userId/', '_id' );

  
  // ***********************************
  // *** AUTH ********************
  // ***********************************


  var UserStrategies = declare( Store, {

    schema: new Schema({
      _id       :  { type: 'id' },
      strategyId:  { type: 'string', required: true, trim: 30 }  ,
      userId:      { type: 'id', required: true },

      field1:      { type: 'string', required: false, trim: 255 } ,
      field2:      { type: 'string', required: false, trim: 255 } ,
      field3:      { type: 'string', required: false, trim: 255 } ,
      field4:      { type: 'string', required: false, trim: 255 } ,
    }),

    searchSchema: new Schema({
      _id       :  { type: 'id' },
      strategyId:  { type: 'string', trim: 30 }  ,
      userId:      { type: 'id' },

      field1:      { type: 'string', trim: 255 } ,
      field2:      { type: 'string', trim: 255 } ,
      field3:      { type: 'string', trim: 255 } ,
      field4:      { type: 'string', trim: 255 } ,

    }),

		storeName:  'UserStrategies',

    handlePut: true,
    handlePost: false,
    handleGet: true,
    handleGetQuery: true,
    handleDelete: true,

    paramIds: [ 'userId', '_id' ],
  });

  UserStrategies.onlineAll( app, '/userStrategies/:userId/', ':_id' );


  var AuthStrategies = declare( BasicStore, {

    // COMMON
    schema: new Schema({
      strategyId:        { type: 'string', isRequired: true, trim: 30 }  ,
    }),

    handlePut: false,
    handlePost: false,
    handleGet: true,
    handleGetQuery: true,
    handleDelete: false,

    storeName:  'AuthStrategies',
    paramIds: [ 'strategyId' ],

    driverAllDbFetch: function( params, body, options, cb ){
      var strategies = hotplate.get('hotCoreAuth/strategies');
      var doc;

      // No strategies defined in Hotplate, end of story
      if( typeof( strategies ) === 'undefined' ){
        return cb( null, null );     
      }
 
      // Check if the strategy is one of the ones defined in Hotplate
      if( typeof( strategies[ params[ 'strategyId' ] ] ) !== 'undefined' ){
        doc = {}
        doc.strategyId = params[ 'strategyId' ];
      } else {
        doc = null;
      }

      // Return whatever was found
      cb( null, doc );
    },

    driverGetDbQuery: function( params, body, options, cb ){
      var strategies = hotplate.get('hotCoreAuth/strategies');
      var doc;
      var docs = [];
      
      for( var strategyId in strategies ){
        docs.push( { strategyId: strategyId } );
      }      
      cb( null, docs );
    },

  });

  AuthStrategies.onlineAll( app, '/authStrategies/', ':strategyId' );


  // ***********************************
  // *** AUTH ********************
  // ***********************************



  var UserLogins = declare( BasicStore, {

    schema: new Schema({
      login     :  { type: 'string', required: true, lowercase: true, trim: 30 },

    }),

		storeName:  'login',

    handlePut: false,
    handlePost: false,
    handleGet: false,
    handleGetQuery: true,
    handleDelete: false,

    paramIds: [ 'login' ],

    driverGetDbQuery: function( params, body, options, cb ){
      
      var self = this;

      UserStrategies.GetQuery( { filters: { strategyId: 'local', field1: options.filters.login } }, function( err, res ){
        if( err ){
          cb( err, null );
        } else {
          if( res.length ){
            self.makeId( res, function( err, id ){
              cb( null, [ { login: options.filters.login, _id: id } ] );
            });
          } else {
            cb( null, [ ] );
          }
        }
      });      

    },   

  });

  UserLogins.onlineAll( app, '/userLogins/', ':_id' );



  function makeResponder( req, res, next, strategyId ) {

    return function(err, user, profile ) {

      var responseType, strategies;
        
      // If it was passed by a body parameter, then listen to it
      if( typeof( req.body.responseType ) !== 'undefined' ){
        responseType = req.body.responseType;

      // Otherwise, try to get it from the config options
      } else {

        // Set the responseType, defaulting to "redirect"
        strategies =  hotplate.get('hotCoreAuth/strategies');
        if( strategies && strategies[ strategyId ] && strategies[ strategyId ].responseType ){
          responseType = strategies[ strategyId ].responseType;
        }
      }

      // Fallback option
      if( ! responseType ) responseType = 'redirect';

      // Defaults to an empty profile object
      if( typeof( profile ) === 'undefined' ){
        profile = {};
      }

      /*
      console.log("AUTHENTICATING IN MADE RESPONDER (strategyId): ");

      console.log("user: ");
      console.log( user );
            
      console.log("profile: ");
      console.log( profile );

      console.log("responseType: ");
      console.log( responseType );
      */

      // Error: just return that
      if( err ) { return next( err ); }


      console.log( user );
      console.log("PROFILE");
      console.log( profile );



      switch( responseType ){

        case 'close':
          console.log("METHOD: CLOSE");
          if( ! user && typeof( profile.message) !== 'undefined'  ){
            req.session.messages = req.session.messages || []; 
            req.session.messages.push( { type: 'error', message: profile.message } );
          }
          res.send('<script>window.close();</script></html>');      
        break;

        case 'ajax':
          console.log("METHOD: AJAX");
          if( user ){
            res.json( 200, { user: user, profile: profile } );
          } else {
            var error = 'Authentication error';
            if( typeof( profile.message) !== 'undefined' ) error =  profile.message;
            res.json( 403, { message: error } );
          }

        break;

        case 'redirect':
        default:
          console.log("METHOD: REDIRECT");
          if( user ){
            res.redirect( hotplate.get('hotCoreAuth/redirectToSuccess') || '/' );
          } else {

            // Add the error to the session messages
            if( typeof( profile.message) !== 'undefined'  ){
              req.session.messages = req.session.messages || []; 
              req.session.messages.push( { type: 'error', message: profile.message } );
            }

            res.redirect( hotplate.get('hotCoreAuth/redirectToFailure') || '/login' );
          }
        break;

      }

    }
  }



  if( typeof( hotplate.get('hotCoreAuth')) === 'object' ){
    var callbackURLBase = hotplate.get('hotCoreAuth').callbackURLBase;
  }
  
  if( typeof( hotplate.get('hotCoreAuth/strategies' )) === 'object' ){
    Object.keys( hotplate.get('hotCoreAuth/strategies' )).forEach( function( k ) {
    
      var strategy = hotplate.get('hotCoreAuth/strategies' )[k];
 
      switch( k ){

        case 'local':

          // Local auth
          passport.use(new LocalStrategy({
            passReqToCallback: true,
            usernameField: 'login',
          },

          function(req, login, password, done) {


            console.log(" AND REQ IS: ");
            console.log( req );

            // **************************************************
            // ** NOT LOGGED IN:    attempts to create an account
            // **************************************************
            if( ! req.session.loggedIn ){

              done( null, false );

/*
             p = (Math.PI * Math.max(0.01, Math.random())).toString(36).substr(2, 5) ;
              profile.username + ' ' + p;

              var randomCrap = (Math.PI * Math.max(0.01, Math.random())).toString(36).substr(2, 5);
              Users.Post( { userName: profile.username + '_' + randomCrap }, { }, function( err, res, idProperty ){
                if( err ){
                  done( err, false, null );
                } else {
                 
                  UserStrategies.Post( { strategy: 'facebook', field1: accessToken }, { user: res[ idProperty ] }, function( err, res, idProperty ){
                    if( err ) {
                      done( err, null );
                    } else {
                      done( null, res[ idProperty ], profile  );
                    }
                  });
                }

              });

              */


            // **************************************************
            // ** USER LOGGED IN: will add it to the list of
            //    "allowed" identities
            // **************************************************

            } else {

              // Check that there isn't one already there
              UserStrategies.GetQuery( { filters: { userId: req.session.userId, strategyId: 'local' } }, function( err, res, idProperty ){
                if( err ) {
                  done( err, null );
                } else {
                  if( res.length ){

                    var itsEdit = true;
                    var foundStrategyId = res[0][idProperty];
                    console.log("It's an EDIT of: " + foundStrategyId );
                  }

                  UserStrategies.GetQuery( { filters: { field1: login.toLowerCase() } }, function( err, res, idProperty ){
                    if( err ) {
                      done( err, null );
                    } else {
                      var editingSelf = false;
                      // p.o.r=10; // FIXME: Figure out why stack trace goes MAD here
                      if( res.length > 0 ){
                        editingSelf = ( itsEdit == true && res[0][idProperty].toString() == foundStrategyId.toString()  );
                      }

                      if( res.length > 0 && !editingSelf ){
                        done( null, false, { message: "Login name taken!" } );
                      } else {

                        // It's an edit: overwrite existing values
                        if( itsEdit ){

                          UserStrategies.Put( foundStrategyId, { userId: req.session.userId, strategyId: 'local', field1: login.toLowerCase(), field2: password }, function( err, res, idProperty ){
                            if( err ) {
                              done( err, null );
                            } else {
                              complete( res[ idProperty ] );
                            }
                          });
 

                        // It's a new entry: add a new record
                        } else {

                          UserStrategies.Post( { userId: req.session.userId, strategyId: 'local', field1: login.toLowerCase(), field2: password }, function( err, res, idProperty ){
                            if( err ) {
                              done( err, null );
                            } else {
                              complete( res[ idProperty ] );
                            }
                          });
                        }
                        function complete( userStrategiesId ){
                          Users.Get( req.session.userId, function( err, user ){
                            if( err ){
                              done( err, null );
                            } else {
                              user.userStrategiesId = userStrategiesId;
                              done( null, user, {}  );
                            }
                          });


                        }
                      }
                    } 
                  });
                }
              });
            }
          }
          ));

          app.post('/auth/add/local', function( req, res, next) {
            passport.authenticate('local',  makeResponder( req, res, next, 'local')  )(req, res, next);
          });
          
        break;



        case 'facebook':

          // Facebook auth
          passport.use(new FacebookStrategy({
            clientID: strategy.clientID,
            clientSecret: strategy.clientSecret,
            callbackURL: callbackURLBase + "/auth/add/facebook/callback",
            passReqToCallback: true,
          },

          function(req, accessToken, refreshToken, profile, done) {

            // **************************************************
            // ** NOT LOGGED IN:    attempts to create an account
            // **************************************************
            //req.session.loggedIn = false;

            if( ! req.session.loggedIn ){

              var randomCrap = (Math.PI * Math.max(0.01, Math.random())).toString(36).substr(2, 5);
              Users.Post( { name: profile.username + '_' + randomCrap }, function( err, resUser, idProperty ){
                if( err ){
                  done( err, false, null );
                } else {
                 
                  UserStrategies.Post( { userId: resUser[ idProperty ], strategyId: 'facebook', field1: accessToken }, function( err, resUserStrategies, idProperty ){
                    if( err ) {
                      done( err, null );
                    } else {
                      done( null, resUser, profile  );
                    }
                  });
                }

              });



            // **************************************************
            // ** USER LOGGED IN: will add it to the list of
            //    "allowed" identities
            // **************************************************

            } else {

              // Check that "facebook" isn't already there
              UserStrategies.GetQuery( { filters: { userId: req.session.userId, strategyId: 'facebook' } }, function( err, res ){
                if( err ) {
                  done( err, null );
                } else {
                  if( res.length ){
                    done( null, false, { message: "User already has a Facebook login setup" } );
                  } else {
                    UserStrategies.Post( { userId: req.session.userId, strategyId: 'facebook', field1: accessToken }, function( err, res, idProperty ){
                      if( err ) {
                        done( err, null );
                      } else {
                        Users.Get( req.session.userId, function( err, user ){
                          if( err ){
                            done( err, null );
                          } else {
                            done( null, user, profile  );
                          }
                        });
                      }
                    });
                  } 
                }
              });
            }
          }
          ));

          app.get('/auth/add/facebook', passport.authenticate('facebook'));
          app.get('/auth/add/facebook/callback', function( req, res, next) {
            passport.authenticate('facebook',  makeResponder( req, res, next, 'facebook')  )(req, res, next);
          });
          
        break;
      }
 
    });

  }


  done( null );
}

hooks.stores = function( done ){
  done( null, {

    userStrategies     : { target: '/userStrategies/:userId/',         idProperty: '_id', sortParam: 'sortBy', },
    authStrategies     : { target: '/authStrategies/',                 idProperty: 'strategyId', sortParam: 'sortBy', },
    userLogins         : { target: '/userLogins/',                     idProperty: '_id', sortParam: 'sortBy', },


  });
}







/*
hooks.init = function( done ){

  // Middleware parameters that set req.application
  app.param( 'workspaceIdPages', paramWorkspaceIdPages);     // Used by /ws/WORKSPACEID
  app.param( 'tokenCall',        paramTokenCall);            // Used by API calls
  app.param( 'workspaceId',      paramWorkspaceIdCall);      // Used by API calls

  done( null );
}



hooks.run = function( done ){


  // Calls to check if users and workspaces are taken
  app.get(  '/call/usersAnon',      getUsersAnon );
  app.get(  '/call/workspacesAnon', getWorkspacesAnon );

  // Calls to actually create workspaces
  app.post( '/call/workspacesAnon', postWorkspacesAnon );
  app.post( '/call/workspacesUser', postWorkspacesUser );

  // Login, logout, recover calls
  app.post( '/call/recoverAnon',    postRecoverAnon );
  app.post( '/call/loginAnon',      postLoginAnon );
  app.get(  '/call/logoutUser',     getLogoutUser );

  done( null );

}

hooks.clientPaths = function( done ){
  done( null, { moduleName: 'hotCoreAuth', result: [ path.join(__dirname, '../client') ] } );
}


hooks.stores = function( done ){
  done( null, {
    usersAnon     : { target: '/call/usersAnon',      idProperty: '_id', sortParam: 'sortBy', },
    workspacesAnon: { target: '/call/workspacesAnon', idProperty: '_id', sortParam: 'sortBy', },

    workspacesUser: { target: '/call/workspacesUser', idProperty: '_id', sortParam: 'sortBy', },

    loginAnon     : { target: '/call/loginAnon',      idProperty: '_id', sortParam: 'sortBy', },
    recoverAnon   : { target: '/call/recoverAnon',    idProperty: '_id', sortParam: 'sortBy', },
    logoutUser    : { target: '/call/logoutUser',     idProperty: '_id', sortParam: 'sortBy', },
  });
}
*/

/*
    driverAllDbFetch: function( params, body, options, cb ){
      var strategies = hotplate.get('hotCoreAuth/strategies');
      var doc;

      // No strategies defined in Hotplate, end of story
      if( typeof( strategies ) === 'undefined' ){
        return cb( null, null );     
      }
 
      // Check if the strategy is one of the ones defined in Hotplate
      if( typeof( strategies[ params[ 'strategyId' ] ] ) !== 'undefined' ){

        // Make up the record
        doc = {}
        doc.strategyId = params[ 'strategyId' ];

        // Check that the strategy is indeed active 
        // for that user, and  if it is, set the "active" flag

        UserStrategies.GetQuery( { filters: { userId: params.userId, strategyId: params.strategyId } }, function( err, res ){
          if( err ){
            cb( err, null );
          } else {
            doc.active = 0;
            doc.field1 = '';
            doc.field2 = '';
            doc.field3 = '';
            doc.field4 = '';
            if( res.length ){
              doc.active = 1;
              doc.field1 = res[0].field1;
              doc.field2 = res[0].field2;
              doc.field3 = res[0].field3;
              doc.field4 = res[0].field4;
            }
            cb( null, doc) ;
          }
          
        });

      } else {
        cb( null, null );
      }

    },
*/


