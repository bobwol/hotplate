define( [

  "dojo/_base/declare"
, "dojo/dom-class"
, "dojo/Deferred"

, "hotplate/hotDojoWidgets/ConfirmDialog"
, 'hotplate/hotDojoStores/stores'
, 'hotplate/hotDojoGlobals/globals'


, "./_SignInRecoverRegisterButton"

], function(

  declare
, domClass
, Deferred

, ConfirmDialog
, stores
, globals

, _SignInRecoverRegisterButton

){

  return declare( [ _SignInRecoverRegisterButton ], {

    templateString: '<div><div class="auth-button" data-dojo-type="dijit/form/Button" data-dojo-attach-point="button" data-dojo-props="iconClass: \'auth-button-icon-all auth-button-icon-${strategyId}\'"></div><div class="unticked" data-dojo-attach-point="accessIcon"></div></div>',

    userStrategyData: null,
    resultSet: [],

    constructor: function( params ){
      var self = this;

      //  Create attributes that are local to the object
      self.userStrategyData = params.userStrategyData;
      self.resultSet = params.resultSet;

      // Observe the result set. If things change, the object
      // will update its internal values (`active` and `userStrategyData`) accordingly
      /* TODO: RESTORE OBSERVER */

      params.store.track();
      params.store.on('add, remove, update', function( event ){
        console.log( 'EVENT:', event );


        var id = event.type == 'remove' ? event.id : params.store.getIdentity( event.target );

        // TODO dstore: I absolutely _need_ the full object here as I need to compare
        // self.strategyId with the strategyId of the object that was just deleted!
        // I can do a get() when I have the cache I suppose.
        

        if( self.userStrategyData && id == self.userStrategyData.id ) {

//        if( ( (event.type == 'update' || event.type == 'add' ) && event.target.strategyId === self.strategyId ) ||
//            ( (event.type == 'remove' ) && self.strategyData.event.id === self.strategyId )
        
        
          switch( event.type ){

            case 'remove':
              self.set( 'active', false );
              self.set( 'userStrategyData', null );
            break;

            case 'add':
              self.set( 'active', true );
              self.set( 'userStrategyData', event.target );          
            break;

            case 'update':
              self.set( 'userStrategyData', event.target );
            break;
          }
        }
      });

      /*
      self.resultSet.observe( function( object, removeFrom, insertedInto ) {

        if( object.strategyId === self.strategyId ){

          // It's a deletion
          if( removeFrom != -1 && insertedInto == -1 ){
            self.set( 'active', false );
            self.set( 'userStrategyData', null );
          }

          // It's a addition
          if( removeFrom == -1 && insertedInto != -1 ){
            self.set( 'active', true );
            self.set( 'userStrategyData', object );
          }

          // It's an edit
          if( removeFrom == -1 && insertedInto == -1 ){
            self.set( 'userStrategyData', object );
          }
        }

      }, true );
      */


    },


    postCreate: function(){
      var self = this;

      this.inherited(arguments); 

      if( self.userStrategyData ) self.set( 'active', true );
    },

    // When set as "active", it will give visual feedback 
    _setActiveAttr: function( value ){
      this._set( 'active', value );
     
      if( value ){
        domClass.add( this.accessIcon, 'ticked' );
        domClass.remove( this.accessIcon, 'unticked' );
      } else {
        domClass.add( this.accessIcon, 'unticked' );
        domClass.remove( this.accessIcon, 'ticked' );
      }
    }, 


    _deleteStrategyData: function( title, content ){

      var self = this;
      deferred = new Deferred();

      var myDialog = new ConfirmDialog({
        title: title,
        content: content,
      });
      myDialog.startup();
      myDialog.on( 'dialogconfirmed', function( e ){


         var store = stores( 'usersStrategies', { userId: globals.userId } );       
         store.remove( self.userStrategyData.id ).then(

          function( r ){

            self.userStrategyData = null;
            deferred.resolve( true );
            return r;
          },
          function( err ){
            (new ConfirmDialog( { cancelButton: false, title: "Failed", content: "Operation failed" })).startup();
            deferred.reject( err );
            console.log(err);
            throw( err );
          }
        );
      });

      return deferred.promise
    },

  });

});

