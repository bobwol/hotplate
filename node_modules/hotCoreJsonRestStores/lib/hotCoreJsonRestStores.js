var 
  hotplate =  require('hotplate')
, path = require('path')
, async = require('async')
, util = require('util')
, mongoWrapper = require('mongowrapper')
, declare = require( 'simpledeclare' )
;



app = hotplate.app;

exports.hotHooks = hooks = {}


// Small helper function to see if multiHome is enabled
function multiHomeEnabled(){
  var hotCoreMultiHome = hotplate.get( 'hotCoreMultiHome' );

  if( typeof( hotCoreMultiHome ) === 'object' && hotCoreMultiHome !== null && hotCoreMultiHome.enabled ){
    return true;
  }
  return false;
}

exports.makeTabIdHashForMultihome = function( userId, tabId, message, done ){

  var hotCoreComet = hotplate.getModule( 'hotCoreComet' );
  var tabIdHash = {};

  console.log("TRIGGERED THE SPECIFIC FILTER FOR MULTI HOME");
  console.log( userId);
  console.log( message );


  // Get a list of all tabs
  hotCoreComet.Tabs.GetQuery( { }, function( err, tabs ){
    if( err ){
      done( err );
    } else {
      tabs.forEach( function( i ){
        if( i.tabId != tabId ) tabIdHash[ i.tabId ] = true;
      });


      // TODO
      // The record HAS a workspaceId: send it to all tabs of users belonging
      // to that specific workspaceId
      if( typeof( message.object.workspaceId ) === 'undefined' ){
        done( null, tabIdHash );

      // TODO
      // The record DOESN'T HAVE a workspaceId: send it to all tabs of users
      // who are in the same workspace as userId
      } else {
        done( null, tabIdHash );
      }

    }
  });

}

hooks.init = function( done ){

  // var messages = hotplate.getModule('hotCoreComet');
  var sharedCode = hotplate.getModule('hotCoreSharedCode');

  exports.SchemaMixin = declare( null, {

    sharedValidatorTypeParam: function( p ){
      if( typeof( p.parameterValue ) !== 'string' )
        throw( new Error("Validator needs to be a string, found: " + typeof( p.parameterValue ) ) );

      var f = sharedCode.sharedFunctions.hotCoreCommonValidators[ p.parameterValue ];

      if( f && ! f( p.value ) ){
        var msg = f( false );
        p.errors.push( { field: p.fieldName, message: msg, mustChange: true } );
      }
    }
  });



  exports.StoreMixin = declare(null, {

    killComet: false,
    chainErrors: 'all',

    echoAfterPutNew: true,
    echoAfterPutExisting: true,
    echoAfterPost: true,
    echoAfterPostAppend: true,

    db: hotplate.get('db'),

    _getTabId: function( req ){
      var tabId = this._req.headers['x-hotplate-tabid'];
      if( tabId == '' ){
        tabId = null;
      }
      return tabId; 
    },


    afterDelete: function( params, body, options, doc, fullDoc ){
      this.inherited( arguments );
    
  
      hotplate.invokeAll('storeRecordRemove', this.storeName, this._req.session.userId, this.idProperty, doc ); 
    },    

    afterPutExisting: function( params, body, options, doc, fullDoc, docAfter, fullDocAfter, overwrite, done ){
      this.inherited( arguments );

      var makeTabIdHash;
      var fromUserId;

      // Sets the userId if it's a remote request
      if( this.remote ){
         fromUserId = this._req.session.userId;
      } else {
         fromUserId = null;
      }

      // If it's in a multi-home environment, use the specific multi-home filter
      if( multiHomeEnabled() && doc.workspaceId ) makeTabIdHash = exports.makeTabIdHashForMultihome;

      // { to: 'workspace' }, {to: 'everybody' }, { to: 'userWorkspaces', workspaceId: doc.workspaceId }
      hotplate.invokeAll('cometBroadcast', this._req.session.userId, this._getTabId(), makeTabIdHash, { type: 'storeRecordUpdate', storeName: this.storeName, objectId: doc[ this.idProperty], object: doc } );
     

      done( null );
    },    


  });


  done( null );
}
hooks.init.after = [ 'hotCoreSharedCode' ];


