"use strict";

var dummy
, hotplate =  require('hotplate')
, declare = require( 'simpledeclare' )
, SimpleDbLayer = require( 'simpledblayer' )
, SimpleSchema = require( 'simpleschema' )
, JsonRestStores = require( 'jsonreststores' )

, hotCoreStoreRegistry = require('hotCoreStoreRegistry')
;


exports.makeTabIdHashForMultihome = function( userId, tabId, message, done ){

  var tabIdHash = {};

  hotCoreStoreRegistry.getAllStores( function( err, allStores ){
    if( err ){
       next( err );
    } else {

      // Get a list of all tabs
      allStores.stores.Tabs.Store.GetQuery( { }, function( err, tabs ){
        if( err ){
          done( err );
        } else {
          tabs.forEach( function( i ){
            if( i.tabId != tabId ) tabIdHash[ i.tabId ] = true;
          });


          // TODO
          // The record HAS a workspaceId: send it to all tabs of users belonging
          // to that specific workspaceId
          if( typeof( message.object.workspaceId ) === 'undefined' ){
            done( null, tabIdHash );

          // TODO
          // The record DOESN'T HAVE a workspaceId: send it to all tabs of users
          // who are in the same workspace as userId
          } else {
            done( null, tabIdHash );
          }

        }
      });
    }
  });
}

exports.get = function( done ){

  var classes = {};
  var sharedValidators = {};

  hotplate.hotEvents.emit('sharedFunctions', function( err, sharedFunctions) {
    if( err ){
      done( err );
    } else {

      // Gets the results, and adds them to the sharedValidators hash which
      // will then get used
      sharedFunctions.onlyResults().forEach( function( functions ){
        for( var k in functions ){
          // If it ends with "Validator", then it's a validator
          if( k.indexOf('Validator', k.length - 'Validator'.length) !== -1 ){
            sharedValidators[ k ] = functions[ k ];
          }
        }
      });


      classes.HotSchemaMixin = declare( null, {

        sharedValidatorTypeParam: function( p ){
          if( typeof( p.parameterValue ) !== 'string' )
            throw( new Error("Validator needs to be a string, found: " + typeof( p.parameterValue ) ) );

      
          var f = sharedValidators[ p.parameterValue ];
 
          if( f && ! f( p.value ) ){
            var msg = f( false );
            p.errors.push( { field: p.fieldName, message: msg, mustChange: true } );
          }
        }
      });

      classes.HotSchema = declare( [ SimpleSchema, hotplate.config.get( 'hotplate.SchemaMixin'), classes.HotSchemaMixin ] );

      classes.HotStoreMixin = declare( null, {

        killComet: false,
        chainErrors: 'all',

        echoAfterPutNew: true,
        echoAfterPutExisting: true,
        echoAfterPost: true,

        _getTabId: function( req ){

          // If the tab header wasn't there, then there is no way to broadcast -- abord
          if( typeof( this._req ) === 'undefined' ) return null;

          var tabId = this._req.headers['x-hotplate-tabid'];
          if( tabId == '' ){
            tabId = null;
          }
          return tabId; 
        },


        _broadcast: function( killCometOption, type, objectId, object ){

          var makeTabIdHash;
          var fromUserId;
          var storeTarget;

          // No comet required (from the option, or for the store's own request
          if( this.killComet || killCometOption ) return;

          // Sets the userId if it's a remote request
          if( this.remote ){
             fromUserId = this._req.session.userId;
          } else {
             fromUserId = null;
          }

          // If it's in a multi-home environment, use the specific multi-home filter
          if( hotplate.config.get( 'hotCoreMultiHome.enabled' ) && object.workspaceId ) makeTabIdHash = exports.makeTabIdHashForMultihome;

          // Actually invoke the broadcast
          hotplate.hotEvents.emit('cometBroadcast', fromUserId, this._getTabId(), makeTabIdHash, { type: type, storeName: this.storeName, objectId: objectId, object: object },  function(){}  );

        },

        afterPutExisting: function( params, body, options, doc, fullDoc, docAfter, fullDocAfter, overwrite, done ){
          var self = this;
          this.inheritedAsync( 'afterPutExisting', arguments, function(){
            self._broadcast( options.killComet, 'storeRecordUpdate', docAfter[ self.idProperty], docAfter );
            done( null );
          });
        },    

        afterPost: function( params, body, options, doc, fullDoc, done ){
          var self = this;
          this.inheritedAsync( 'afterPost', arguments, function(){
            self._broadcast( options.killComet, 'storeRecordCreate', doc[ self.idProperty], doc );
            done( null );
          });
        },

        afterPutNew: function( params, body, options, doc, fullDoc, overwrite, done ){
          var self = this;
          this.inheritedAsync( 'afterPutNew', arguments, function(){
            self._broadcast( options.killComet, 'storeRecordCreate', doc[ self.idProperty], doc );
            done( null );
          });
        },

        afterDelete: function( params, body, options, doc, fullDoc, done ){
          var self = this;
          this.inheritedAsync( 'afterDelete', arguments, function(){
            self._broadcast( options.killComet, 'storeRecordRemove', doc[ self.idProperty ], doc ); 
            done( null );
          });
        },    
      });

      classes.HotStore = declare( [ JsonRestStores, classes.HotStoreMixin ],{
        DbLayer: declare( [ SimpleDbLayer, hotplate.config.get('hotplate.DbLayerMixin') ], { db: hotplate.config.get( 'hotplate.db' ) } )
      });

      done( null, classes );

    }
  });

}


