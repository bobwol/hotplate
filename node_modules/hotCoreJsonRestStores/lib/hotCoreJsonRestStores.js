var 
  hotplate =  require('hotplate')
, path = require('path')
, async = require('async')
, util = require('util')
, mongoWrapper = require('mongowrapper')
, declare = require( 'simpledeclare' )
;



// Simply activate path to client files
hooks.clientPaths = function( done ){
  done( null, { moduleName: 'hotCoreJsonRestStores', result: [ path.join(__dirname, '../client') ] } );
}



app = hotplate.app;

// Registry variables
exports.storeRegistry = {}
exports.collectionRegistry = {}
exports.configStoreRegistry = {}

exports.hotHooks = hooks = {}


hooks.init = function( done ){

  var messages = hotplate.getModule('hotMongoCometMessages');
  var sharedCode = hotplate.getModule('hotCoreSharedCode');

  exports.SchemaMixin = declare( null, {

    sharedValidatorTypeParam: function( p ){
      if( typeof( p.parameterValue ) !== 'string' )
        throw( new Error("Validator needs to be a string, found: " + typeof( p.parameterValue ) ) );

      var f = sharedCode.sharedFunctions.hotCoreCommonValidators[ p.parameterValue ];

      if( f && ! f( p.value ) ){
        var msg = f( false );
        p.errors.push( { field: p.fieldName, message: msg, mustChange: true } );
      }
    }
  });


  exports.StoreMixin = declare(null, {

    killComet: false,
    chainErrors: 'all',

    echoAfterPutNew: true,
    echoAfterPutExisting: true,
    echoAfterPost: true,
    echoAfterPostAppend: true,

    db: hotplate.get('db'),

    _getTabId: function( req ){
      var tabId = this._req.headers['x-hotplate-tabid'];
      if( tabId == '' ){
        tabId = null;
      }
      return tabId; 
    },


    _broadcastChange: function( storeName, object, op ){

      var self = this;

      if( ! self.killComet && self.remote ){

        // Work out the tab Id
        var tabId = self._getTabId( self._req );

        // This is dreadful. But what am I to do?
        // A store is identified by its name and its target
        // This allows nested stores like 
        // bookingPerformers = store('bookingPerformers', { bookingId: 4343 } )
        // bookingPerformers.query({}) => `GET /Bookings/4343/performers/`
        var storeTarget = self._req.originalUrl.match( /(^.*\/)/,'' )[0];


        /*
        // Broadcast the change to its own store
        messages.sendToTabsOfWorkspace(

          // These ones never change
          self._req.application.workspace._id,
          tabId,
          self._req.application.user._id,
          op,

          // These ones do change: it's the message to broadcast
          {
            storeName: storeName,
            storeTarget: storeTarget,
            objectId: object._id,
            object: object,
            remote: true
          }
        );
        */


        /*
        if( Array.isArray( this.cometGroup ) ){
          for( var i =0, l=this.cometGroup.length; i < l; i++ ){
            var groupStoreName = this.cometGroup[ i ];
            if( storeName != groupStoreName ){

              // Broadcast the change to other stores in the same group
              messages.sendToTabsOfWorkspace(

                // These ones never change
                self._req.application.workspace._id,
                tabId,
                self._req.application.user._id,
                op,

                // These ones do change: it's the message to broadcast
                { storeName: groupStoreName,
                  objectId: object._id,
                  object: object,
                  remote: true
                }
              );

            }
          }
        }
        */


      }

    },

    afterDelete: function( params, body, options, doc, fullDoc ){
      this.inherited( arguments );
      this._broadcastChange( this.storeName, doc, 'storeRemove' );
    },    

    afterPutExisting: function( params, body, options, body, doc, docAfter, fullDoc, fullDocAfter, overwrite ){
      this.inherited( arguments );
      this._broadcastChange( this.storeName, docAfter, 'storeUpdate' );
    },    

    afterPutNew: function( params, body, options, body, doc, fullDoc, overwrite  ){
      this.inherited( arguments );
      this._broadcastChange( this.storeName, doc, 'storeCreate' );
    },    

    afterPost: function( params, body, options, body, doc, fullDoc ){
      this.inherited( arguments );
      this._broadcastChange( this.storeName, doc, 'storeCreate' );
    },    

    constructor: function(){
      //console.log("********************************************* CONSTRUCTOR: hotCoreJsonRestStore");
    },

  });


  // Specific function to use instead of Declare to declare a Store and
  // add that store to the registry
  exports.declareStore = function( SuperCtor, protoMixin ){


    // Declare the new store and create a store Object, which
    // won't be used for an actual connection/API operation, but to
    // get the store's properties
    var Store = declare( SuperCtor, protoMixin );


    // Tries to create a store object. Note that this might not work as
    // the schema might not be defined, for example -- in which case, it just
    // returns the Store class just created without adding it to the registry
    console.log("ENTERING TRY/CATCH");
    try { 
      var store = new Store();
    } catch ( e ){
      console.log("DIDN'T HAPPEN: " );
      console.log( e );
      return Store;
    }
    console.log("AFTER TRY/CATCH");


    console.log(" STORE: " + store.storeName );
    console.log( store );
    console.log(" ------------ " );
    // STORE REGISTRY OPERATIONS  
 
    // Add the module to the store registry
    exports.storeRegistry[ store.storeName ] = { Store: Store, storeObject: store };

    // Add the module to the configStore registry
    if( store.configStore ){
      exports.configStoreRegistry[ store.storeName ] = { Store: Store, storeObject: store };
    }

    // Add the module to the collection registry
    if( store.collectionName ){
      exports.collectionRegistry[ store.collectionName ] = exports.collectionRegistry [ store.collectionName ] || [];
      exports.collectionRegistry[ store.collectionName ].push( { Store: Store, storeObject: store }  );
    }

    return Store;
  }



  done( null );
}
hooks.init.after = [ 'hotMongoCometMessages', 'hotCoreSharedCode' ];


