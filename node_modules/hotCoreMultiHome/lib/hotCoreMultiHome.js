"use strict";

/**
Provides multi-home abilities to Hotplate

This module's aim is to make sure Hotplate has full multi-home abilities. The module itself:

* Defines all of the relevant stores ( `workspaces`, `workspacesUsers`, `usersWorkspaces`)
* Places important variables on the rendered page ( `vars.hotCoreMultiHome.enabled` and `.multiHomeURL`)
* Places the crucial `vars.hotCoreMultiHome.workspaceId` variable on the rendered page

However, given the nature of this module, there are _several_ other modules in Hotplate that interact with it.

## SUMMARY: modules that deal with multihome environments:

* hotCoreJsonRestStores -- it will broadcast comet messages only to workspace users
* hotCoreStoreConfig -- if the url has `:workspaceId`, it will set config stores' records in the page for that workspace
* hotDojoGlobals -- will set global variable workspaceId if it's set within the page
* hotDojoStoreConfig -- will call `stores()` passing `userId` and `workspaceId` in resolution hash, allowing easy workspace-bound setting lists
* hotDojoAppContainer -- fully multi-home aware, will hook to correct URL and, if `:workspaceId` is in the URL, it will check that it exists.
* hotDojoAuth -- fully multi-home aware, providing a pick mechanism etc. Gets the workspace URL from `vars.hotCoreMultiHome.multiHomeURL` 

* hotDojoComet -- will add header `X-hotplate-workspaceId` to tab messages requests
* hotCoreComet -- will use `X-hotplate-workspaceId` to return updated config records for the expired workspace

A more detailed explanation of what each module does, in terms of interaction with hotCoreMultiHome, follows. Note that any interaction happens on the basis that `hotCoreMultiHome` is enabled.

## hotCoreJsonRestStores

* ./node_modules/hotCoreJsonRestStores/lib/hotCoreJsonRestStores.js

When broadcasting changes to stores via the hook `cometBroadcast`, it will change its behavious depending on multi-home being enabled or not.

If multiHome is enabled, checks if the record has a workspaceId field -- in which case, it will only broadcast the message to users in that workspaceId (it will do so by passing a `makeTabIdHash()` function to the `cometBroadcast` hook) 

## hotCoreStoreConfig

* ./node_modules/hotCoreStoreConfig/lib/hotCoreStoreConfig.js

Implements `pageElementsPerPage` that passes `params.workspaceId` to `getConfig()` -- which means that if the URL has the `workspaceId` parameter, it will add a variable with the workspace's configuration to the page. It also passes `session.userId` to `getConfig()`, so if the user is logged in, it will return that user's config too.

NOTE: `getConfig()` is implemented here. Signature: `function( workspaceId, userId, cb )`. It basically will return all configs with `workspaceId` and/or `userId` set in their `store.configStore` property

## hotDojoGlobals

* ./node_modules/hotDojoGlobals/client/globals.js

Sets the global variable `workspaceId` based on `vars.hotCoreMultiHome.workspaceId` (Unrelated: it also sets `userId` based in `vars.hotCoreAuth.userId`)

## hotDojoStoreConfig

* ./node_modules/hotDojoStoreConfig/client/ConfigVars.js

Config variables are bound to "nothing" (system-wide settings), to a user (user-wide settings), to a workspace (workspace-wide settings) or both (user-specific settings for a specific workspace). That's why ConfigVars will call `stores()` passing `:userId` and :`workspaceId` in resolution hash.

Note that `:workspaceId` and `userId` are the ONLY parameters allowed in a config store URL.


## hotDojoAppContainer

* ./node_modules/hotDojoAppContainer/lib/hotDojoAppContainer.js

In terms of URLs, it will attach to `hotCoreMultiHome.multiHomeURL` or `hotCoreAuth.appURL` depending on multi-home being enabled or not. Also, IF `:workspaceId` is in the URL as a parameter, it will check that the workspace actually exists or it will return an error.

## hotDojoAuth

* ./node_modules/hotDojoAuth/lib/hotDojoAuth.js

The pagePick callback is there just for multi-home environments, picking the workspace

* ./node_modules/hotDojoAuth/client/NewWorkspace.js

After adding a new workspace, it will redirect to it thanks to `vars.hotCoreMultiHome.multiHomeURL` (replacing `:workspaceId` with the id of the record that was just created) 

* ./node_modules/hotDojoAuth/client/Pick.js

After picking a workspace, it will redirect to it thanks to `vars.hotCoreMultiHome.multiHomeURL` as above

* ./node_modules/hotDojoStoreConfig/client/ConfigVars.js

## hotDojoComet

* ./node_modules/hotDojoComet/client/messages.js

It adds a header `X-hotplate-workspaceId` to tabId requests. This is ESSENTIAL so that hotCoreComet knows which workspaceId the tab belongs to. Yes, IT NEEDS to know it: if the tab is not found or it's expired, hotCoreComet will return only one message, `resetStores`, which will INCLUDE all configuration records for that user and workspace (in order to save GETs and implement error management app-side).

## hotCoreComet

* ./node_modules/hotCoreComet/lib/hotCoreComet.js

Uses the header `X-hotplate-workspaceId` to return the config stores' records for that `workspaceId` in case the tab is expired or not there

@module hotCoreMultiHome
@main hotCoreMultiHome
@class hotCoreMultiHome
@static
*/


var dummy
  , hotplate = require('hotplate')

  , JsonRestStore = require('jsonreststores')
  , SimpleSchema = require('simpleschema')
  , hotCoreJsonRestStores = require( 'hotCoreJsonRestStores' )

  , declare = require('simpledeclare')

;


// Some sane defaults

// Multihome enabled
hotplate.config.set('hotCoreMultiHome', {
   enabled: true,
   multiHomeURL: '/wssssssssssssssssssss/:workspaceId', // MUST contain :workspaceId
   escapePick: true,
});


hotplate.hotEvents.on( 'stores', 'hotCoreMultiHome', hotplate.cachable( function( done ){

  var stores = {};


  hotCoreJsonRestStores.get( function( err, s ){
    if( err ){
      done( err );
    } else {

      var HotStore = s.HotStore;
      var HotSchema = s.HotSchema;

      // ***********************************
      // *** WORKSPACES ********************
      // ***********************************

      stores.Workspaces = declare( HotStore, {

        // COMMON
        schema: new HotSchema({
          id:            { type: 'id' },

          workspaceName: { type: 'string', required: true, notEmpty: true, trim: 128, searchable: true,
                           sharedValidator: 'workspaceValidator' },
          ownerUserId:   { type: 'id' }, 
        }),

        storeName:  'Workspaces',

        paramIds: [ 'id' ],

        publicURL: '/workspaces/',

        handlePost: true,
        checkPermissionsPost: function( params, body, options, cb ){
          // Needs to be logged in
          if( ! this._req.session.userId ) return cb( null, false );
     
          // Make sure that body.ownerUserId IS indeed the logged in user
          body.ownerUserId = this._req.session.userId;

          cb( null, true );
        },


        // If creating a new workspace, and the user is logged in, then
        // assign the creating user to that workspace
        afterPost: function( params, body, options, doc, fullDoc, cb ){

          if( this.remote && this._req.session.loggedIn ){
            var userId = this._req.session.userId;
            if( userId ){
               // Note: this calls the callback
               stores.WorkspacesUsers.Post( { userId: userId, workspaceId: doc.id }, {}, cb );
            } else {
              cb( null );
            }
          }
        },

      });


/*
  var WorkspaceInvites = exports.WorkspaceInvites = declare( HotStore, {

    schema: new HotSchema({
      workspaceId: { type: 'id' },
      inviteCode:  { type: 'string' },
      email     :  { type: 'string' },
      name      :  { type: 'string' },
      id:         { type: 'id' },
    }),

    handlePost: true,
    handleGet: true,
    handleGetQuery: true,
    handleDelete: true,

    searchSchema: new Schema({
      workspaceId: { type: 'id' },
      userId:      { type: 'id' },
      id:         { type: 'id' },
    }),

    storeName:  'workspaceInvites',
    paramIds: [ 'workspaceId', 'id' ],
    publicURL: '/workspaces/:workspaceId/invites/',
  });
  //WorkspaceInvites.onlineAll( app, '/workspaces/:workspaceId/invites', ':id' );
*/


      // The basic schema for the WorkspacesUsers table
      stores.WorkspacesUsersBase = declare( HotStore, {

        schema: new HotSchema({
          userId:      { type: 'id' },
          workspaceId: { type: 'id' },
          id:          { type: 'id' },
        }),

        storeName: 'WorkspacesUsersBase',
        collectionName: 'WorkspacesUsers',

        paramIds: [ 'id' ],
      });


      stores.WorkspacesUsers = declare( stores.WorkspacesUsersBase, {

        searchSchema: new HotSchema({
          workspaceId: { type: 'id' },
          userId:      { type: 'id' },
          id:          { type: 'id' },
        }),

        paramIds: [ 'workspaceId', 'id' ],

        storeName:  'WorkspacesUsers',

        publicURL: '/workspaces/:workspaceId/users/',
      });

      stores.UsersWorkspaces = declare( stores.WorkspacesUsersBase, {

        searchSchema: new HotSchema({
          userId:        { type: 'id' },
          workspaceId:   { type: 'id' },
          id:            { type: 'id' },
         // workspaceName: { EXTERNAL FROM workspaces } 
        }),

        paramIds: [ 'userId', 'id' ],

        storeName:  'UsersWorkspaces',

        publicURL: '/users/:userId/workspaces/',

        handleGetQuery: true,
        checkPermissionsGetQuery: function( params, body, options, cb ){
          // Only their own workspaces
          if( this._req.session.userId != params.userId ) return cb( null, false );
          cb( null, true );
        },


        // Get the much needed workspaceName from the Workspaces table
        prepareBeforeSend: function( doc, cb ){

          var self = this;

          stores.Workspaces.Get( doc.workspaceId, {}, function( err, otherDoc ){
            self._sendErrorOnErr( err, cb, function(){

              doc.workspaceName = otherDoc.workspaceName;
              cb( null, doc );
            })
          })

        },


      });

      // done( null, stores );
      done( null,  [ stores.Workspaces, stores.WorkspacesUsers, stores.UsersWorkspaces ] );

    }
  })


}));



// Place relevant config variables on the rendered page
hotplate.hotEvents.on( 'pageElements', 'hotCoreMultiHome', function( done ){

  done( null, {
    vars:  [
             { name: 'enabled',      value: hotplate.config.get('hotCoreMultiHome.enabled') },
             { name: 'multiHomeURL', value: hotplate.config.get('hotCoreMultiHome.multiHomeURL') },
           ],
  });
});

// Place workspaceId on the rendered page
hotplate.hotEvents.on( 'pageElementsPerPage', 'hotCoreMultiHome', function( elements, req, pageName, done ){

  var vars = [];

  // Add the user ID to the page as a variable
  if( req.params.workspaceId ){
    vars.push( { name: 'workspaceId', value: req.params.workspaceId } );
  }

  done( null, {
    vars: vars
  });

});

