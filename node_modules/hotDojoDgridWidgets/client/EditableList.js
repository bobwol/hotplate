define([
   "dojo/_base/declare",
   "dojo/when",
   "dojo/topic",
   "dojo/on",
   "dojo/_base/lang",
   "dojo/dom-construct",
   "dojo/dom-style",
   "dojo/dom-attr",
   "dojo/aspect",

   "dijit/_WidgetBase",
   "dijit/Dialog",
   "dijit/_OnDijitClickMixin",
   "dijit/focus",
   "dijit/form/Button",
   "dijit/layout/BorderContainer",
   "dijit/layout/ContentPane",

   'dgrid/List',
   'dgrid/OnDemandList',
   "dgrid/Selection",
   "dgrid/Keyboard",
   "dgrid/util/mouse",

   'put-selector/put',

   "hotplate/hotDojoSubmit/defaultSubmit",
   "hotplate/hotDojoWidgets/BusyButton",
   "hotplate/hotDojoWidgets/ConfirmDialog",

   ], function(
     declare
     , when
     , topic
     , on
     , lang
     , domConstruct
     , domStyle
     , domAttr
     , aspect

     , _WidgetBase
     , Dialog
     , _OnDijitClickMixin
     , focusUtil
     , Button
     , BorderContainer
     , ContentPane

     , List
     , OnDemandList
     , Selection
     , Keyboard
     , mouse
     , put

     , ds
     , BusyButton
     , ConfirmDialog

 ){


    return declare( BorderContainer, {

      // Internal list of rows being edited or being deleted
      _editing: {},
      _inDeletion: {},

      // Store
      storeName: '',
      store: null,
      //storeFields: {},

      listWidget: null,

      EditingConstructor: null,
      editingWidget: null,
      editingWidgetPlacement: 'inline', // It can be 'inline', 'dialog'
      multipleEditingAllowed: false,

      AddingConstructor: null,
      addingWidget: null,
      addingWidgetPlacement: 'after', // 'none', 'before', 'after',

      // Edit and delete buttons
      editButton: 'Edit',
      deleteButton: 'Delete',

      // Refresh parameters
      refreshOnSubmit: false,

      constructor: function( params ){
        // this.store = stores( params.storeName, params.storeFields );
        this.editing = {};
        this.inherited(arguments);
      },

      // Proxy method for listwidget.row()
      row: function( p ){
        return this.listWidget.row( p );
      },


      postCreate: function(){

        this.inherited(arguments); 
        var self = this;       

        put( this.domNode, '.editable-list' );

        // Add the dgrid, always in the middle
        self.listWidget = new this.ListConstructor( { store: this.store, region: 'center' } );
       
        if( this.listWidget.layoutPriority !== 0 ){
           throw( new Error("The Dgrid needs to inherit from dgrid/extensions/DijitRegistry in order to work here!") );
        }

        this.addChild( this.listWidget );

        // Create the adding widget
        if( self.AddingConstructor ){

          // Create an editing widget using the passed constructor. However,
          // it will set storeName, store (no recordId since it's an add)
          self.addingWidget = new self.AddingConstructor({
            storeName: self.storeName,
            store: self.store,
            region: self.addingWidgetRegion,
          });

          // if self.refreshOnSubmit is set, then it will refresh the
          // list
          if( self.refreshOnSubmit ){
            self.addingWidget.on('successfulsubmit', function( e ){
              self.listWidget.refresh();
            });
          }
        }
        if( self.addingWidgetRegion != '' ) self.addChild( self.addingWidget );

        // Turn self.[edit|delete]Button into widgets (busyButtons) if
        // they were passed as strings
        if( typeof( self.editButton ) === 'string' ){
          self.editButton = new BusyButton({
            label: self.editButton
          });
          self.editButton.startup();
        }

        if( typeof( self.deleteButton ) === 'string' ){
          self.deleteButton = new BusyButton({
            label: self.deleteButton
          });
          self.deleteButton.startup();
        }

        // Wire the click of the edit button
        if( self.editButton ){
          self.editButton.on('click', function(e){
            var row = self.row( e );         
            var row = self.row( e );         
            put( row.element, self.editButton.domNode, '!' );
            put( row.element, self.deleteButton.domNode, '!' );
            self._editRow( row );
          });
        }


        // Wire the click of the delete button
        if( self.deleteButton ){
          self.deleteButton.on('click', function( deleteEvent ){

            var row = self.row( deleteEvent );         

            var myDialog = new ConfirmDialog({
              title: "Are you sure?",
              content: "Are you sure you want to delete the element?",
            });            
            myDialog.startup();
            myDialog.show();
            myDialog.on( 'dialogconfirmed', function( e ){

              put( row.element, self.editButton.domNode, '!' );
              put( row.element, self.deleteButton.domNode, '!' );

              var cover = put( row.element, 'div.editable-list-overlay' );

              domStyle.set( row.element, 'pointer-events', 'none' );
              self._inDeletion[ row.id ] = true;
          
              self._deleteRow( row ).then(
                function( res ){
                  console.log("IN RES");
                
                },
                function( err ){
                  console.log("IN ERR");
                  self._inDeletion[ row.id ] = false;
                  put( row.element, cover, '!' );
                  domStyle.set( row.element, 'pointer-events', 'all' );
                }
              )
            })
          })
        }


        // Pressing Enter will trigger editing
        self.listWidget.on( 'keypress' , function( e ){
          var row = self.row( e );
          if( e.charCode == 13 && ! self._inDeletion[ row.id ] ){
            var row = self.row( e );
            self._editRow( row );
          } 
        }),

        // Double-click will trigger editing 
        self.listWidget.on('.dgrid-row:dblclick', function(e){
          var row = self.row( e );
          self._editRow( row );

        })


        // Make the edit/delete buttons appear if the mouse goes over them
        self.listWidget.on( mouse.enterRow, function(e){
          var row = self.row( e );

          // Don't show buttons if editing right now
          if( self._editing[ row.id ] ) return;

          // Don't show more buttons if a row is being edited and multipleEditingAllowed is false
          if( Object.keys( self._editing ).length > 0 && ! self.multipleEditingAllowed ) return;

          // Add the buttons if they are present
          if( self.editButton ){
            put( row.element, self.editButton.domNode );
          }
          if( self.deleteButton ){
            put( row.element, self.deleteButton.domNode );
          }
        });

        // Take the buttons out of the DOM for that row when the mouse
        // leaves
        self.listWidget.on( mouse.leaveRow, function(e){
          var row = self.row( e );

          if( self.editButton ){
            put( row.element, self.editButton.domNode, '!' );
          }
          if( self.deleteButton ){
            put( row.element, self.deleteButton.domNode, '!' );
          }
        });


        // Make sure that every row is rendered with "position: relative" as it's used
        // by inline editing and edit/delete buttons
        self.own( aspect.around( self.listWidget, 'renderRow', function( renderRow ){
          return function( object, options ){
            var r = renderRow( object, options );
            domStyle.set( r, 'position', 'relative' );
            return r;
          }
        }) );

        // Aspect to check if renderRow is called for a row that is being edited
        // IF that's the case, it will need to re-attach the editing widget's domNode
        // to it, so that it doesn't disappear (zapped by renderRow which returns a new DOM)
        if( self.editingWidgetPlacement === 'inline' ){
          self.own( aspect.around( self.listWidget, 'renderRow', function( renderRow ){

            return function( object, options ){
         
              var id = object[ self.store.idProperty ];
              if( self._editing[ id ] ){
                //console.log("RENDERING WHILE EDITING OF " + object.name );
                var r = renderRow( object, options );
                put( r, self._editing[ id ].editingWidget.domNode );
                return r;
              } else {
                //console.log("CLEAN RENDERING OF " + object.name );
                
                return renderRow( object, options );
              }
            }

          }) );
        }

      },


      destroy: function(){
        this.inherited(arguments);
      },


 
      // Allows editing of a row in a dialog box
      //
      _editInDialog: function( row ){
        var self = this;
        var editingWidget;

        // Create an editing widget using the passed constructor. However,
        // it will set storeName, storeFields and recordId
        editingWidget = new self.EditingConstructor({
          storeName: self.storeName,
          store: self.store,
          //storeFields: self.storeFields,
          recordId: row.id,
        });

        // if self.refreshOnSubmit is set, then it will refresh the
        // list
        if( self.refreshOnSubmit ){
          editingWidget.on('successfulsubmit', function( e ){
            self.listWidget.refresh();
          });
        }


        // Make up the dialog with editing widget, show it
        self.dialog = new Dialog({
          title: "Edit",

          // The widget was created programmatically: destroy on hiding
          hide: function(){

            // Dialog.hide() returns a promise, which resolves when
            // the hiding animation is over. 
            // First of all, get this promise...
            var p = this.inherited('hide', arguments ); // Need the name, this will be lang.mixin, not declare.safeMixin

            // Attach a new callback triggered when the animation is over:
            // the callback will destroy the widget
            p.then( lang.hitch(this, function(){
              this.destroyRecursive();
            }));

            // Return the promise, in case other calls want to
            // attach more callbacks to it
            return p;
          },

        });

        self.dialog.addChild( editingWidget );
        self.dialog.startup();
        self.dialog.show();

        editingWidget.on( 'successfulsubmit', function(){
          self.dialog.hide();
          console.log( row.element );
          focusUtil.focus( row.element );  
        });

      },

      // Allows editing of a row inline
      //
      _editInline: function( row ){
        var self = this;
        var editingWidget;
        var keyHandler;

        if( self._editing[ row.id ] ) return;

        // Self._editing will be an object containing several rows
        // indexed by row.id and each row contains:
        //
        // element:        the element's domNode
        // editingWidget:  the editing widget attached to that row
        // 
        self._editing[ row.id ] = { element: row.element } ;


        // Create an editing widget using the passed constructor. However,
        // it will set storeName, storeFields and recordId
        editingWidget = new self.EditingConstructor({
          storeName: self.storeName,
          store: self.store,
          //storeFields: self.storeFields,
          recordId: row.id,
        });

        // if self.refreshOnSubmit is set, then it will refresh the
        // list
        if( self.refreshOnSubmit ){
          editingWidget.on('successfulsubmit', function( e ){
            self.listWidget.refresh();
          });
        }

        self._editing[ row.id ].editingWidget = editingWidget;

        // Give the row the class .dgrid-cell-editing
        put( row.element, ".dgrid-cell-editing");

        // Add the editing widget to the row domNode. It will have
        // absolute positioning, which means it will overlap
        // the actual row
        put( row.element, editingWidget.domNode );
        put( editingWidget.domNode, '.editable-list-row-editor' );

        // Basic styles to make sure that the editing widget is positioned correctly
        domStyle.set( row.element, 'position', 'relative' );

        // Startup and show the widget
        editingWidget.startup();
        editingWidget._onShow();

        // Escape and successful submit will close this form (properly)
        editingWidget.formWidget.on( 'keydown' , function( e ){
          if( e.keyCode == 27 ) closeThis(); 
        });
        editingWidget.on( 'successfulsubmit', function(){
          closeThis();
        });

        // If there is "escape" at widget level, then kill the editing.
        // This is necessary in case escape is pressed at widget level
        // and there are editing forms open and which won't get the focus
        // because of the overlay, or which don't have the focus full stop.
        keyHandler = self.on( 'keydown', function( e ){
          if( e.keyCode == 27 ){
            closeThis();
          }
        });

        // Close this form "properly":
        // * taking the class out
        // * delete the self.editing entry,
        // * destroy the widget
        function closeThis(){
          put( row.element, "!dgrid-cell-editing"); // Take out the extra editing class
          focusUtil.focus( self.row( row.id ).element );  
          delete self._editing[ row.id ]; // Delete the self._editing holder
          editingWidget.destroyRecursive(); // Destroy the widget and its children
          self.listWidget.select( row.id );
          focusUtil.focus( self.row( row.id ).element );// FIXME: Won't work
          keyHandler.remove();
        }
      },


      _editRow: function( row ){
        var self = this;

        if( self.multipleEditingAllowed || Object.keys( self._editing ).length < 1 ){

          if( self.editingWidgetPlacement === 'inline' ){
            self._editInline( row );
          } else {
            self._editInDialog( row );
          }
        }       
      },

      _deleteRow: function( row ){

        var self = this;

        // Try to save the values
        var promise = when( self.store.remove( row.id )) .then(
          
          function( res ){
             // alert('Deleted!');
          },
          ds.UIErrorMsg( null, null, null )
        );
        return promise;

      },

    });
 

});

