define([
   "dojo/_base/declare",
   "dojo/when",
   "dojo/topic",
   "dojo/on",
   "dojo/_base/lang",
   "dojo/dom-construct",
   "dojo/dom-style",
   "dojo/dom-class",
   "dojo/dom-attr",
   "dojo/dom-geometry",
   "dojo/aspect",
   "dojo/mouse",

   "dijit/_WidgetBase",
   "dijit/_TemplatedMixin",
   "dijit/_WidgetsInTemplateMixin",
   "dijit/Dialog",
   "dijit/_OnDijitClickMixin",
   "dijit/focus",
   "dijit/form/Button",
   "dijit/layout/BorderContainer",
   "dijit/layout/ContentPane",

   'dgrid/List',
   'dgrid/OnDemandList',
   "dgrid/Selection",
   "dgrid/Keyboard",
   "dgrid/util/mouse",

   'put-selector/put',

   "hotplate/hotDojoSubmit/defaultSubmit",
   "hotplate/hotDojoWidgets/BusyButton",
   "hotplate/hotDojoWidgets/ConfirmDialog",

   ], function(
     declare
     , when
     , topic
     , on
     , lang
     , domConstruct
     , domStyle
     , domClass
     , domAttr
     , domGeometry
     , aspect
     , dojoMouse

     , _WidgetBase
     , _TemplatedMixin
     , _WidgetsInTemplateMixin
     , Dialog
     , _OnDijitClickMixin
     , focusUtil
     , Button
     , BorderContainer
     , ContentPane

     , List
     , OnDemandList
     , Selection
     , Keyboard
     , mouse
     , put

     , ds
     , BusyButton
     , ConfirmDialog

 ){

    var DefaultButtonsConstructor = declare( [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, _OnDijitClickMixin ], {

      listWidget: null,

      constructor: function( params ){
        if( typeof( params) == 'undefined' || typeof( params.listWidget ) == 'undefined' ){
          throw( new Error( "The buttonsWidget need to be passed a listWidget parameter in its constructor") );
        }
        this.listWidget = params.listWidget;
      },

      templateString: ''+
                      '<div>\n'+
                      '  <div data-dojo-type="dijit/form/Button" data-dojo-attach-point="editButtonWidget, focusNode" data-dojo-props="label:\'Edit\'"> </div>\n'+
                      '  <div data-dojo-type="dijit/form/Button" data-dojo-attach-point="deleteButtonWidget" data-dojo-props="label:\'Del\'"></div>\n'+
                      '</div>\n'+
                              '',

      postCreate: function(){
        var self = this;

        this.inherited(arguments);

        domStyle.set( self.domNode, { 'position' : 'fixed' } );
        domClass.add( self.domNode, 'button-widgets' );

        // Pressing Enter will trigger editing
        self.on( 'keydown' , function( e ){
          if( e.keyCode == 27  ){
            var row = self.listWidget.row( self.listWidget._buttonsRowId );
            domStyle.set( self.domNode, { display: 'none' } );
            row.element.focus();
          }
        });


        // Wire up the default buttons. Note: templateString might have been redefined. That's
        // why the conditional wiring (the buttons might not be there)
        if( self.editButtonWidget ){
          self.editButtonWidget.on('click', function(e){
            var row = self.listWidget.row( self.listWidget._buttonsRowId );
            self.listWidget._editRow( row );
          });
        }

        if( self.editButtonWidget ){
          self.deleteButtonWidget.on('click', function(e){
            var row = self.listWidget.row( self.listWidget._buttonsRowId );
            self.listWidget._deleteRow( row );
          });
        }

      },
    });



    r = declare( BorderContainer, {

      // Internal list of rows being edited or being deleted
      _inlineEditing: {},
      _inDeletion: {},

      // Store
      storeName: '',
      store: null,
      //storeFields: {},

      listWidget: null,

      ButtonsConstructor: DefaultButtonsConstructor,

      EditingConstructor: null,
      editingWidgetPlacement: 'inline', // It can be 'inline', 'dialog'
      multipleEditingAllowed: false,

      AddingConstructor: null,
      addingWidget: null,
      addingWidgetPlacement: 'after', // 'none', 'before', 'after',

      // Refresh parameters
      refreshOnSubmit: false,

      // Mouse statuses, to check if pointer is on the buttons or on the widget
      _onButtonsNode: false,
      _onWidget: false,

      // The row ID the buttons currently refer to. Important when
      // using click, since the buttons are not part of the dgrid DOM
      // and self.row() won't work
      _buttonsRowId: null,

      constructor: function( params ){
        this.editing = {};
        this.inherited(arguments);
      },


      // Proxy method for listwidget.row()
      row: function( p ){
        return this.listWidget.row( p );
      },


      postCreate: function(){

        this.inherited(arguments); 
        var self = this;       

        // *****************************************
        // *** THE CENTER PIECE: THE LIST WIDGET ***
        // *****************************************

        // Add the right class to the widget. The DOM is created
        // by hand, so classes need to be added programmatically
        put( this.domNode, '.editable-list' );

        // Add the dgrid, always in the middle. Note that it's crucial
        // that the widget inherits from DijitRegistry
        if( ! self.ListConstructor ){
           throw( new Error("You must specify a ListConstructor for this widget to work") );
        }
        self.listWidget = new this.ListConstructor( { store: this.store, region: 'center' } );
        //
        // The grid _needs_ to inherit from dgrid/extensions/DijitRegistry
        // as it's been added to a Dijit container
        if( this.listWidget.layoutPriority !== 0 ){
           throw( new Error("The Dgrid needs to inherit from dgrid/extensions/DijitRegistry in order to work here!") );
        }
        this.addChild( this.listWidget );


        // If there is a refreshData mmessage, then it will need to refresh the list as it might well
        // have changed
        self.own(
          topic.subscribe('refreshData', function( ){
            self.listWidget.refresh();

          })
        );


        // *****************************************
        // *** THE ADDING WIDGET                 ***
        // *****************************************

        // Create the adding widget, if a constructor
        // was passed
        if( self.addingWidgetRegion == '' ) self.addingWidgetRegion = 'top';
        if( self.AddingConstructor ){

          // Create the using the passed constructor. However,
          // it will set storeName, store (no recordId since it's an add)
          // Then, add it
          self.addingWidget = new self.AddingConstructor({
            storeName: self.storeName,
            store: self.store,
            region: self.addingWidgetRegion,
          });
          domClass.add( self.addingWidget.domNode, 'adding-form' );
          self.addChild( self.addingWidget );

          // if self.refreshOnSubmit is set, then a successful submit
          // will refresh the list
          if( self.refreshOnSubmit ){
            self.addingWidget.on('successfulsubmit', function( e ){
              self.listWidget.refresh();
            });
          }
        }


        // *****************************************
        // *** THE EDITING WIDGET*S*<--- plural! ***
        // *****************************************

        // Aspect to check if renderRow is called for a row that is being edited
        // IF that's the case, it will need to re-attach the editing widget's domNode
        // to it, so that it doesn't disappear (zapped by renderRow which returns a new DOM)
        if( self.editingWidgetPlacement === 'inline' ){
          self.own( aspect.around( self.listWidget, 'renderRow', function( renderRow ){

            return function( object, options ){
         
              var id = object[ self.store.idProperty ];
              if( self._inlineEditing[ id ] ){
                var r = renderRow( object, options );
                put( r, self._inlineEditing[ id ].editingWidget.domNode );
                return r;
              } else {
                return renderRow( object, options );
              }
            }

          }) );
        }

        // Make absolute sure that every row is rendered with "position: relative" so that
        // it works with inline editing
        self.own( aspect.around( self.listWidget, 'renderRow', function( renderRow ){
          return function( object, options ){
            var r = renderRow( object, options );
            domStyle.set( r, 'position', 'relative' );
            return r;
          }
        }) );


        // *****************************************
        // *** THE (MOVING) BUTTONS              ***
        // *****************************************

        if( self.ButtonsConstructor ){

          // BUTTONS: CREATION

          // Create the buttons widget, place it in the document body as
          // invisible
          self.buttons = new self.ButtonsConstructor( { listWidget: self } );
          self.buttons.startup();
          self.buttonsNode = self.buttons.domNode;
          put( document.body, self.buttonsNode );
          domStyle.set( self.buttonsNode, { display: 'none', opacity: '0' } );

          // BUTTONS: KEYBOARD

          // Pressing Enter will trigger the appearance of the
          // buttons in the right spot, and the focus on them
          self.listWidget.on( 'keypress' , function( e ){
            var row = self.row( e );

            if( e.charCode == 13 && ! self._inDeletion[ row.id ] ){
              var row = self.row( e );
              _buttonsToRow( row );
              if( self.buttons.focusNode) self.buttons.focusNode.focus(); 
            }
          });

          // Taking the focus out will make them disappear. This is
          // crucial for when they are created after pressing ENTER,
          // while the mouse pointer was *outside* the listWidget
          // (so there is no leave event)
          focusUtil.on("widget-blur", function( widget ){
            if( widget == self.buttons ){
              domStyle.set( self.buttonsNode, { display: 'none', opacity: '0' } );
            }
          });

          // BUTTONS: MOUSE


          // Make the edit/delete buttons appear if the mouse goes over them
          self.listWidget.on( mouse.enterRow, function(e){
            var row = self.row( e );
            _buttonsToRow( row );
          });

          // Make sure the buttons disappear if the mouse leaves the
          // widget. It's tricky, as hovering on the buttons themselves
          // ALSO means "leaving the widget". So, it's important to
          // check both

          self.own( on( self.buttonsNode, dojoMouse.enter, function(e){
            self._onButtonsNode = true;
          }) );

          self.own( on( self.buttonsNode, dojoMouse.leave, function(e){
            self._onButtonsNode = false;
            hideButtonsNode();
          }) );

          self.own( on( self.domNode, dojoMouse.enter, function(e){
            self._onWidget = true;
          }) );

          self.own( on( self.domNode, dojoMouse.leave, function(e){
            self._onWidget = false;
            hideButtonsNode();
          }) );

          function hideButtonsNode(){
            setTimeout( function(){
              if( !self._onWidget && !self._onButtonsNode ) {
                domStyle.set( self.buttonsNode, 'display', 'none' );
                // self._buttonsRowId = null; // TODO: Decide on this one
              }
            }, 0 );
          }
        }


        function _buttonsToRow( row ){

          // Set a default for buttonsPosition, if needed
          var buttonsPosition = self.buttonsPosition;
          if( buttonsPosition !== 'after' && buttonsPosition !== 'top' && buttonsPosition !== 'bottom' ){
            buttonsPosition = 'top';
          }

          // Don't show buttons if editing right now
          if( self._inlineEditing[ row.id ] ) return;

          // Already displaying buttons for that row, don't do anything
          if( self._buttonsRowId == row.id && domStyle.get( self.buttonsNode, 'display') != 'none' ) return;

          // Sets this one as the last row for which buttons were displayed
          self._buttonsRowId = row.id;

          // Don't show more buttons if a row is being edited and multipleEditingAllowed is false
          if( Object.keys( self._inlineEditing ).length > 0 && ! self.multipleEditingAllowed ) return;


          // Add the buttons if they are present. Manually place them in the right spot.
          // Note: they need to be outside of the document flow, or
          // you might not be able to edit the last element of the grid (as the
          // buttons fall under the visible area)
          if( self.buttonsNode ){ 
            
            var geoButtons = domGeometry.position( self.buttonsNode, false );
            domStyle.set( self.buttonsNode, { 'transition-duration' : 0 } );
            domStyle.set( self.buttonsNode, { display: 'block', opacity: '0' } );

            var geoRow = domGeometry.position( row.element, false );

            switch( buttonsPosition ){
              case 'top':
                domStyle.set( self.buttonsNode, 'top', (geoRow.y ) + 'px' );
              break;
              case 'bottom':
                domStyle.set( self.buttonsNode, 'top', (geoRow.y + geoRow.h - geoButtons.h ) + 'px' );
              break;
              case 'after':
                domStyle.set( self.buttonsNode, 'top', (geoRow.y + geoRow.h - 2 ) + 'px' );
              break;
            }
            domStyle.set( self.buttonsNode, 'left', ( geoRow.x ) + 'px' );

            domStyle.set( self.buttonsNode, { 'transition-duration': '0.4s' } );
            domStyle.set( self.buttonsNode, { opacity: '1' } );
          }

        }

      },


      destroy: function(){
        this.inherited(arguments);
      },


 
      // Allows editing of a row in a dialog box
      //
      _editInDialog: function( row ){
        var self = this;
        var editingWidget;

        // Create an editing widget using the passed constructor. However,
        // it will set storeName, storeFields and recordId
        editingWidget = new self.EditingConstructor({
          storeName: self.storeName,
          store: self.store,
          recordId: row.id,
        });
        domClass.add( editingWidget.domNode, 'editing-form' );

        // if self.refreshOnSubmit is set, then it will refresh the
        // list
        if( self.refreshOnSubmit ){
          editingWidget.on('successfulsubmit', function( e ){
            self.listWidget.refresh();
          });
        }


        // Make up the dialog with editing widget, show it
        self.dialog = new Dialog({
          title: "Edit",

          // The widget was created programmatically: destroy on hiding
          hide: function(){

            // Dialog.hide() returns a promise, which resolves when
            // the hiding animation is over. 
            // First of all, get this promise...
            var p = this.inherited('hide', arguments ); // Need the name, this will be lang.mixin, not declare.safeMixin

            // Attach a new callback triggered when the animation is over:
            // the callback will destroy the widget
            p.then( lang.hitch(this, function(){
              this.destroyRecursive();
            }));

            // Return the promise, in case other calls want to
            // attach more callbacks to it
            return p;
          },

        });

        // Add the child to the dialog, and show it
        self.dialog.addChild( editingWidget );
        self.dialog.startup();
        self.dialog.show();

        // When subimission is successful, 
        editingWidget.on( 'successfulsubmit', function(){
          self.dialog.hide();
          self.listWidget.focus( self.row( row.id) );  
        });

      },

      // Allows editing of a row inline
      //
      _editInline: function( row ){
        var self = this;
        var editingWidget;
        var keyHandler;

        if( self._inlineEditing[ row.id ] ) return;

        // Self._inlineEditing will be an object containing several rows
        // indexed by row.id and each row contains:
        //
        // element:        the element's domNode
        // editingWidget:  the editing widget attached to that row
        // 
        self._inlineEditing[ row.id ] = { element: row.element } ;


        domStyle.set( self.buttonsNode, { display: 'none' } );

        // Create an editing widget using the passed constructor. However,
        // it will set storeName, storeFields and recordId
        editingWidget = new self.EditingConstructor({
          storeName: self.storeName,
          store: self.store,
          recordId: row.id,
        });
        domClass.add( editingWidget.domNode, 'editing-form' );

        // if self.refreshOnSubmit is set, then it will refresh the
        // list
        if( self.refreshOnSubmit ){
          editingWidget.on('successfulsubmit', function( e ){
            self.listWidget.refresh();
          });
        }

        self._inlineEditing[ row.id ].editingWidget = editingWidget;

        // Give the row the class .dgrid-cell-editing
        put( row.element, ".dgrid-cell-editing");

        // Add the editing widget to the row domNode. It will have
        // absolute positioning, which means it will overlap
        // the actual row
        put( row.element, editingWidget.domNode );
        put( editingWidget.domNode, '.editable-list-row-editor' );

        // Basic styles to make sure that the editing widget is positioned correctly
        domStyle.set( row.element, 'position', 'relative' );

        // Startup and show the widget
        editingWidget.startup();
        editingWidget._onShow();

        // Escape and successful submit will close this form (properly)
        editingWidget.formWidget.on( 'keydown' , function( e ){
          if( e.keyCode == 27 ) closeThis(); 
        });
        editingWidget.on( 'successfulsubmit', function(){
          closeThis();
          self.listWidget.focus( self.row( row.id) );  
        });

        // If there is "escape" at widget level, then kill the editing.
        // This is necessary in case escape is pressed at widget level
        // and there are editing forms open and which won't get the focus
        // because of the overlay, or which don't have the focus full stop.
        keyHandler = self.on( 'keydown', function( e ){
          if( e.keyCode == 27 ){
            closeThis();
          }
        });

        // Close this form "properly":
        // * taking the class out
        // * delete the self.editing entry,
        // * destroy the widget
        function closeThis(){
          put( row.element, "!dgrid-cell-editing"); // Take out the extra editing class
          focusUtil.focus( self.row( row.id ).element );  
          delete self._inlineEditing[ row.id ]; // Delete the self._inlineEditing holder
          editingWidget.destroyRecursive(); // Destroy the widget and its children
          // self.listWidget.select( row.id );
          keyHandler.remove();
        }
      },


      _editRow: function( row ){
        var self = this;

        if( self.multipleEditingAllowed || Object.keys( self._inlineEditing ).length < 1 ){

          if( self.editingWidgetPlacement === 'inline' ){
            self._editInline( row );
          } else {
            self._editInDialog( row );
          }
        }       
      },

      _deleteRow: function( row ){

        var self = this;

        domStyle.set( self.buttons.domNode, { display: 'none' } );

        var myDialog = new ConfirmDialog({
          title: "Are you sure?",
          content: "Are you sure you want to delete the element?",
        });            
        myDialog.startup();
        myDialog.show();

        // Declined: give the focus back to the grid
        myDialog.on( 'dialogdeclined', function( e ){
          self.listWidget.focus( row );
        });


        // Confirmed: place an overlay on the row,
        // disable mouse events, and delete reporting
        // any errors
        myDialog.on( 'dialogconfirmed', function( e ){

          var cover = put( row.element, 'div.editable-list-overlay' );

          domStyle.set( row.element, 'pointer-events', 'none' );
          self._inDeletion[ row.id ] = true;
         
          when( self.store.remove( row.id )) .then(
            function( res ){
              self._inDeletion[ row.id ] = false;
               
            },
            function( err ){
              ds.UIErrorMsg( null, null, null )
              self._inDeletion[ row.id ] = false;
              put( row.element, cover, '!' );
              domStyle.set( row.element, 'pointer-events', 'all' );
              self.listWidget.focus( row );
            }
          )
        })
      }

    });
 
    // This needs to be available to developers so that they
    // can redefine the default ButtonsConstructor
    r.DefaultButtonsConstructor = DefaultButtonsConstructor;

    return r;

  });


