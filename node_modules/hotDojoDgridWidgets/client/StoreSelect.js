define([
   "dojo/_base/declare",
   "dojo/when",
   "dojo/topic",
   "dojo/on",
   "dojo/_base/lang",
   "dojo/dom-construct",
   "dojo/dom-style",
   "dojo/dom-attr",
   "dojo/dom-geometry",
   "dojo/aspect",

   "dijit/_WidgetBase",
   "dijit/Dialog",
   "dijit/_OnDijitClickMixin",
   "dijit/focus",
   "dijit/form/Button",
   "dijit/layout/BorderContainer",
   "dijit/_Container",
   "dijit/layout/_ContentPaneResizeMixin",
   "dijit/_TemplatedMixin",
   "dijit/_WidgetsInTemplateMixin",

   'dgrid/List',
   'dgrid/OnDemandList',
   "dgrid/Selection",
   "dgrid/Keyboard",
   "dgrid/util/mouse",
   "dgrid/extensions/DijitRegistry",
   'put-selector/put',

   "hotplate/hotDojoSubmit/defaultSubmit",
   "hotplate/hotDojoWidgets/BusyButton",
   "hotplate/hotDojoWidgets/ConfirmDialog",

   ], function(
     declare
     , when
     , topic
     , on
     , lang
     , domConstruct
     , domStyle
     , domAttr
     , domGeometry
     , aspect

     , _WidgetBase
     , Dialog
     , _OnDijitClickMixin
     , focusUtil
     , Button
     , BorderContainer
     , _Container
     , _ContentPaneResizeMixin
     , _TemplatedMixin
     , _WidgetsInTemplateMixin

     , List
     , OnDemandList
     , Selection
     , Keyboard
     , mouse
     , DijitRegistry
     , put

     , ds
     , BusyButton
     , ConfirmDialog

 ){


    return declare( [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, _Container, _ContentPaneResizeMixin, _OnDijitClickMixin ] , {

      templateString: '<div class="store-select">\n' +
                      '  <div data-dojo-attach-point="itemNode" class="donno">\n'+
                      '    <div class="label button"><div data-dojo-attach-point="labelNode">Pick</div></div>\n' +
                      '    <div class="arrow button"></div>\n' +
                      '  </div>\n'+
                      '  <div data-dojo-attach-point="listWidgetNode" class="dgrid-spot"></div>\n'+
                      '</div>\n'+
                      '\n'+
                      '',


      widgetsInTemplate: true,
      // Store
      storeName: '',
      store: null,
      query: {},
      queryOptions: {},
      renderRow: function( o ){ return "renderRow not defined"; } ,

      selectedId: null,
      listWidget: null,

      expanded: false,
      distanceFromBottom: 20,

      constructor: function( params ){
        // this.store = stores( params.storeName, params.storeFields );
      },

      // Proxy method for listwidget.row()
      row: function( p ){
        return this.listWidget.row( p );
      },

      postCreate: function(){

        var self = this;
        this.inherited(arguments); 

        put( self.domNode, '.dgrid-select' );

        var ListConstructor = declare( [ OnDemandList, Selection, Keyboard, DijitRegistry ], {
          renderRow: self.renderRow,
          selectionMode: 'single',
        } );

        // Make a listWidget
        self.listWidget = new ListConstructor( {
          store: this.store,
          query: self.query,
          queryOptions: this.queryOptions,

          // Adding and deleting rows will trigger the "position calculation"
          // function to make sure that the select list is not ourside of the
          // visible area
          newRow: function(){
            var r = this.inherited(arguments);
            self._moveIfNecessary();
            return r;
          },
          removeRow: function(){
            var r = this.inherited(arguments);
            self._moveIfNecessary();
            return r;
          },
          

        });

        // A record was selected beforehand: load it up
        if( this.selectedId !== null ){
          self.labelNode.innerHTML = "Loading...";

          when( self.store.get( self.selectedId ) ).then(
            function( res ) {
              self.labelNode.innerHTML = '';
              put( self.labelNode, self.renderRow( res ) );
              connectUp();
            },
            function( err ){
              self.labelNode.innerHTML = 'Error loading item!';
              self.selectedId = null;
              connectUp();
            }
          );

        } else {
          connectUp();
        }

        function connectUp(){

          // Place the grid, invisible, in the right domNode
          domStyle.set( self.listWidget.domNode, { display: 'none' } );
          domConstruct.place( self.listWidget.domNode, self.listWidgetNode );
          self.listWidget.startup();
          
          self.listWidget.on("dgrid-select", function( e ) {
            var row = e.rows[0];
            self.selectedId = row.id;

            self.labelNode.innerHTML = '';
            put( self.labelNode, self.renderRow( row.data ) );
          });

          self.own( 

            // If this store is updated, and the change is in the selected item,
            // refresh the selected item
            // FIXME: Is there a generic way of doing this, other than making a query just for
            // this element?
            topic.subscribe('storeUpdate', function( from, message){
              if( message.storeName === self.storeName && message.objectId === self.selectedId ){
                self.labelNode.innerHTML = '';
                put( self.labelNode, self.renderRow( message.object ) );
              }
            }),


            // Escape pressed at body level: close the select box
            on( document.body, 'keydown', function( e ) {
              if( e.keyCode == 27 && self.expanded){
                domStyle.set( self.listWidget.domNode, { display: 'none' } );
                self.expanded = false;
                self.listWidget.clearSelection();
                self.listWidget.select( self.selectedIdWhenOpen );
              }
            }),


            on( self.domNode, 'keydown', function( e ){

              if( e.keyCode == 13 ){

                if( ! self.expanded  ){
                  expandList();
                } else {
                  collapseList( self.row( e ) );
                }
              }

            }),

            on( self.domNode, 'click', function( e ){
              if( ! self.expanded ){ 
                expandList();
              } else {
                collapseList( self.row( e ) );
             }
            }),


            // Focus out: hide the select box
            // Haven't quite managed this one yet
            on( document.body, 'click', function( e ) {
              if( self.expanded){
              //  domStyle.set( self.listWidget.domNode, { display: 'none' } );
              //  self.expanded = false;
              }
            })

          );

          function expandList(){
            self.selectedIdWhenOpen = self.selectedId;
            domStyle.set( self.listWidget.domNode, { display: 'block' } );
            self.listWidget.focus();
            self.expanded = true;
            self._moveIfNecessary();
          }

          function collapseList( row ){

            domStyle.set( self.listWidget.domNode, { display: 'none' } );
            self.expanded = false;
            if( row ){ 
              self.selectedId = row.id;
              self.labelNode.innerHTML = '';
              put( self.labelNode, self.renderRow( row.data ) );
            }
          }
        }

      },

      _moveIfNecessary: function(){
        var self = this;

        //self.listWidget.resize();
        domStyle.set( self.listWidget.domNode, { top: '' } );
        var bodyBox = domGeometry.getContentBox( document.body );
        var listBox = domGeometry.position( self.listWidget.domNode, true );
        var delta = bodyBox.h - ( listBox.y + listBox.h ) - self.distanceFromBottom;
        if( delta < 0 ){
          domStyle.set( self.listWidget.domNode, { top: (delta)+'px' } );
        } else {
          domStyle.set( self.listWidget.domNode, { top: '' } );
        }


      },

      resize: function(){
        this.listWidget.resize();

        this.inherited(arguments); 
      },

      destroy: function(){
        this.listWidget.destroy();

        this.inherited(arguments); 
      },

      startup: function(){
        this.inherited(arguments); 
      },

    });
 

});

