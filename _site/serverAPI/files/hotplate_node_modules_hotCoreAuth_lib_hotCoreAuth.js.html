<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>hotplate/node_modules/hotCoreAuth/lib/hotCoreAuth.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/weblookalike.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">


 <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mercmobily/hotplate">View on GitHub</a>

          <div id="main_menu">
            <ul>
               <li><a href="https://www.hotplatejs.com">Home</a></li>
               <li><a href="https://www.hotplatejs.com/guide.html">Guide</a></li>
               <li><a href="https://www.hotplatejs.com/serverAPI.html">Server API</a></li>
               <li><a href="https://www.hotplatejs.com/clientAPI.html">Client API</a></li>
            </ul>
           </div>
            
          <a id="main_menu" href="https://github.com/mercmobily/hotplate">View on GitHub</a>


          <h1 id="project_title">Hotplate -- server API</h1>
          <h2 id="project_tagline">Multi-homed SaaS with NodeJs, Express, (any)DB, Dojo</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/mercmobily/hotplate/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/mercmobily/hotplate/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>



<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">




           <!-- 
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
            -->

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/hotCoreAuth.html">hotCoreAuth</a></li>
            
                <li><a href="../classes/hotCoreAuth.facebook.html">hotCoreAuth.facebook</a></li>
            
                <li><a href="../classes/hotCoreClientFiles.html">hotCoreClientFiles</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/hotCoreAuth.html">hotCoreAuth</a></li>
            
                <li><a href="../modules/hotCoreClientFiles.html">hotCoreClientFiles</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: hotplate/node_modules/hotCoreAuth/lib/hotCoreAuth.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var dummy
  , path = require(&#x27;path&#x27;)
  , hotplate = require(&#x27;hotplate&#x27;)
  , declare = require(&#x27;simpledeclare&#x27;)

  , e = require(&#x27;allhttperrors&#x27;)

  // Stores
  , Schema = require(&#x27;simpleschema&#x27;)
  , MongoSchemaMixin = require(&#x27;simpleschema/MongoSchemaMixin.js&#x27;)

  , Store = require(&#x27;jsonreststores&#x27;)
  , MongoDriverMixin = require(&#x27;jsonreststores/MongoDriverMixin.js&#x27;)

  // Passport stuff
  , passport = require(&#x27;passport&#x27;)
  , FacebookStrategy = require(&#x27;passport-facebook&#x27;).Strategy
  , LocalStrategy = require(&#x27;passport-local&#x27;).Strategy
;

/**
Provides authentication abilities to Hotplate

This module&#x27;s goal is to do two things.

First of all , it defines all of the stores necessary for authentication. The stores in question are:

* Users. The list of users.
* UserStrategies. The list of strategies set bu that user.
* AuthStrategies. The complete list of auth strategies available
* UserLogins. A store that simply allows the search of username, used by Ajax to check if a username is already taken



@module hotCoreAuth
@main hotCoreAuth
@class hotCoreAuth
@static
*/

// Define store and mongo drivers.

var app = hotplate.app;

var hooks = exports.hotHooks = {}


/**
  Initialisation hook. It creates the basic authentication stores
  (Users, UserStrategies, AuthStrategies, UserLogins) 

  @event init
  @requires hotCoreJsonRestStores
*/

hooks.init = function( done ){

  var hotCoreJsonRestStores = hotplate.getModule( &#x27;hotCoreJsonRestStores&#x27; );

  Store = declare( [ Store, MongoDriverMixin, hotCoreJsonRestStores.StoreMixin ] );
  Schema = declare( [ Schema, MongoSchemaMixin, hotCoreJsonRestStores.SchemaMixin ] );

  BasicStore = require(&#x27;jsonreststores&#x27;);


  // ***********************************
  // *** USERS *************************
  // ***********************************

  exports.Users = declare( Store, {

    // COMMON
    schema: new Schema({
      _id:                 { type: &#x27;id&#x27; },

      recoverToken:        { type: &#x27;string&#x27;, searchable: true, searchPartial: false, sortable: false, notempty: true },
      recoverTokenCreated: { type: &#x27;date&#x27;, searchable: true, searchPartial: false, sortable: false, notempty: true },

      // name: { type: &#x27;string&#x27;, searchable: true, searchPartial: false, sortable: false, notEmpty: true, sharedValidator: &#x27;user&#x27;, trim: 15 },
    }),

    // #4
    publicURL: &#x27;/users/&#x27;,

    storeName:  &#x27;users&#x27;,
    paramIds: [ &#x27;_id&#x27; ],

  });

  // Users.onlineAll( app, &#x27;/users/&#x27;, &#x27;:_id&#x27; );

  var UserStrategies = exports.UserStrategies = declare( Store, {

    schema: new Schema({
      _id       :  { type: &#x27;id&#x27; },

      strategyId:  { type: &#x27;string&#x27;, required: true, trim: 30 }  ,
      userId:      { type: &#x27;id&#x27;, required: true },

      field1:      { type: &#x27;string&#x27;, required: false, trim: 255 } ,
      field2:      { type: &#x27;string&#x27;, required: false, trim: 255 } ,
      field3:      { type: &#x27;string&#x27;, required: false, trim: 255 } ,
      field4:      { type: &#x27;string&#x27;, required: false, trim: 255 } ,
    }),

    searchSchema: new Schema({
      _id       :  { type: &#x27;id&#x27; },
      strategyId:  { type: &#x27;string&#x27;, trim: 30 }  ,
      userId:      { type: &#x27;id&#x27; },

      field1:      { type: &#x27;string&#x27;, trim: 255 } ,
      field2:      { type: &#x27;string&#x27;, trim: 255 } ,
      field3:      { type: &#x27;string&#x27;, trim: 255 } ,
      field4:      { type: &#x27;string&#x27;, trim: 255 } ,

    }),

		storeName:  &#x27;userStrategies&#x27;,

    // #3
 
    handleGet: true,
    checkPermissionsGet: function( params, body, options, doc, fullDoc, cb ){
      // Only their own strategies
      if( this._req.session.userId != params.userId ) return cb( null, false );

      cb( null, true );
    },

    handleGetQuery: true,
    checkPermissionsGetQuery: function( params, body, options, cb ){
      // Only their own strategies
      if( this._req.session.userId != params.userId ) return cb( null, false );
      
      // TODO: Don&#x27;t filter by fieldX
      if( typeof( options.filters ) === &#x27;object&#x27; &amp;&amp; ( options.filters.field1 || options.filters.field1 || options.filters.field3 || options.filters.field4 )  ){
        cb( null, false );
      }

      cb( null, true );
    },

    // Make sure that, if the request is from the web, field3 and field4 are out of the equation as
    // they often include nice goodies like passwords etc.
    extrapolateDoc: function( params, body, options, fullDoc, cb ){
      if( ! this.remote ) return cb( null, fullDoc );

      // Copy body onto newBody, leaving out fieldX 
      var doc = {};
      for( var i in fullDoc ){
        if( i != &#x27;field3&#x27; &amp;&amp; i != &#x27;field4&#x27; ) doc[ i ] = fullDoc[ i ];
      }
      cb( null, doc );
      
    },


    handleDelete: true,
    checkPermissionsDelete: function( params, body, options, doc, fullDoc, cb ){

      // Only their own strategies
      if( this._req.session.userId != params.userId ) return cb( null, false );

      UserStrategies.GetQuery( { filters: { userId: doc.userId } }, function( err, queryDocs, idProperty){
        if( queryDocs.length &gt; 1 ){
          cb( null, true );
        } else {
          cb( null, false );
        }
      });

    },

    paramIds: [ &#x27;userId&#x27;, &#x27;_id&#x27; ],

    publicURL: &#x27;/user/:userId/strategies/&#x27;,

  });

  // UserStrategies.onlineAll( app, &#x27;/user/:userId/strategies/&#x27;, &#x27;:_id&#x27; );


  var AuthStrategies = exports.AuthStrategies = declare( BasicStore, {

    // COMMON
    schema: new Schema({
      strategyId:        { type: &#x27;string&#x27;, isRequired: true, trim: 30 }  ,
    }),

    handlePut: false,
    handlePost: false,
    handleGet: true,
    handleGetQuery: true,
    handleDelete: false,

    storeName:  &#x27;authStrategies&#x27;,
    paramIds: [ &#x27;strategyId&#x27; ],

    driverAllDbFetch: function( params, body, options, cb ){
      var strategies = hotplate.get(&#x27;hotCoreAuth/strategies&#x27;);
      var doc;

      // No strategies defined in Hotplate, end of story
      if( typeof( strategies ) === &#x27;undefined&#x27; ){
        return cb( null, null );     
      }
 
      // Check if the strategy is one of the ones defined in Hotplate
      if( typeof( strategies[ params[ &#x27;strategyId&#x27; ] ] ) !== &#x27;undefined&#x27; ){
        doc = {}
        doc.strategyId = params[ &#x27;strategyId&#x27; ];
      } else {
        doc = null;
      }

      // Return whatever was found
      cb( null, doc );
    },

    driverGetDbQuery: function( params, body, options, cb ){
      var strategies = hotplate.get(&#x27;hotCoreAuth/strategies&#x27;);
      var doc;
      var docs = [];
      
      for( var strategyId in strategies ){
        docs.push( { strategyId: strategyId } );
      }      
      cb( null, docs );
    },

    publicURL: &#x27;/authStrategies/&#x27;,

  });

  //AuthStrategies.onlineAll( app, &#x27;/authStrategies/&#x27;, &#x27;:strategyId&#x27; );


  // This is used so that an applicaton can know in advance if a user login is already taken
  var UserLogins = exports.UserLogins = declare( BasicStore, {

    schema: new Schema({
      login     :  { type: &#x27;string&#x27;, required: true, lowercase: true, trim: 30, searchable: true },
    }),

		storeName:  &#x27;userLogins&#x27;,

    handlePut: false,
    handlePost: false,
    handleGet: false,
    handleGetQuery: true,
    handleDelete: false,

    paramIds: [ &#x27;_id&#x27; ],

    driverGetDbQuery: function( params, body, options, cb ){
      
      var self = this;

      UserStrategies.GetQuery( { filters: { strategyId: &#x27;local&#x27;, field1: options.filters.login } }, function( err, res ){
        if( err ){
          cb( err, null );
        } else {
          if( res.length ){
            self.schema.makeId( res, function( err, id ){
              cb( null, [ { login: options.filters.login, _id: id } ] );
            });
          } else {
            cb( null, [ ] );
          }
        }
      });      

    },   

    publicURL: &#x27;/userLogins/&#x27;,

  });

  //UserLogins.onlineAll( app, &#x27;/userLogins/&#x27;, &#x27;:_id&#x27; );




  done( null );
}
hooks.init.after = [ &#x27;hotCoreJsonRestStores&#x27; ];

/**
Sets recover URL &#x60;/recover/:recoverToken&#x60; (for token recovery).  
Also goes through the list of &#x60;AuthStrategies&#x60;, loads the right
files in &#x60;auth/{strategy name}.js&#x60; (e.g. {{#crossLink &quot;hotCoreAuth.facebook&quot;}}{{/crossLink}}), and runs them.
This basically ensures that all strategies have the right URLs all set for them to work.

@event run
*/
hooks.run = function( done ){

  

  app.get(&#x27;/recover/:recoverToken&#x27;, function( req, res, next ){

    exports.Users.GetQuery( { filters: { recoverToken: req.params[ &#x27;recoverToken&#x27; ] } }, function( err, result ){
      if( err ){
        done( err, null );
      } else {
        if( result.length == 0 ){
          // Error page

          // Artificially create a TokenInvalid error, and next( err ) it 
          var error = new Error();
          error.name = &quot;TokenInvalidError&quot;;
          error.message = &quot;Token not valid!&quot;;
          req.hotError = error;
          next( error );

          // hotplate.get(&#x27;errorPage&#x27;)(req, res, next);
        } else {
        
          var user = result[0];

          if( ! user.recoverTokenCreated ){

            // Artificially create a TokenDateInvalid error, and next( err ) it 
            var error = new Error();
            error.name = &quot;TokenDateInvalidError&quot;;
            error.message = &quot;Token date invalid!&quot;;
            req.hotError = error;
            next( error );

            // hotplate.get(&#x27;errorPage&#x27;)(req, res, next);
          } else {

            // Get the important variables 
            var tokenAgeInSeconds = Math.round( ( (new Date() ) - user.recoverTokenCreated ) / 1000 );
            var recoverURLexpiry = hotplate.get( &#x27;hotCoreAuth&#x27; ).recoverURLexpiry || 300; 

            var tokenIsGood = tokenAgeInSeconds &lt; recoverURLexpiry;

            if( ! tokenIsGood ){

              // Artificially create a TokenExpired error, and next( err ) it 
              var error = new Error();
              error.name = &quot;TokenExpiredError&quot;;
              error.message = &quot;Token expired!&quot;;
              req.hotError = error;
              next( error );

              // hotplate.get(&#x27;errorPage&#x27;)(req, res, next);
            } else {

              delete user.recoverToken;
              delete user.recoverTokenCreated;

              exports.Users.Put( user._id, user, function( err, userNew ){
                if( err ){
                  next( err );
                } else {

                  // Log the user in using the token!
                  req.session.loggedIn = true;
                  req.session.userId = user._id;

                  // Redirect to the right URL
                  var redirectURLs = hotplate.get(&#x27;hotCoreAuth/redirectURLs/success&#x27;);
                  res.redirect( redirectURLs[&#x27;recover&#x27; ] || &#x27;/&#x27; );
                }
  
              });
            }
             

          }
          
        }
          
      }
    });


  }); 



  function makeResponder( req, res, next, strategyId, action ) {

    return function(err, user, profile ) {

      var responseType, strategies;
        
      // #2      

      var k = req.cookies[ strategyId + &#x27;-&#x27; + action ];
      if( typeof( k ) !== &#x27;undefined&#x27; ){
        responseType = k;
      }

      // Fallback option
      if( ! responseType ) responseType = &#x27;redirect&#x27;;

      // Defaults to an empty profile object
      if( typeof( profile ) === &#x27;undefined&#x27; ){
        profile = {};
      }

      // Error: just return/next that
      if( err ) { return next( err ); }

      // #1

      switch( responseType ){

        case &#x27;content&#x27;:

            // Work out the page&#x27;s content by calling the user-set hotCoreAuth/responsePage function
            // Note: if hotCoreAuth/responsePage is not set, it will use a placeholder fallback string
            var content;
            var contentFunction = hotplate.get( &#x27;hotCoreAuth/responsePage&#x27; );
            if( typeof( contentFunction ) === &#x27;function&#x27; ){
              content = contentFunction( strategyId, action, user, profile );
            } else {
              content = &quot;PLEASE SET hotCoreAuth/responsePage IN YOUR SERVER FILE TO CUSTOMIZE CONTENTS&quot;;
            }


            // Send the contents
            res.send( content );      
        break;



        case &#x27;close&#x27;:

          if( ! user &amp;&amp; typeof( profile.message) !== &#x27;undefined&#x27;  ){
            
            // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
            res.send(&#x27;&lt;html&gt;&lt;script&gt;window.opener.alert(&quot;&#x27; + profile.message + &#x27;&quot;);window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
          } else {
            res.send(&#x27;&lt;html&gt;&lt;script&gt;window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
          }
        break;

        case &#x27;ajax&#x27;:

          if( user ){
            res.json( 200, { user: user, profile: profile } );
          } else {
            var error = &#x27;Authentication error&#x27;;
            if( typeof( profile.message) !== &#x27;undefined&#x27; ) error =  profile.message;
            res.json( 403, { message: error } );
          }

        break;


        case &#x27;redirect-opener&#x27;:

          if( ! user &amp;&amp; typeof( profile.message) !== &#x27;undefined&#x27;  ){

            // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
            res.send(&#x27;&lt;html&gt;&lt;script&gt;window.opener.alert(&quot;&#x27; + profile.message + &#x27;&quot;);window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
            
          } else {
            var redirectURLs = hotplate.get(&#x27;hotCoreAuth/redirectURLs/success&#x27;) || {};
            var redirectURL = redirectURLs[ action ] || &#x27;/&#x27; ;
            console.log( &quot;SUCCESS URL:&quot; );
            console.log( redirectURL );
            res.send(&#x27;&lt;html&gt;&lt;script&gt;window.opener.location = &quot;&#x27; + redirectURL + &#x27;&quot;;window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
          }
        break;


        case &#x27;redirect&#x27;:
        default:

          if( user ){

            var redirectURLs = hotplate.get(&#x27;hotCoreAuth/redirectURLs/success&#x27;) || {};
            res.redirect( redirectURLs[ action ] || &#x27;/&#x27; );
          } else {

            // Add the error to the session messages
            if( typeof( profile.message) !== &#x27;undefined&#x27;  ){
              req.session.messages = req.session.messages || []; 
              req.session.messages.push( { type: &#x27;error&#x27;, message: profile.message } );
            }

            var redirectURLs = hotplate.get(&#x27;hotCoreAuth/redirectURLs/fail&#x27;);
            res.redirect( redirectURLs[ action ] || &#x27;/&#x27; );
          }
        break;

      }

    }
  }

  if( typeof( hotplate.get(&#x27;hotCoreAuth/strategies&#x27; )) === &#x27;object&#x27; ){
    Object.keys( hotplate.get(&#x27;hotCoreAuth/strategies&#x27; )).forEach( function( strategyName ) {
    
      // Get the strategy&#x27;s data
      var strategyConfig = hotplate.get(&#x27;hotCoreAuth/strategies&#x27; )[strategyName];

      // Gets the right strategy maker and runs it
      strategyMaker = require( &#x27;./auth/&#x27; + strategyName );
      strategyMaker( strategyConfig, makeResponder, exports.AuthStrategies, exports.Users, exports.UserStrategies, exports.UserLogins );
    });

  }

  done( null );

}


hooks.stores = function( done ){

  done( null,  {
    moduleName: &#x27;hotCoreAuth&#x27;, result: [ exports.Users, exports.UserStrategies, exports.AuthStrategies, exports.UserLogins ]
  });

}

hooks.pageElements = function( done ){
  var strategyIds = Object.keys( hotplate.get(&#x27;hotCoreAuth/strategies&#x27;) ) || [];
  
  done( null, { moduleName: &#x27;hotCoreAuth&#x27;, result: {
    vars:  [
             { name: &#x27;strategyIds&#x27;,  value: strategyIds },
             { name: &#x27;successURLs&#x27;,  value: hotplate.get(&#x27;hotCoreAuth/redirectURLs/success&#x27;) },
             { name: &#x27;failURLs&#x27;,     value: hotplate.get(&#x27;hotCoreAuth/redirectURLs/fail&#x27;) },
           ],
  } } );
}


hooks.pageElementsPerPage = function( elements, req, pageName, done ){

  var vars = [];

  // Add the user ID to the page as a variable
  if( req.session.userId ) {
    vars.push( { name: &#x27;userId&#x27;, value: req.session.userId } );
  }

  // Add the successURL/failURLs objects, needed by authentication modules (such as hotDojoAuth)
  //vars.push( { name: &#x27;successURLs&#x27;, value: hotplate.get(&#x27;hotCoreAuth/redirectURLs/success&#x27;) } );
  //vars.push( { name: &#x27;failURLs&#x27;, value: hotplate.get(&#x27;hotCoreAuth/redirectURLs/fail&#x27;) } );
  //vars.push( { name: &#x27;multiHomeURL&#x27;, value: hotplate.get(&#x27;hotCoreAuth&#x27;).multiHomeURL } );

  done( null, { moduleName: &#x27;hotCoreAuth&#x27;, result: {
    vars: vars 
  } } );

}



/*

#1

      // If a user was actually created, call the appropriate callback if it&#x27;s needed
      if( user ){
        hotplate.invokeAll(&#x27;hotCoreAuth/userRegistered&#x27;, user, function(){} );
      }

#2
      // If it was passed by a body parameter, then listen to it
      //if( typeof( req.body.responseType ) !== &#x27;undefined&#x27; ){
      if( false ){
        responseType = req.body.responseType;

        console.log(&quot;GOT responseType FROM FORM!&quot;);

      // Otherwise, try to get it from a cookie
      } else {
        var k = req.cookies[ strategyId + &#x27;-&#x27; + action ];
        if( typeof( k ) !== &#x27;undefined&#x27; ){
          responseType = k;
        }

      }



*/



    // #3
    /*
    // Put is managed to &quot;save&quot; strategy data (for strategies that store something in fields)
    handlePut: true,
    checkPermissionsPutExisting: function( params, body, options, doc, fullDoc, cb ){
      // Only their own strategies
      if( this._req.session.userId != params.userId ) return cb( null, false );
      cb( null, true );
    },
    checkPermissionsPutNew: function( params, body, options, cb ){
      // Only their own strategies
      if( this._req.session.userId != params.userId ) return cb( null, false );
      cb( null, true );
    },

    */

    // #4
     /*
    handlePut: true,
    checkPermissionsPutNew: function( params, body, options, cb ){
      if( params._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },
    checkPermissionsPutExisting: function( params, body, options, doc, fullDoc, cb ){
      if( doc._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },

    handlePost: true,
    checkPermissionsPost: function( params, body, options, cb ){
      if( params._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },

    handleGet: true,
    checkPermissionsGet: function( params, body, options, cb ) {
      if( doc._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },

    handleDelete: true,
    checkPermissionsDelete: function( params, body, options, doc, fullDoc, cb ){
      if( doc._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },
    */




    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
