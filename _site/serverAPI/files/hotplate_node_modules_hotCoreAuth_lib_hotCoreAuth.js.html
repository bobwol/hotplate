<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Hotplate server API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/weblookalike.css" id="site_styles">
    <link rel="stylesheet" href="/global/header.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">


    <!-- HEADER -->
    <div id="header_wrap" class="outer">

        <div class="main_menu">
             <span><a href="/">Home</a></span>
             <span><a href="/guide.html">Guide</a></span>
             <span><a href="/serverAPI/index.html">Server API</a></span>
             <span><a href="/clientAPI/index.html">Client API</a></span>
        </div>

        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mercmobily/hotplate">View on GitHub</a>

            
          <h1 id="project_title">Hotplate server API</h1>
          <h2 id="project_tagline">Multi-homed SaaS with NodeJs, Express, (any)DB, Dojo</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/mercmobily/hotplate/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/mercmobily/hotplate/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>



<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">




           <!-- 
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
            -->

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/hotCoreAuth.html">hotCoreAuth</a></li>
            
                <li><a href="../classes/hotCoreAuth.facebook.html">hotCoreAuth.facebook</a></li>
            
                <li><a href="../classes/hotCoreClientFiles.html">hotCoreClientFiles</a></li>
            
                <li><a href="../classes/hotCoreMultiHome.html">hotCoreMultiHome</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/hotCoreAuth.html">hotCoreAuth</a></li>
            
                <li><a href="../modules/hotCoreClientFiles.html">hotCoreClientFiles</a></li>
            
                <li><a href="../modules/hotCoreMultiHome.html">hotCoreMultiHome</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: hotplate/node_modules/hotCoreAuth/lib/hotCoreAuth.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var dummy
  , path = require(&#x27;path&#x27;)
  , hotplate = require(&#x27;hotplate&#x27;)
  , declare = require(&#x27;simpledeclare&#x27;)

  , e = require(&#x27;allhttperrors&#x27;)

  // Stores
  , SimpleSchema = require(&#x27;simpleschema&#x27;)
  , MongoSchemaMixin = require(&#x27;simpleschema/MongoSchemaMixin.js&#x27;)

  , JsonRestStore = require(&#x27;jsonreststores&#x27;)
  , MongoDriverMixin = require(&#x27;jsonreststores/MongoDriverMixin.js&#x27;)

  // Passport stuff
  , passport = require(&#x27;passport&#x27;)
  , FacebookStrategy = require(&#x27;passport-facebook&#x27;).Strategy
  , LocalStrategy = require(&#x27;passport-local&#x27;).Strategy

  , hotCoreJsonRestStores = require( &#x27;hotCoreJsonRestStores&#x27; )
  , hotCoreStoreRegistry = require( &#x27;hotCoreStoreRegistry&#x27; )
;

/**
Provides authentication abilities to Hotplate

This module&#x27;s goal is to do two things.

First of all , it defines all of the stores necessary for authentication. The stores in question are:

* Users. The list of users.
* UserStrategies. The list of strategies set bu that user.
* AuthStrategies. The complete list of auth strategies available
* UserLogins. A store that simply allows the search of username, used by Ajax to check if a username is already taken



@module hotCoreAuth
@main hotCoreAuth
@class hotCoreAuth
@static
*/

// Set some sane defaults

var basicResponsePage = function( strategyId, action, user, profile ){
  var response = &#x27;&#x27;;
  response += &quot;&lt;html&gt;&lt;body&gt;&lt;script type=\&quot;text/javascript\&quot;&gt;setTimeout(function(){ window.close() }, 5000);&lt;/script&gt; RESPONSE&lt;/body&gt;&lt;/html&gt;&quot;;
  return response;
};



hotplate.config.set(&#x27;hotCoreAuth&#x27;, {

  callbackURLBase: &#x27;http://localhost:3000&#x27;,

  recoverURLexpiry: 60*30, // Seconds for which the recover URL works for

  // Only local strategy enabled by default
  strategies: {
    local: { },
  },

  redirectURLs: {
    success: {
      signin: &#x27;/pages/pick&#x27;,
      recover: &#x27;/pages/pick&#x27;,
      register: &#x27;/pages/pick&#x27;,
      manager: &#x27;/&#x27;,
    },

    fail: {
      signin: &#x27;/pages/welcome&#x27;,
      recover: &#x27;/pages/welcome&#x27;,
      register: &#x27;/pages/welcome&#x27;,
      manager: &#x27;/&#x27;,
    }
  },
  responsePage: basicResponsePage,
  appURL: &#x27;/app&#x27;,

});


/**
  Initialisation hook. It creates the basic authentication stores
  (Users, UserStrategies, AuthStrategies, UserLogins) 

  @event init
  @requires hotCoreJsonRestStores
*/

hotplate.hotEvents.on( &#x27;stores&#x27;, &#x27;hotCoreAuth&#x27;, function( done ){

  var stores = {}

  hotCoreJsonRestStores.getJsonRestStoresMixins( function( err, mixins ){
    if( err ){
      done( err );
    } else {

      var Store = declare( [ JsonRestStore, MongoDriverMixin, mixins.StoreMixin ] );
      var Schema = declare( [ SimpleSchema, MongoSchemaMixin, mixins.SchemaMixin ] );

      // ***********************************
      // *** USERS *************************
      // ***********************************
    
      stores.Users = declare( Store, {
    
        // COMMON
        schema: new Schema({
          _id:                 { type: &#x27;id&#x27; },
    
          recoverToken:        { type: &#x27;string&#x27;, searchable: true, searchPartial: false, sortable: false, notempty: true },
          recoverTokenCreated: { type: &#x27;date&#x27;, searchable: true, searchPartial: false, sortable: false, notempty: true },
    
          // name: { type: &#x27;string&#x27;, searchable: true, searchPartial: false, sortable: false, notEmpty: true, sharedValidator: &#x27;user&#x27;, trim: 15 },
        }),
    
        publicURL: &#x27;/users/&#x27;,
    
        storeName:  &#x27;users&#x27;,
        paramIds: [ &#x27;_id&#x27; ],
    
      });
    
      stores.UserStrategies = declare( Store, {
    
        schema: new Schema({
          _id       :  { type: &#x27;id&#x27; },
    
          strategyId:  { type: &#x27;string&#x27;, required: true, trim: 30 }  ,
          userId:      { type: &#x27;id&#x27;, required: true },
    
          field1:      { type: &#x27;string&#x27;, required: false, trim: 255 } ,
          field2:      { type: &#x27;string&#x27;, required: false, trim: 255 } ,
          field3:      { type: &#x27;string&#x27;, required: false, trim: 255 } ,
          field4:      { type: &#x27;string&#x27;, required: false, trim: 255 } ,
        }),
    
        searchSchema: new Schema({
          _id       :  { type: &#x27;id&#x27; },
          strategyId:  { type: &#x27;string&#x27;, trim: 30 }  ,
          userId:      { type: &#x27;id&#x27; },
    
          field1:      { type: &#x27;string&#x27;, trim: 255 } ,
          field2:      { type: &#x27;string&#x27;, trim: 255 } ,
          field3:      { type: &#x27;string&#x27;, trim: 255 } ,
          field4:      { type: &#x27;string&#x27;, trim: 255 } ,
    
        }),
    
    		storeName:  &#x27;userStrategies&#x27;,
    
        // #3
     
        handleGet: true,
        checkPermissionsGet: function( params, body, options, doc, fullDoc, cb ){
          // Only their own strategies
          if( this._req.session.userId != params.userId ) return cb( null, false );
    
          cb( null, true );
        },
    
        handleGetQuery: true,
        checkPermissionsGetQuery: function( params, body, options, cb ){
          // Only their own strategies
          if( this._req.session.userId != params.userId ) return cb( null, false );
          
          // TODO: Don&#x27;t filter by fieldX
          if( typeof( options.filters ) === &#x27;object&#x27; &amp;&amp; ( options.filters.field1 || options.filters.field2 || options.filters.field3 || options.filters.field4 )  ){
            cb( null, false );
          }
    
          cb( null, true );
        },
    
        // Make sure that, if the request is from the web, field3 and field4 are out of the equation as
        // they often include nice goodies like passwords etc.
        extrapolateDoc: function( params, body, options, fullDoc, cb ){
          if( ! this.remote ) return cb( null, fullDoc );
    
          // Copy body onto newBody, leaving out fieldX 
          var doc = {};
          for( var i in fullDoc ){
            if( i != &#x27;field3&#x27; &amp;&amp; i != &#x27;field4&#x27; ) doc[ i ] = fullDoc[ i ];
          }
          cb( null, doc );
          
        },
    
    
        handleDelete: true,
        checkPermissionsDelete: function( params, body, options, doc, fullDoc, cb ){
    
          // Only their own strategies
          if( this._req.session.userId != params.userId ) return cb( null, false );
    
          UserStrategies.GetQuery( { filters: { userId: doc.userId } }, function( err, queryDocs, idProperty){
            if( queryDocs.length &gt; 1 ){
              cb( null, true );
            } else {
              cb( null, false );
            }
          });
    
        },
    
        paramIds: [ &#x27;userId&#x27;, &#x27;_id&#x27; ],
    
        publicURL: &#x27;/user/:userId/strategies/&#x27;,
    
      });
    
    
      stores.AuthStrategies = declare( JsonRestStore, {
    
        // COMMON
        schema: new Schema({
          strategyId:        { type: &#x27;string&#x27;, isRequired: true, trim: 30 }  ,
        }),
    
        handlePut: false,
        handlePost: false,
        handleGet: true,
        handleGetQuery: true,
        handleDelete: false,
    
        storeName:  &#x27;authStrategies&#x27;,
        paramIds: [ &#x27;strategyId&#x27; ],
    
        driverAllDbFetch: function( params, body, options, cb ){
          var strategies = hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27;);
          var doc;
    
          // No strategies defined in Hotplate, end of story
          if( typeof( strategies ) === &#x27;undefined&#x27; ){
            return cb( null, null );     
          }
     
          // Check if the strategy is one of the ones defined in Hotplate
          if( typeof( strategies[ params.strategyId ] ) !== &#x27;undefined&#x27; ){
            doc = {}
            doc.strategyId = params[ &#x27;strategyId&#x27; ];
          } else {
            doc = null;
          }
    
          // Return whatever was found
          cb( null, doc );
        },
    
        driverGetDbQuery: function( params, body, options, cb ){
          var strategies = hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27;);
          var doc;
          var docs = [];
          
          for( var strategyId in strategies ){
            docs.push( { strategyId: strategyId } );
          }      
          cb( null, docs );
        },
    
        publicURL: &#x27;/authStrategies/&#x27;,
    
      });
    
    
      // This is used so that an applicaton can know in advance if a user login is already taken
      stores.UserLogins = declare( JsonRestStore, {
    
        schema: new Schema({
          login     :  { type: &#x27;string&#x27;, required: true, lowercase: true, trim: 30, searchable: true },
        }),
    
    		storeName:  &#x27;userLogins&#x27;,
    
        handlePut: false,
        handlePost: false,
        handleGet: false,
        handleGetQuery: true,
        handleDelete: false,
    
        paramIds: [ &#x27;_id&#x27; ],
    
        driverGetDbQuery: function( params, body, options, cb ){
          
          var self = this;
    
          UserStrategies.GetQuery( { filters: { strategyId: &#x27;local&#x27;, field1: options.filters.login } }, function( err, res ){
            if( err ){
              cb( err, null );
            } else {
              if( res.length ){
                self.schema.makeId( res, function( err, id ){
                  cb( null, [ { login: options.filters.login, _id: id } ] );
                });
              } else {
                cb( null, [ ] );
              }
            }
          });      
    
        },   
    
        publicURL: &#x27;/userLogins/&#x27;,
    
      });
    
    
      done( null, [ stores.Users, stores.UserStrategies, stores.AuthStrategies, stores.UserLogins ] );

    }
  });

})

/**
Sets recover URL &#x60;/recover/:recoverToken&#x60; (for token recovery).  
Also goes through the list of &#x60;AuthStrategies&#x60;, loads the right
files in &#x60;auth/{strategy name}.js&#x60; (e.g. {{#crossLink &quot;hotCoreAuth.facebook&quot;}}{{/crossLink}}), and runs them.
This basically ensures that all strategies have the right URLs all set for them to work.

@event run
*/
hotplate.hotEvents.on( &#x27;setRoutes&#x27;, function( app, done ){

  hotCoreStoreRegistry.getAllStores( function( err, storesData ){
    if( err ){
      done( err );
    } else {

      // 
      var stores = storesData.stores;

      app.get(&#x27;/recover/:recoverToken&#x27;, function( req, res, next ){
    
        stores.users.Store.GetQuery( { filters: { recoverToken: req.params[ &#x27;recoverToken&#x27; ] } }, function( err, result ){
          if( err ){
            done( err, null );
          } else {
            if( result.length == 0 ){
              // Error page
    
              // Artificially create a TokenInvalid error, and next( err ) it 
              var error = new Error();
              error.name = &quot;TokenInvalidError&quot;;
              error.message = &quot;Token not valid!&quot;;
              req.hotError = error;
              next( error );
    
            } else {
            
              var user = result[0];
    
              if( ! user.recoverTokenCreated ){
    
                // Artificially create a TokenDateInvalid error, and next( err ) it 
                var error = new Error();
                error.name = &quot;TokenDateInvalidError&quot;;
                error.message = &quot;Token date invalid!&quot;;
                req.hotError = error;
                next( error );
              } else {
    
                // Get the important variables 
                var tokenAgeInSeconds = Math.round( ( (new Date() ) - user.recoverTokenCreated ) / 1000 );
                var recoverURLexpiry = hotplate.config.get( &#x27;hotCoreAuth.recoverURLexpiry&#x27; ); 
    
                var tokenIsGood = tokenAgeInSeconds &lt; recoverURLexpiry;
    
                if( ! tokenIsGood ){
    
                  // Artificially create a TokenExpired error, and next( err ) it 
                  var error = new Error();
                  error.name = &quot;TokenExpiredError&quot;;
                  error.message = &quot;Token expired!&quot;;
                  req.hotError = error;
                  next( error );
    
                } else {
    
                  delete user.recoverToken;
                  delete user.recoverTokenCreated;
    
                  stores.users.Store.Put( user._id, user, function( err, userNew ){
                    if( err ){
                      next( err );
                    } else {
    
                      // Log the user in using the token!
                      req.session.loggedIn = true;
                      req.session.userId = user._id;
    
                      // Redirect to the right URL
                      res.redirect( hotplate.config.get(&#x27;hotCoreAuth.redirectURLs.success.recover&#x27;) );
                    }
      
                  });
                }
                 
    
              }
              
            }
              
          }
        });
    
    
      }); 
    
    
    
      function makeResponder( req, res, next, strategyId, action ) {
    
        return function(err, user, profile ) {
    
          var responseType, strategies;
            
          // #2      
    
          var k = req.cookies[ strategyId + &#x27;-&#x27; + action ];
          if( typeof( k ) !== &#x27;undefined&#x27; ){
            responseType = k;
          }
    
          // Fallback option
          if( ! responseType ) responseType = &#x27;redirect&#x27;;
    
          // Defaults to an empty profile object
          if( typeof( profile ) === &#x27;undefined&#x27; ){
            profile = {};
          }
    
          // Error: just return/next that
          if( err ) { return next( err ); }
    
          // #1
    
          switch( responseType ){
    
            case &#x27;content&#x27;:
    
                // Work out the page&#x27;s content by calling the user-set hotCoreAuth/responsePage function
                // Note: if hotCoreAuth/responsePage is not set, it will use a placeholder fallback string
                var content;
                var contentFunction = hotplate.store.get( &#x27;hotCoreAuth.responsePage&#x27; );
                if( typeof( contentFunction ) === &#x27;function&#x27; ){
                  content = contentFunction( strategyId, action, user, profile );
                } else {
                  content = &quot;PLEASE SET hotCoreAuth/responsePage IN YOUR SERVER FILE TO CUSTOMIZE CONTENTS&quot;;
                }
    
    
                // Send the contents
                res.send( content );      
            break;
    
    
    
            case &#x27;close&#x27;:
    
              if( ! user &amp;&amp; typeof( profile.message) !== &#x27;undefined&#x27;  ){
                
                // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
                res.send(&#x27;&lt;html&gt;&lt;script&gt;window.opener.alert(&quot;&#x27; + profile.message + &#x27;&quot;);window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
              } else {
                res.send(&#x27;&lt;html&gt;&lt;script&gt;window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
              }
            break;
    
            case &#x27;ajax&#x27;:
    
              if( user ){
                res.json( 200, { user: user, profile: profile } );
              } else {
                var error = &#x27;Authentication error&#x27;;
                if( typeof( profile.message) !== &#x27;undefined&#x27; ) error =  profile.message;
                res.json( 403, { message: error } );
              }
    
            break;
    
    
            case &#x27;redirect-opener&#x27;:
    
              if( ! user &amp;&amp; typeof( profile.message) !== &#x27;undefined&#x27;  ){
    
                // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
                res.send(&#x27;&lt;html&gt;&lt;script&gt;window.opener.alert(&quot;&#x27; + profile.message + &#x27;&quot;);window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
                
              } else {
                var redirectURL = hotplate.config.get(&#x27;hotCoreAuth.redirectURLs.success.&#x27; + action) || &#x27;/&#x27;;
                res.send(&#x27;&lt;html&gt;&lt;script&gt;window.opener.location = &quot;&#x27; + redirectURL + &#x27;&quot;;window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
              }
            break;
    
    
            case &#x27;redirect&#x27;:
            default:
    
              if( user ){
                var redirectURL = hotplate.store.get(&#x27;hotCoreAuth.redirectURLs.success.&#x27; + action) || &#x27;/&#x27;;
                res.redirect( redirectURL );
              } else {
    
                // Add the error to the session messages
                if( typeof( profile.message) !== &#x27;undefined&#x27;  ){
                  req.session.messages = req.session.messages || []; 
                  req.session.messages.push( { type: &#x27;error&#x27;, message: profile.message } );
                }
    
                var redirectURL = hotplate.store.get(&#x27;hotCoreAuth.redirectURLs.fail.&#x27; + action) || &#x27;/&#x27;;
                res.redirect( redirectURL );
              }
            break;
    
          }
    
        }
      }
    
      if( typeof( hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27; )) === &#x27;object&#x27; ){
        Object.keys( hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27; )).forEach( function( strategyName ) {
        
          // Get the strategy&#x27;s data
          var strategyConfig = hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27; )[strategyName];
    
          // Gets the right strategy maker and runs it
          strategyMaker = require( &#x27;./auth/&#x27; + strategyName );
          strategyMaker( app, strategyConfig, makeResponder, stores.authStrategies.Store, stores.users.Store, stores.userStrategies.Store, stores.userLogins.Store );
        });
    
      }
    
      done( null );
    }
  });

})


hotplate.hotEvents.on( &#x27;pageElements&#x27;, &#x27;hotCoreAuth&#x27;, function( done ){
  var strategyIds = Object.keys( hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27;) ) || [];
  
  done( null, {
    vars: [
            { name: &#x27;strategyIds&#x27;,  value: strategyIds },
            { name: &#x27;successURLs&#x27;,  value: hotplate.config.get(&#x27;hotCoreAuth.redirectURLs.success&#x27;) },
            { name: &#x27;failURLs&#x27;,     value: hotplate.config.get(&#x27;hotCoreAuth.redirectURLs.fail&#x27;) },
          ],
  });
});


hotplate.hotEvents.on( &#x27;pageElementsPerPage&#x27;, &#x27;hotCoreAuth&#x27;, function( elements, req, pageName, done ){

  var vars = [];

  // Add the user ID to the page as a variable
  if( req.session.userId ) {
    vars.push( { name: &#x27;userId&#x27;, value: req.session.userId } );
  }

  done( null, {
    vars: vars 
  });

});



    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
