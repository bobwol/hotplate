var dummy
  , hotplate = require('hotplate')

  , e = require('allhttperrors')

  , Schema = require('simpleschema')
  , MongoSchemaMixin = require('simpleschema/MongoSchemaMixin.js')

  , Store = require('jsonreststores')
  , MongoDriverMixin = require('jsonreststores/MongoDriverMixin.js')

  , declare = require('simpledeclare')
;

var app = hotplate.app;

var hooks = exports.hotHooks = {}

hooks.init = function( done ){

  var hotCoreJsonRestStores = hotplate.getModule( 'hotCoreJsonRestStores' );

  Store = declare( [ Store, MongoDriverMixin, hotCoreJsonRestStores.StoreMixin ]  );
  Schema = declare( [ Schema, MongoSchemaMixin, hotCoreJsonRestStores.SchemaMixin ] );

  // ***********************************
  // *** WORKSPACES ********************
  // ***********************************

  var Workspaces = exports.Workspaces = declare( Store, {

    // COMMON
    schema: new Schema({
      _id:           { type: 'id' },
      workspaceName: { type: 'string', searchable: true, searchPartial: false,
                       sortable: false, notEmpty: true, sharedValidator: 'workspace', trim: 128 },
      ownerUserId:   { type: 'id' }, 
    }
    // #2
    ),

    handlePost: true,
    checkPermissionsPost: function( params, body, options, cb ){
      // Needs to be logged in
      if( ! this._req.session.userId ) return cb( null, false );
     
      // Make sure that body.ownerUserId IS indeed the logged in user
      body.ownerUserId = this._req.session.userId;

      cb( null, true );
    },

    // #1

    storeName:  'workspaces',
    paramIds: [ '_id' ],

    // #5

    // If creating a new workspace, and the user is logged in, then
    // assign the creating user to that workspace
    afterPost: function( params, body, options, doc, fullDoc, cb ){

      if( this.remote && this._req.session.loggedIn ){
        var userId = this._req.session.userId;
        if( userId ){
           // Note: this calls the callback
           WorkspaceUsers.Post( { userId: userId, workspaceId: doc._id }, {}, cb );
        } else {
          cb( null );
        }
      }
    },
    publicURL: '/workspaces/',

  });


/*
  var WorkspaceInvites = exports.WorkspaceInvites = declare( Store, {

    schema: new Schema({
      workspaceId: { type: 'id' },
      inviteCode:  { type: 'string' },
      email     :  { type: 'string' },
      name      :  { type: 'string' },
      _id:         { type: 'id' },
    }),

    handlePut: false,
    handlePost: true,
    handleGet: true,
    handleGetQuery: true,
    handleDelete: true,

    searchSchema: new Schema({
      workspaceId: { type: 'id' },
      userId:      { type: 'id' },
      _id:         { type: 'id' },
    }),

    storeName:  'workspaceInvites',
    paramIds: [ 'workspaceId', '_id' ],
    publicURL: '/workspaces/:workspaceId/invites/',
  });
  //WorkspaceInvites.onlineAll( app, '/workspaces/:workspaceId/invites', ':_id' );
*/


  // The basic schema for the WorkspaceUsers table
  var WorkspacesUsersBase = exports.WorkspacesUsersBase = declare( Store, {

    schema: new Schema({
      userId:      { type: 'id' },
      workspaceId: { type: 'id' },
      _id:         { type: 'id' },
    }),

    storeName: 'workspacesUsersBase',
    collectionName: 'workspaceUsers',

    paramIds: [ '_id' ],
  });


  var WorkspaceUsers = exports.WorkspaceUsers = declare( WorkspacesUsersBase, {

    searchSchema: new Schema({
      workspaceId: { type: 'id' },
      userId:      { type: 'id' },
      _id:         { type: 'id' },
    }),

    storeName:  'workspaceUsers',
    paramIds: [ 'workspaceId', '_id' ],
    publicURL: '/workspaces/:workspaceId/users/',
  });
  //WorkspaceUsers.onlineAll( app, '/workspaces/:workspaceId/users', ':_id' );

  var UserWorkspaces = exports.UserWorkspaces = declare( WorkspacesUsersBase, {

    searchSchema: new Schema({
      userId:        { type: 'id' },
      workspaceId:   { type: 'id' },
      _id:           { type: 'id' },
   // workspaceName: { EXTERNAL FROM workspaces } 
    }),

    storeName:  'userWorkspaces',
    paramIds: [ 'userId', '_id' ],

    handleGetQuery: true,
    checkPermissionsGetQuery: function( params, body, options, cb ){
      // Only their own strategies
      if( this._req.session.userId != params.userId ) return cb( null, false );
      cb( null, true );
    },


    // Get the much needed workspaceName from the Workspaces table
    prepareBeforeSend: function( doc, cb ){

      var self = this;

      Workspaces.Get( doc.workspaceId, {}, function( err, otherDoc ){
        self._sendErrorOnErr( err, cb, function(){

          doc.workspaceName = otherDoc.workspaceName;
          cb( null, doc );
        })
      })

    },

    publicURL: '/users/:userId/workspaces/',

  });

  //UserWorkspaces.onlineAll( app, '/users/:userId/workspaces/', '_id' );

  done( null );
}
hooks.init.after = [ 'hotCoreJsonRestStores' ];



hooks.stores = function( done ){

  done( null,  {
    moduleName: 'hotCoreMultiHome', result: [ exports.Workspaces, exports.WorkspaceInvites, exports.WorkspaceUsers, exports.UserWorkspaces ]
    }
  );

}

// Export config variables
hooks.pageElements = function( done ){

  done( null, { moduleName: 'hotCoreMultiHome', result: {
    vars:  [
             { name: 'enabled',      value: hotplate.get('hotCoreMultiHome').enabled },
             { name: 'multiHomeURL', value: hotplate.get('hotCoreMultiHome').multiHomeURL },
           ],
  } } );
}



    // #1
    /*
    // Only owner can put
    handlePut: true,
    checkPermissionsPutNew: function( params, body, options, cb ){
      if( params._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },
    checkPermissionsPutExisting: function( params, body, options, doc, fullDoc, cb ){
      if( doc._id == this._req.session.userId ) return cb( null, true );
      cb( null, false );
    },
    */

    // #2
    /*
    {
      // Avoid dupes in workspace names: if name taken, add validation error to `error` array
      // Ajax will make sure that this check doesn't normally fail after submit
      // DB index should make DEAD sure that a hard error happens in case of name overlap
      // (in case of two requests at the exact same time for the exact same workspace)
      validator: function( schema, errors, cb ){
        Workspaces.GetQuery( { filters: { workspaceName: this.workspaceName } }, function( err, result ){
          if( err ){
            cb( err );
          } else {
            if( result.length ){
              errors.push( { field: 'workspaceName', message: 'Workspace name taken' } );
            }
            cb( null );
          }
        });

      },
    }
    */





      // #3


    // Allow anybody to search by workspace name, even though they are not
    // logged in
    /*
    handleGetQuery: true,
    checkPermissionsGetQuery: function( params, body, options, cb ){

      if( typeof( options.filters ) === 'object' && ( options.filters._id  || options.filters.ownerUserId )  ){
        return cb( null, false );
      }

      return( null, true );
    },
    */


