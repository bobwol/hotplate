var 
  dummy
, hotplate =  require('hotplate')
, path = require('path')
, async = require('async')
, util = require('util')
, db = hotplate.get('db')
, ObjectId = require('mongowrapper').ObjectId
, checkObjectId = require('mongowrapper').checkObjectId
, e = require('allhttperrors')
;


/*
  // Sets the Workspace schema, which is simply a list with name, active flag,
  // and the list of users who can access it (though the [Access] schema)
  var Tab = new Schema({
    // _id            : { type: ObjectId, index: true },  // TODO: Why if this is defined, it doesn't get created?
    userId         : { type: ObjectId, index: true },
    workspaceId    : { type: ObjectId, index: true },
    lastSync       : { type: Date, index: true },

    messages: [{
      from      : { type: ObjectId, index: true },
      type      : { type: String,   index: true },
      message   : { type: Schema.Types.Mixed },
    }],
  });
*/

var app = hotplate.app;

exports.hotHooks = hooks = {}

hooks.init = function( done ){

  done( null );
}


hooks.run = function( done ){
  app.post( '/call/:workspaceId/sync/:tabId', pollSync );
  app.get(  '/call/:workspaceId/register', registerSync );
  app.post( '/call/:workspaceId/unregister', unregisterSync );

  // Delete unused tabs, now and then every 4 minutes
  unregisterOldTabs();
  setInterval( unregisterOldTabs, 1000 * 60 * 4 ); 

  done( null );
}

// Simply activate path to client files
hooks.clientPaths = function( done ){
  done( null, { moduleName: 'hotCoreCometMessages', result: [ path.join(__dirname, '../client') ] } );
}


function registerTab( userId, workspaceId, cb){
  var tabs = db.collection('tabs');

  var tab = new Object();
  tab.userId = userId;
  tab.workspaceId = workspaceId;
  tab.lastSync = new Date();
  tab.messages = [];

  tabs.insert( tab, cb );
}

function unregisterOldTabs( cb ){
  var tabs = db.collection('tabs');

  // The callback needs to be there full stop
  cb = cb || function(){} 

  var fiveMinutesAgo = new Date();
  fiveMinutesAgo.setMinutes( fiveMinutesAgo.getMinutes() - 5 );

  tabs.remove( { lastSync: { $lt: fiveMinutesAgo } }, cb );
}

function unregisterTab( tabId, cb ){
  var tabs = db.collection('tabs');

  // The callback needs to be there full stop
  cb = cb || function(){} 

  tabs.remove( { _id: tabId }, cb );
}

function retrieveTab( tabId, cb ){
  var tabs = db.collection('tabs');

  // The callback needs to be there full stop
  cb = cb || function(){} 

   tabs.findAndModify( { _id: tabId }, [[ '_id', 1 ]], { $set: { lastSync: new Date() } }, cb );
}

function sendToTabsOfWorkspace(toWorkspaceId, excludeTabId, fromUserId, type, message, cb){
  var tabs = db.collection('tabs');

  excludeTabId = ObjectId( excludeTabId );

  // The callback needs to be there full stop
  cb = cb || function(){} 

  var fiveMinutesAgo = new Date();
  fiveMinutesAgo.setMinutes( fiveMinutesAgo.getMinutes() - 5 );

  tabs.update( { workspaceId: toWorkspaceId, _id: { $ne: excludeTabId}, lastSync: { $gt: fiveMinutesAgo } },
               { $push: { messages: { from: fromUserId, type: type, message: message }  } }, 
               { multi: 1 },
               cb );
};

exports.sendToTabsOfWorkspace = sendToTabsOfWorkspace;

function sendToTabsOfUser( toUserId, excludeTabId, fromUserId,  type, message, cb ){
  var tabs = db.collections('tabs');

  excludeTabId = ObjectId( excludeTabId );

  // The callback needs to be there full stop
  cb = cb || function(){} 

  var fiveMinutesAgo = new Date();
  fiveMinutesAgo.setMinutes( fiveMinutesAgo.getMinutes() - 5 );
  
  tabs.update( { userId: toUserId, _id: { $ne: excludeTabId}, lastSync: { $gt: fiveMinutesAgo } },
               { $push: { messages: { from: fromUserId, type: type, message: message }  } }, 
               { multi: 1 },
                cb );
}

function sendToSiblingTabs( tabId, fromUserId,  type, message, cb ){
  var tabs = db.collections('tabs');


  var fiveMinutesAgo = new Date();
  fiveMinutesAgo.setMinutes( fiveMinutesAgo.getMinutes() - 5 );

  // The callback needs to be there full stop
  cb = cb || function(){} 

  tabs.update( { userId: toUserId, _id: { $ne: excludeTabId}, lastSync: { $gt: fiveMinutesAgo } },
               { $push: { messages: { from: fromUserId, type: type, message: message }  } }, 
               { multi: 1 },
                cb );
}



function clearMessagesOfTab( tabId, cb ){
  var tabs = db.collection('tabs');

  // The callback needs to be there full stop
  cb = cb || function(){} 

  tabs.update( { _id: tabId }, { $set: { messages: [] } }, cb );
}

function registerSync( req, res, next ){
  var sendResponse = hotplate.getModule('hotCoreProtocol').sendResponse;

  registerTab( req.application.user._id, req.application.workspace._id, function( err, doc ){
    if( err ){
      next( err );
    } else {
      sendResponse( res, { tabId: doc[0]._id } );
    }
  });
}

function pollSync( req, res, next ){

  var sendResponse = hotplate.getModule('hotCoreProtocol').sendResponse;
  var tabId = req.params.tabId;

  // Get the messages from Json, safely
  try {
    if( ! req.body.messages )
      throw( new Error("req.body.messages not there") );
    var messages = JSON.parse(req.body.messages);
  } catch(e) {
    var messages = [];
  }

  // Usual sanity checks
  if( ! checkObjectId(tabId) ){
    next( new e.UnprocessableEntityError( "Tab id not valid" ) );
    return;
  }

  tabId = ObjectId( tabId );

  placeMessagesInQueue( function(err ){
    if( err ){
      next( err );
    } else {
      returnMessages();
    };
  })


  function placeMessagesInQueue( cb ){

    // Send data out first
    if( messages && Array.isArray(messages) ){

     messages.forEach( function(item) {
        if( item.type !== 'reset' ){
          if( item.toType === 'toMyTabs'){
            sendToTabsOfUser( req.application.user._id, tabId,      req.application.user._id, item.type, item.message );
          }
          if( item.toType === 'toEverybody'){
            sendToTabsOfWorkspace( req.application.workspace._id, tabId,      req.application.user._id, item.type, item.message );
          }
        }
      });

    } 

    cb(null);
  }


  function returnMessages(){

    // Attempt to retrieve the tab's info
    retrieveTab( tabId, function( err, doc ){
      if( err ){
        next( err );
      } else {

        // Document returned, check that it's owned by the caller, send messages and clear
        if( doc ){
          sendResponse( res, doc.messages );
          clearMessagesOfTab( tabId ); // Nothing we can do if this doesn't work

        // Nothing returned: tab doesn't exist, creating a new one and letting client know
        } else {
          registerTab(  req.application.user._id, req.application.workspace._id, function( err, doc ){
            if( err ){
              next( err ); 
            } else {
              var messages = [];
              messages.push( { from: req.application.user._id, type: 'reset', message: { tabId: doc[0]._id } } );
              sendResponse( res, messages );
            }
          });
        }
      }
    });
  }
}


function unregisterSync( req, res, next ){

  var sendResponse = hotplate.getModule('hotCoreProtocol').sendResponse;
  var tabId = req.body.tabId;

  // Usual sanity checks
  if( ! checkObjectId(tabId) ){
    
    next( new e.UnprocessableEntityError( "Tab id not valid" ) );
    return;
  }

  tabId = ObjectId( tabId );
  unregisterTab( tabId, function(err, doc ){
    if( err ){
      next( err );
    } else {
      sendResponse( res );
    }
  });

}
