define([
   "dojo/_base/declare",
   "dojo/when",
   "dojo/topic",
   "dojo/on",
   "dojo/_base/lang",
   "dojo/dom-construct",
   "dojo/dom-style",
   "dojo/dom-attr",
   "dojo/dom-geometry",
   "dojo/aspect",

   "dijit/_WidgetBase",
   "dijit/Dialog",
   "dijit/_OnDijitClickMixin",
   "dijit/focus",
   "dijit/form/Button",
   "dijit/layout/BorderContainer",
   "dijit/_Container",
   "dijit/layout/_ContentPaneResizeMixin",
   "dijit/_TemplatedMixin",
   "dijit/_WidgetsInTemplateMixin",
   "dijit/_CssStateMixin",
   "dijit/form/_FormValueMixin",

   'dgrid/List',
   'dgrid/OnDemandList',
   "dgrid/Selection",
   "dgrid/Keyboard",
   "dgrid/util/mouse",
   "dgrid/extensions/DijitRegistry",
   'put-selector/put',

   "hotplate/hotDojoSubmit/defaultSubmit",
   "hotplate/hotDojoWidgets/BusyButton",
   "hotplate/hotDojoWidgets/ConfirmDialog",

   ], function(
     declare
     , when
     , topic
     , on
     , lang
     , domConstruct
     , domStyle
     , domAttr
     , domGeometry
     , aspect

     , _WidgetBase
     , Dialog
     , _OnDijitClickMixin
     , focusUtil
     , Button
     , BorderContainer
     , _Container
     , _ContentPaneResizeMixin
     , _TemplatedMixin
     , _WidgetsInTemplateMixin
     , _CssStateMixin
     , _FormValueMixin

     , List
     , OnDemandList
     , Selection
     , Keyboard
     , mouse
     , DijitRegistry
     , put

     , ds
     , BusyButton
     , ConfirmDialog

 ){


    return declare( [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, _Container, _ContentPaneResizeMixin, _OnDijitClickMixin, _FormValueMixin ] , {

      templateString: '<div class="store-select">\n' +
                      '    <div data-dojo-attach-point="itemNode" class="picked">\n'+
                      '      <div class="label button"><div data-dojo-attach-point="focusNode,labelNode">Pick</div></div>\n' +
                      '      <div class="arrow button"></div>\n' +
                      '    </div>\n'+
                      '    <div data-dojo-attach-point="listWidgetNode" class="dgrid-spot"></div>\n'+
                      '    <input type="hidden" ${!nameAttrSetting} data-dojo-attach-point="valueNode" value="${value}" aria-hidden="true" />\n'+
                      '</div>\n'+
                      '\n'+
                      '',


      widgetsInTemplate: true,

      // Store
      store: null,

      // Store name. Useful for topics etc.
      storeName: '',

      // Query, and query options
      query: {},
      queryOptions: {},

      // renderRow which will be used by the created dgrid.
      // It needs to be defined
      renderRow: function( o ){ return "renderRow not defined"; } ,

      // The list widget
      listWidget: null,

      // Whether the listWidget is visible or not
      expanded: false,

      // When automatically moving based on the current window,
      // the minimum distance to the bottom
      distanceFromBottom: 20,

      // Proxy method for listwidget.row()
      row: function( p ){
        if( this.listWidget ){
          return this.listWidget.row( p );
        }
      },

      resize: function(){
        this._moveIfNecessary();
        this.inherited(arguments); 
      },

      destroy: function(){
        this.listWidget.destroy();
        this.inherited(arguments); 
      },


      // STOLEN FROM _FormWidget.js
      postMixInProperties: function(){
        // Setup name=foo string to be referenced from the template (but only if a name has been specified)
        // Unfortunately we can't use _setNameAttr to set the name due to IE limitations, see #8484, #8660.
        // Regarding escaping, see heading "Attribute values" in
        // http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
        this.nameAttrSetting = this.name ? ('name="' + this.name.replace(/"/g, "&quot;") + '"') : '';
        this.inherited(arguments);
      },

      // Override automatic assigning type --> focusNode, it causes exception on IE.
      // Instead, type must be specified as ${type} in the template, as part of the original DOM
      _setTypeAttr: null,

      // Sets valueNode in the DOM
      _setValueAttr: function(value){

        this.inherited(arguments);
        var self = this;

        self._set( 'value', value );

        // Set the valueNode (the hidden field in this widget)
        // domAttr.set(this.valueNode, "value", this.get("value"));
        domAttr.set(this.valueNode, "value", value);

        // Sets the value of the labelNode so that it displays
        // the right value (only if `row()` works )
        var row = self.row( value );
        //setTimeout( function(){

          //row = self.row( value ); 

          if( row && row.data ){
            self.labelNode.innerHTML = '';
            put( self.labelNode, self.renderRow( row.data ) );
          }

        //}, 1000 );

      },

      postCreate: function(){

        this.inherited(arguments); 

        var self = this;
        var PPPP = this;

        // Make up the constructor for the select list. It's basically a dgrid, with the
        // renderRow set as the parent's, and single selection mode
        var ListConstructor = declare( [ OnDemandList, Selection, Keyboard, DijitRegistry ], {
          renderRow: self.renderRow,
          selectionMode: 'single',

          // Adding and deleting rows will trigger the "position calculation"
          // function to make sure that the select list is not ourside of the
          // visible area
          newRow: function(){
            var r = this.inherited(arguments);
            self._moveIfNecessary();
            return r;
          },
          removeRow: function(){
            var r = this.inherited(arguments);
            self._moveIfNecessary();
            return r;
          },
          
        } );

        // Make the dgrid widget. Note that query and queryOptions NEED to
        // be passed to the widget via the constructor
        self.listWidget = new ListConstructor( {
          store: self.store,
          query: self.query,
          queryOptions: self.queryOptions,
        });


        // Place the grid, invisible, in the right node, start it up, and
        // make it invisible
        domConstruct.place( self.listWidget.domNode, self.listWidgetNode );
        self.listWidget.startup();
        domStyle.set( self.listWidget.domNode, { display: 'none' } );

        // Load value
        // self._renderValue().then( connectUp, connectUp );
        connectUp();

        function connectUp(){
          
          self.listWidget.on("dgrid-select", function( e ) {
            var rowId = e.rows[0].id;
            self.set( 'value', rowId );
          });

          self.own( 

            // If this store is updated, and the change is in the selected item,
            // refresh the selected item
            topic.subscribe('storeRecordUpdate', function( from, message ){
              if( message.storeName === self.storeName && message.objectId === self.value ){
                self.labelNode.innerHTML = '';
                put( self.labelNode, self.renderRow( message.object ) );
              }
            }),
            topic.subscribe('storeRecordRemove', function( from, message){
              if( message.storeName === self.storeName && message.objectId === self.value ){
                self.labelNode.innerHTML = 'Item deleted';
              }
            }),


            // The following code makes sure that, if there is a "refreshData" topic, then
            // 1) The list itself is refreshed
            // 2) The *picked* element is refreshed
            // The picked element is refreshed only when an event dgrid-refresh-complete happens,
            // as `self.listWidget.refresh()` is asynchronous and might take a while to actually work...
            //
            topic.subscribe('refreshData', function( ){
              self.listWidget.refresh();
            }), 
            on( self.listWidget.domNode, 'dgrid-refresh-complete', function( e ){
               console.log("Refreshed: time to refresh the picked value too");
               self.set( 'value', self.value );
            }),


            // Escape pressed at body level: close the select box, select
            // value that selected in the first place when it was open
            on( document.body, 'keydown', function( e ) {
              if( e.keyCode == 27 && self.expanded){
                domStyle.set( self.listWidget.domNode, { display: 'none' } );
                self.expanded = false;
                self.listWidget.clearSelection();
                self.listWidget.select( self.valueWhenOpen );
              }
            }),


            // Open or close when pressing enter
            on( self.domNode, 'keydown', function( e ){
              if( e.keyCode == 13 ){
                if( ! self.expanded  ){
                  expandList();
                } else {
                  collapseList( self.row( e ) );
                }
              }
            }),

            // Open or close when clicking on it with mouse
            on( self.domNode, 'click', function( e ){
              if( ! self.expanded ){ 
                expandList();
              } else {
                collapseList( self.row( e ) );
             }
            }),


            // Focus out: hide the select box
            // FIXME: Haven't quite managed this one yet
            on( document.body, 'click', function( e ) {
              if( self.expanded){
              //  domStyle.set( self.listWidget.domNode, { display: 'none' } );
              //  self.expanded = false;
              }
            })

          );

          // Function to expand the widget to include the select list.
          // It will do all of the required operations: make it visible in the CSS,
          // give the focus to the right element, mark it as "expanded", and move it
          // if necessary to do so (e.g. its bottom is out of the visible screen)
          function expandList(){
            self.valueWhenOpen = self.value;
            domStyle.set( self.listWidget.domNode, { display: 'block' } );
            var r = self.row( self.value );
            self.listWidget.focus( r );
            self.expanded = true;
            self._moveIfNecessary();
          }

          // Function to collapse the widget so that the select list is no longe there.
          // It will just make it invisible, but it will also set the widget value to
          // the row element. This is to be called once a pick is successful, either
          // with an Enter or with a mouse click.
          function collapseList( row ){

            domStyle.set( self.listWidget.domNode, { display: 'none' } );
            self.expanded = false;
            if( row ){ 
              self.set( 'value', row.id);
            }
          }
        }

      },

      // Te dgrid might grow to the point that its bottom is outside of the
      // actual visible area. This would be bad (the bottom elements would be
      // unreachable). So, it calculates things up and makes sure that the dgrid
      // is moved up, also considering the required self.distanceFromBottom
      _moveIfNecessary: function(){
        var self = this;

        //self.listWidget.resize();
        domStyle.set( self.listWidget.domNode, { top: '' } );
        var bodyBox = domGeometry.getContentBox( document.body );
        var listBox = domGeometry.position( self.listWidget.domNode, true );
        var delta = bodyBox.h - ( listBox.y + listBox.h ) - self.distanceFromBottom;
        if( delta < 0 ){
          domStyle.set( self.listWidget.domNode, { top: (delta)+'px' } );
        } else {
          domStyle.set( self.listWidget.domNode, { top: '' } );
        }


      },

    });
 

});


      /*
      _renderValuePROBABLYOBSOLETE: function(){

        var self = this;

        return when( 1 );

        // A record was selected beforehand: load it up.
        //
        // FIXME: Optimise. If the query for the list of objects
        // includes the one selected, then don't fire up the
        // lookup.
        if( self.value ){
          self.labelNode.innerHTML = "Loading...";
          
          var q = {};
          q[ self.store.idProperty ] = self.value;
          var promise = when( self.store.query( q, { start: 0, count: 1 }  ) ).then(

            function( res ) {
              if( res.length == 1 ){
                var rowId = self.store.getIdentity( res[0] );
                self.set( 'value', rowId );
                console.log("AFTER SET:");
                console.log( self );
                self.listWidget.select( rowId );
              } else {
                self.labelNode.innerHTML = 'Error loading item!';
                self.set( 'value', '' );
              }
            },
            function( err ){
              self.labelNode.innerHTML = 'Error loading item!';
              self.set( 'value', '' );
            }
          );

        }

        return when( promise );

      },
      */


