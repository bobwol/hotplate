{
  "name": "resthttperrors",
  "description": "A module with a bunch of pre-defined HTTP errors",
  "keywords": [
    "javascript",
    "http",
    "errors"
  ],
  "main": "HTTPErrors.js",
  "version": "0.0.2",
  "private": false,
  "repository": {
    "type": "git",
    "url": "git://github.com/mercmobily/HTTPErrors.git"
  },
  "author": {
    "name": "Tony Mobily"
  },
  "dependencies": {},
  "readme": "HTTPErrors\n==========\n\nThis is a simple bunch of HTTP errors, which include handy properties to know what they are and what their status code should be.\n\n## BadRequestError (400)\n\nThis error is triggered when the URL has a problem. In web applications, this is often triggered when the ID of a resource in an URL is not in the right format. This is why its constructor has errorFields, as well as the message:\n\n    e['BadRequestError'] = function( message, errorFields ){\n      this.httpError = 400;\n      this.message = message || 'Bad request';\n      this.name = 'BadRequestError';\n      this.errorFields = errorFields;\n    }\n    util.inherits(e['BadRequestError'], Error);\n\n## UnauthorizedError (401)\n\nThis error is used when a user needs to login in order to access a resource. Nothing fancy here:\n\n    e['UnauthorizedError'] = function( message ){\n      this.httpError = 401;\n      this.message = message || 'Login necessary to access the requested resource';\n      this.name = 'UnauthorizedError';\n    }\nutil.inherits(e['UnauthorizedError'], Error);\n\n## ForbiddenError (403)\n\nThis error is used when even though a user may be logged in, they might not have the right permissions to access a specific resource. Nothing fancy here:\n\n    e['ForbiddenError'] = function( message ){\n      this.httpError = 403;\n      this.message = message || 'Access to resource denied';\n      this.name = 'ForbiddenError';\n    }\nutil.inherits(e['ForbiddenError'], Error);\n\n## NotFoundError (404)\n\nWe all know this one. One of the few errors for which even non-developers know its code...\n\ne['NotFoundError'] = function( message ){\n  this.httpError = 404;\n  this.message = message || 'Resource not found';\n  this.name = 'NotFoundError';\n}\nutil.inherits(e['NotFoundError'], Error);\n \n\n## PreconditionFailedError (404)\n\nThis error is triggered when a precondition is not met. For example, the user has sent the header `if-match: *` and has requested a PUT on a resource that doesn't exist. Nothing fancy:\n\n    e['PreconditionFailedError'] = function( message ){\n      this.httpError = 412;\n      this.message = message || 'Precondition failed';\n      this.name = 'PreconditionFailedError';\n    }\n    util.inherits(e['PreconditionFailedError'], Error);\n\n## ValidationError (422)\n\nA very common error. It happens when a field in an online form has a field that doesn't pass validation. The constructor has the message, as well as a second field `errorFields` which is an object in the format `{ field: \"Error message\", anotherField: \"Another error message\" }`. The server, when this error happens, is meant to send something back to the client probably highlighting the affected fields with the message\n\n    e['ValidationError'] = function( message, errorFields ){\n      this.httpError = 422;\n      this.message = message || 'Validation problem';\n      this.name = 'ValidationError';\n      this.errorFields = errorFields;\n    }\n    util.inherits(e['ValidationError'], Error);\n\n## NotImplementedError (501)\n\nAn error when a client asks to PUT when they shouldn't be. Nothing fancy here.\n\n    e['NotImplementedError'] = function( message ){\n      this.httpError = 501;\n      this.message = message || \"Method not implemented\";\n      this.name = 'NotImplementedError';\n    }\n    util.inherits(e['NotImplementedError'], Error);\n\n\n## RuntimeError (503)\n\nAnother error often known to lay people. When an application bombs, this is what should be triggered. The database server connection might have failed, or a database lookup that _ought to_ have worked failed. The \"trick\" is to 1) Create a new RuntimeError 2) Create the RuntimeError passing it a not-so-scary message and the `originalError` to it 3) Give the user a not-so-scary message 4) Log the original error in the application, so that you can see what _actually_ happened. Here's the code:\n\n    e['RuntimeError'] = function( message, originalError ){\n      this.httpError = 503;\n      this.message = message || \"Runtime error\";\n      this.name = 'RuntimeError';\n      this.originalError = originalError;\n    }\n    util.inherits(e['RuntimeError'], Error);\n\n\n",
  "readmeFilename": "README.md",
  "_id": "resthttperrors@0.0.2",
  "dist": {
    "shasum": "537ecf13535a60b6a6de20c17b1c2d525cce5cea"
  },
  "_from": "resthttperrors@",
  "_resolved": "https://registry.npmjs.org/resthttperrors/-/resthttperrors-0.0.2.tgz"
}
